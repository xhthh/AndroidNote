### Java虚拟机

#### 一、Java内存区域相关

##### 1、jvm内存结构，堆和栈的结构、栈帧？

Java虚拟机管理的内存分为以下几个运行时数据区域：

- 程序计数器

  <font color='red'>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</font>

  分支、循环、跳转、异常处理、线程恢复都需要依赖程序计数器。

  由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，用程序计数器来记录代码已经执行到的位置，所以它是线程私有的。

  > <font color='red'>此内存区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</font>

- Java虚拟机栈

  线程私有，生命周期与线程相同。

  虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

  局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。

  > 异常：
  >
  > - 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；
  > - 如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常；

  <font color='red'>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，每一个线程在执行某个方法时，都会为这个方法创建一个栈帧。</font>

- 本地方法栈

  本地方法栈与虚拟机栈类似，针对的是本地（native）方法。

- Java堆（线程共享）

  虚拟机所管理的内存中最大的一块。线程共享，在虚拟机启动时创建。

  <font color='red'>几乎所有的对象实例都在堆中分配内存（逃逸分析，可能会在栈上分配）。</font>

  Java堆是垃圾收集器管理的主要区域，基本采用分代收集算法，分为新生代和老年代。

  > 如果堆中没有内存完成实力分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryError 异常。

- 方法区（线程共享）

  用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

  > 当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。

- 运行时常量池

  运行是常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。

  一般来说，除了保存 Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。

  > 异常同方法区



##### 2、方法区有什么东西？

##### 3、jvm的运行时数据结构。栈帧中会有什么异常？<font color='red'>方法区里面存放的是什么数据？</font>

TODO

##### 4、Java中进程间共享的数据是放在JVM那个分区的？Java中主进程和子进程间的通信，通过哪块内存区域？

TODO

#### 二、垃圾回收相关

##### 1、垃圾回收机制？

1. 判断对象已死
   - 引用计数法，实现简单，判定效率高，但是无法解决对象之间相互循环引用的问题。
   - 可达性分析，当一个对象到 GC Roots 没有任何应用链相连时，则证明此对象是不可用的。
2. 什么时候回收
   - Allocation Failure：在堆内存中分配时，如果因为可用剩余空间不足导致对象内存分配失败，这时系统会触发一次 GC；
   - System.gc()：程序员主动调用 gc；
3. 等



##### 2、垃圾回收算法？老年代有什么算法？

**1）标记-清除算法**

> 1. 从 GC Roots 集合开始，将内存遍历一次，对存活对象进行标记
> 2.  标记完毕后，将垃圾对象清除

- 优点：实现简单，不需将对象进行移动
- 缺点：效率不高，会产生大量不连续的内存碎片，提高垃圾回收的频率（碎片多，容易在分配大对象时内存不够，导致触发另一次垃圾收集）

**2）复制算法**

将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存使用完了，就将还存活着的对象复制到另一块，然后再把已使用过的内存空间一次清理掉。

适用于对象存活率低的场景，比如新生代。

- 优点：实现简单，效率高，不用考虑内存碎片问题
- 缺点：可用内存缩小为原来的一半，对象存活率高时会频繁进行复制

**3）标记-整理算法**

标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时，将所有存活对象压缩到内存的一端，然后直接清理掉端边界以外的垃圾对象。

适用于对象存活率高的场景，如老年代。

- 优点：避免了碎片的产生，又不需要两块相同的内存空间
- 缺点：需要进行对象移动，一定程度上降低了效率

**4）分代收集算法**

Java虚拟机根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代。

大多数情况下，对象在新生代 Eden 区中分配。新生代对象存活率较低，使用复制算法；老年代对象存活率较高，使用标记-清除或者标记-整理算法。

- 新生代

  新生代细分为3部分：Eden、Survivor0、Survivor1，比例8：1：1，内存分配如下：

  - 绝大多数刚被创建的对象会放在 Eden 区；
  - 当 Eden 区第一次满的时候，会进行垃圾回收。首先将 Eden 区的垃圾对象回收清除，并将存活的对象复制到 S0，此时 S1 是空的。
  - 下一次 Eden 区满时，再执行一次垃圾回收。此次会将 Eden 区和 S0 区中所有垃圾对象清除，并将存活对象复制到 S1，此时 S0 变为空。
  - 如此反复在 S0 和 S1 之间切换几次（默认15次）之后，如果还有存活对象，则转移到老年代。

- 老年代

  一个对象如果在新生代存活了足够长的时间而没有被清理掉，则会被复制到老年代。如果对象比较大（比如长字符串或者大数组），并且新生代的剩余空间不足，则这个大对象会直接被分配到老年代。

  

##### 3、GC Root？

以下几种对象可以作为 GC Root：

- Java虚拟机栈（局部变量表）中引用的对象；
- 方法区中静态引用指向的对象；
- 仍处于存活状态中的线程对象；
- 本地方法栈中 JNI 引用的对象；



##### 4、引用

TODO

#### 三、class类文件结构相关

##### 1、class文件的组成？常量池里面有什么内容？

class 文件是一组以 8 位字节为基础单位的二进制流，class 文件格式采用一种类似于 C 语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表。

> - 无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串值。
> - 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个 class 文件本质上就是一张表。

class文件构成：

- 魔数

  唯一作用是确定这个文件是否为一个能被虚拟机接受的 class 文件。

- class文件版本号

- 常量池

  常量池中主要存放两大类常量：

  - 字面量（Literal）

    字面量比较接近于 Java 语言层面的常量概念，如文本字符串、声明为 final 的常量值等。

  - 符号引用（Symbolic References），属于编译原理方面的概念，包括了下面三类常量：

    - 类和接口的全限定名（Fully Qualified Name）
    - 字段的名称和描述符（Descriptor）
    - 方法的名称和描述符

  常量池中每一项常量都是一个表。

- 访问标志

- 类索引、父类索引与接口索引集合

- 字段表集合

- 方法表集合

- 属性表集合



#### 四、类加载机制相关

##### 1、JVM类加载机制了解吗？类什么时候会被加载？类加载的过程具体生命周期是怎样的？

**1）类加载机制**

虚拟机把描述类的数据从 class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。



**2）类加载时机**

JVM 是什么时候加载某 .class 文件，Java 虚拟机规范中并没有严格规定，不同虚拟机实现会有不同。一般以下两种情况会对 class 进行加载操作：

- 隐式加载：在程序运行过程中，当碰到通过 new 等方式生成对象时，系统会隐式调用 ClassLoader 去加载对应的 class 到内存中。
- 显示加载：在代码中主动通过 ClassLoader 加载 class 对象，比如 Class.forName()、ClassLoader.loadClass()

<font color='red'>初始化阶段，虚拟机规范规定了有且只有5中情况必须立即对类进行“初始化”：</font>

1. 遇到 new、getstatic、putstatic 或者 invokestatic 这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这 4 条指令的最常见的 Java 代码场景是：<font color='red'>使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段（被 final 修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候</font>。
2. <font color='red'>使用 java.lang.reflect 包的方法对类进行反射调用的时候</font>，如果类没有进行过初始化，则需要先触发其初始化。
3. <font color='red'>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化</font>。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。
5. 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。



**3）类加载生命周期**

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接。



##### 2、类加载过程？

- 加载

  - 通过一个类的全限定名来获取定义此类的二进制字节流；

    二进制字节流不一定从 class 文件中获取，也可以从 zip 包、网络中获取。。。

  - 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构；

  - 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口；

- 验证

  目的是为了确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

  验证阶段包括以下 4 个检验动作：

  1. 文件格式验证
  2. 元数据验证
  3. 字节码验证
  4. 符号引用验证

- 准备

  准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

  - 这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。
  - 初始值“通常情况”下是数据类型的零值，比如 `public static int value = 123` 准备阶段过后的初始值是 0，赋值为 123 是在初始化阶段进行的。

- 解析

  解析阶段是虚拟机将常量池内的符号引用替换为直接引用（也就是具体的内存地址）的过程。

  在这一阶段，JVM 会将常量池中的类、接口名、字段名、方法名等转换为具体的内存地址。

- 初始化

  初始化阶段是执行类构造器 `<clinit>()`方法的过程。

  `<clinit>()`方法执行的过程中会有一些特点，其中有一点是<font color='red'>静态内部类单例模式能保证线程安全的原因</font>：

  虚拟机会保证一个类的 `<clinit>()`方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 `<clinit>()`方法，其他线程都需要阻塞等待，直到活动线程执行 `<clinit>()`方法完毕。如果一个类的 `<clinit>()`方法中有耗时很长的操作，就可能造成多个进程阻塞。

##### 3、类加载器 classLoader?

<font color='red'>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机中的唯一性。</font>

类加载器类型：

- 启动类加载器（Bootstrap ClassLoader）
- 扩展类加载器（Extension ClassLoader）
- 应用程序类加载器（Application ClassLoader）



##### 4、java加载对象的步骤？

##### 5、成员变量和局部变量的区别。为何成员变量需要jvm在对象初始话过程中赋默认值？

**1）成员变量、局部变量和静态变量的区别**

|          | **成员变量**        | **局部变量**                       | **静态变量**        |
| -------- | ------------------- | ---------------------------------- | ------------------- |
| 定义位置 | *在类中**,**方法外* | *方法中**,**或者方法的形式参数*    | *在类中**,**方法外* |
| 初始化值 | 有默认初始化值      | *无**,**先定义**,**赋值后才能使用* | 有默认初始化值      |
| 调用方式 | 对象调用            | ---                                | 对象调用，类名调用  |
| 存储位置 | 堆中                | 栈中                               | 方法区              |
| 生命周期 | 与对象共存亡        | 与方法共存亡                       | 与类共存亡          |
| 别名     | 实例变量            | ---                                | 类变量              |

**2）为何成员变量需要jvm在对象初始化过程中赋值？**

因为成员变量是在对象实例化时随着对象一起分配在 Java 堆中的。对象实例化时会触发类的初始化操作。

**3）总结一下对象初始化顺序：**

静态变量/静态代码块 -> 普通代码块 -> 构造函数

1. 父类静态变量和静态代码块；
2. 子类静态变量和静态代码块；
3. 父类普通成员变量和普通代码块；
4. 父类的构造函数；
5. 子类普通成员变量和普通代码块；
6. 子类的构造函数。



##### 6、DexClassLoader与PathClassLoader的区别？

- 8.0之前唯一的区别就是生不生成优化后的odex文件；

- 8.0之后统一不在传递optimizedDirectory

```java
optimizedDirectory this parameter is deprecated and has no effect since API level 26.
```



#### 五、编译期相关

##### 1、泛型与类型擦除？

- 泛型

  本质是参数化类型的应用，也就是说所操作的数据类型被指定为一个参数。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。

- 类型擦除

  <font color='red'>泛型信息只存在于代码编译阶段，在进入 JVM 之前，与泛型相关的信息会被擦除掉，即类型擦除。</font>

  在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 `<T>`则会被转译成普通的 Object 类型，如果指定了上限如 `<T extends String>`则类型参数就被替换成类型上限。

  ```java
  List<String> l1 = new ArrayList<String>();
  List<Integer> l2 = new ArrayList<Integer>();
  		
  System.out.println(l1.getClass() == l2.getClass());//true
  ```

  - 类型擦除会抹掉很多继承相关的特性，这是它带来的局限性；
  - 泛型的限制可以通过反射绕过；



##### 2、自动装箱发生在什么时候？编译期还是运行期？

自动装箱就是Java自动将原始类型值转换成对应的对象，比如将int的变量转换成Integer对象，这个过程叫做装箱，反之将Integer对象转换成int类型值，这个过程叫做拆箱。因为这里的装箱和拆箱是自动进行的非人为转换，所以就称作为自动装箱和拆箱。

<font color='red'>自动装箱发生在编译期。</font>



#### 六、内存模型

##### 1、Java内存模型？

**问题**：

​	由于计算机的存储设备与 CPU 的运算速度差距过大，所以加入了一层高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。

- 缓存一致性问题（多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致）

  为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。

- 指令重排序问题

  为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行优化。

  因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序。

**概念**：

​	内存模型是一套共享内存系统中多线程读写操作行为的规范，这套规范屏蔽了底层各种硬件和操作系统的内存访问差异，解决了 CPU 多级缓存、CPU 优化、指令重排等导致的内存访问问题，从而保证 Java 程序（尤其是多线程）在各种平台下对内存的访问效果一致。

​	<font color='red'>在这套规范中，有一个非常重要的规则——happens-before（先行发生原则）。</font>

​	Java 内存模型规定了所有的变量都存储在主内存中。每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行（volatile也不例外，只是看起来像是直接在主内存中读写访问的），而不能直接读写主内存中的变量。不同的线程之间也无法直接访问 对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

​	这里的主内存、工作内存与 Java 内存区域中的堆、栈、方法区等并不是同一个层次的内存划分，如果勉强对应的话：

- 从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域；
- 从更低层次来看，主内存对应于物理硬件的内存，工作内存对应于寄存器和高速缓存；

##### 

##### 2、volatile

###### 1）volatile关键字的作用，怎么保证原子性呢？

<font color='red'>volatile 保证可见性和有序性，可以使用 synchronized 同步代码块、CAS原子类工具和 lock 锁机制。</font>

###### 2）synchronized和volatile的区别？为何不用volatile替代synchronized？类锁和对象锁互斥么？

1. 区别：https://blog.csdn.net/suifeng3051/article/details/52611233

2. 为啥：https://www.cnblogs.com/hollischuang/p/11386988.html

3. 不互斥

   类锁和对象锁不是一个东西，一个是类的 Class 对象的锁，一个是类的实例的锁。即一个线程访问静态 synchronized 的时候，允许另一个线程访问对象的实例 synchronized 方法。反过来也是成立的，因为它们需要的锁是不同的。

   

###### 3）读写锁和ReentrantLock，synchronized和读写锁的区别。



当一个变量定义为 volatile 之后，它将具备两种特性：

- 可见性

  可见性是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。

  在不符合以下两条规则的场景中，仍要<font color='red'>**通过加锁来保证原子性**</font>：

  - 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
  - 变量不需要与其他的状态变量共同参与不变约束。

- 有序性，禁止指令重排序优化

  - 指令重排序是指指令乱序执行，即在条件允许的情况下直接运行当前有能力立即执行的后续指令，避开为获取一条指令所需数据而造成的等待，通过乱序执行的技术提高执行效率。
  - 指令重排序会在被 volatile 修饰的变量的赋值操作前，添加一个<font color='red'>**内存屏障**</font>，指令重排序时不能把后面的指令重排序移到内存屏障之前的位置。

  

##### 3、可见性，原子性，有序性？

- **原子性**

  指一个操作或多个操作要么全部执行，要么执行失败，不会被中断，基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，可以使用 synchronized 关键字，synchronized 块之间的操作也具备原子性。

- **可见性**

  可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。

- **有序性**

  如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。

  Java语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。

  

##### 4、synchronized可以保证什么？

1. synchronized 可以保证原子性、可见性、有序性。

2. synchronized 的三种应用方式：

   - 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁；
   - 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁；
   - 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码块前要获得给定对象的锁；

3. synchronized 底层语义原理

   Java 虚拟机中的同步（Synchronization）基于进入和退出管程（Monitor）对象实现，无论是显式同步（有明确的 monitorenter 和 monitorexit 指令，即同步代码块）还是隐式同步都是如此。

   - 同步代码块

     编译成字节码后包含 monitorenter、monitorexit 两个字节码指令；

   - 同步方法

     编译成字节码后，方法的 flags 属性中会被标记为 ACC_SYNCHRONIZED 标志。当虚拟机访问一个被标记为 ACC_SYNCHRONIZED 的方法时，会自动在方法的开始和结束（或异常）位置添加 monitorenter 和 monitorexit 指令。

4. s





#### 七、其他

##### 1、java虚拟机与Dalvik和ART区别？









### Java多线程

线程内存模型，线程间通信



#### 一、线程基础问题





#### 二、线程安全问题

1. 平常有用到什么锁，synchronized底层原理是什么
2. synchronized是公平锁还是非公平锁,ReteranLock是公平锁吗？是怎么实现的
3. synchronized跟ReentranLock有什么区别？
4. synchronized与ReentranLock发生异常的场景.
5. synchronized的同步原语
6. 讲一下锁，synchronized和Lock。CAS原理
7. synchronized实现。非静态方法A和B在同一个类中，方法A用synchronized修饰，当A方法因为多线程请求有线程阻塞在对象锁上的时候，B方法的访问受不受影响？
8. Lock的实现，以及与synchronized的区别
9. Java的线程同步方式；synchronized和Lock的实现及区别
10. Synchronized底层原理，java锁机制
11. 锁之间的区别
12. 锁的几种状态





1、锁机制

- 自旋锁

  线程自旋说白了就是让 CPU 做无用功，比如：可以执行几次 for 循环，可以执行几条空的汇编指令，目的是占着 CPU 不放，等待获取锁的机会。如果旋的时间过长会影响整体性能，时间短又达不到延迟阻塞的目的。

- 偏向锁

  偏向锁就是一旦线程第一次获得了监视对象，之后让监视对象“偏向”这个线程，之后的多次调用则可以避免 CAS 操作，说白了就是置个变量，如果发现为 true 则无需再走各种加锁/解锁流程。

- 轻量级锁

  轻量级锁是由偏向锁升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁竞争用的时候，偏向锁就会升级为轻量级锁。

- 重量级锁

  重量级锁在 JVM 中又叫对象监视器（Monitor），







读写锁和ReentrantLock，synchronized和读写锁的区别。























#### 三、多线程问题





#### 四、线程池问题



















