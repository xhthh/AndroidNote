## 性能优化

### 内存优化

https://juejin.cn/post/6844904096541966350

#### 一、Android 内存管理机制

##### 1、Java 内存分配模型

- 程序计数器

  线程私有，当前线程所执行的字节码的行号指示器，存储当前线程执行目标方法执行到了第几行；

- 虚拟机栈

  线程私有，生命周期与线程相同。每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

  局部变量表存放了编译期可知的各种基本数据类型、对象引用和 returnAddress 类型。

- 本地方法栈

  和虚拟机栈类似，为虚拟机用到的 Native 方法服务；

- 堆

  线程共享，虚拟机所管理的内存中最大的一块，用于存放对象实例，几乎所有的对象实例都在堆中分配（逃逸分析，栈上分配），垃圾收集器管理的主要区域。

- 方法区

  线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- 运行时常量池

  方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

##### 2、Java 内存回收算法

- **标记-清除算法**

  实现原理：

  - 标记出所有需要回收的对象
  - 统一回收所有被标记的对象

  特点：

  - 标记和清除效率不高
  - 产生大量不连续的内存碎片

- **复制算法**

  实现原理：

  - 将内存划分为大小相等的两块
  - 一块内存用完之后复制存活对象至另一块
  - 清理另一块内存

  特点：

  - 实现简单，运行高效
  - 浪费一半空间，代价大

- **标记-整理算法**

  实现原理：

  - 标记过程与 “标记-清除” 算法一样
  - 存活对象往一端进行移动
  - 清理其余内存

  特点：

  - 避免 “标记-清除” 算法导致的内存碎片
  - 避免复制算法的空间浪费

- **分代收集算法**

  - 结合多种算法的优势
  - 新生代对象存活率低，采用 “复制算法”（这里每一次的复制比例都是可以调整的，如一次仅复制30%的存活对象）
  - 老年代对象存活率高，采用 “标记-整理” 算法

> - Partial GC：并不收集整个GC堆的模式；
>   - Young GC：只收集 young gen 的 GC。
>   - Old GC：只收集 old gen 的 GC。只有 CMS 的 concurrent collection 是这个模式；
> - Full GC：收集整个堆，包括 young  gen、old gen、perm gen（如果存在的话）等所有部分的模式；
>
> Major GC 通常是跟 Full GC 是等价的，收集整个 GC 堆。
>
> Minor GC 等价于 Young GC 吧。
>
> 不过有的文章里说 Minor GC 发生在 Eden 区，Young GC 发生在 Eden、S0、S1 区。Major GC 发生在 old generation。



**Minor GC，Full GC 触发条件：**

- Minor GC 触发条件：当 Eden 区满时触发；
- Full GC 触发条件：
  - 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；
  - 老年代空间不足；
  - 方法区空间不足；
  - 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存；
  - 当 Eden 区、From Survivor 区向 To Survivor 区复制时，对象大小大于 To Survivor 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。



#### 二、内存优化的意义

- 减少 OOM，提高应用稳定性；
- 减少卡顿，提高应用流畅性；
- 减少内存占用，提高应用后台运行时的存活率；
- 减少异常发生和代码逻辑隐患；



#### 三、避免内存泄漏

##### 1、内存泄漏的定义

GC 会选择一些还存活的对象作为内存遍历的根节点 GC Roots，通过对 GC Roots 的可达性来判断是否需要回收。**内存泄漏就是在当前应用周期内不再使用的对象被 GC Roots 引用，导致不能回收，使实际可用内存变小**。

**可以作为 GC Roots 的对象**：

GC 管理的主要区域是 Java 堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法栈不被 GC 所管理，因此选择这些区域内的对象作为 GC Roots，被 GC Roots 引用个对象不被 GC 回收。

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；

  > 每个方法执行时，都会创建一个栈帧，栈帧中包含这个方法内部使用的所有对象的引用（这就是虚拟机栈中引用的对象）；
  >
  > 一旦该方法执行完后，该栈帧就会从虚拟机栈中弹出，这些局部（临时）对象的引用也就不存在了，或者说没有任何 GC Root 指向这些临时对象，所以这些对象在下一次 gc 时就会被回收掉。

- 方法区中静态属性引用的对象（一般指被static修饰的对象，加载类的时候就加载到内存中）；

  > 因为该对象是类的全局属性，所以会存在于方法区中，每个线程共享，可以作为 GC Root 对象。
  >
  > 比如单例模式的懒汉式和饿汉式的写法：
  >
  > - ```java
  >   private static User user = new User();//懒汉式
  >   ```
  >
  > - ```java
  >   private static User user;//饿汉式
  >   ```
  >
  > Java 8 后静态变量存储的地方改为堆。

- 方法区中常量引用的对象；

  > 是否是静态常量？

- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象；



**各种变量存储的位置：**

> 静态变量：位于方法区。
>
> 实例变量：作为对象的一部分，保存在堆中。
>
> 临时变量：保存于栈中，栈随线程的创建而被分配。
>
> 栈内存中存放局部变量（基本数据类型和对象引用)，而堆内存用于存放对象（实体）
>
> 对于字符串而言，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中；如果是运行期（new出来的）才能确定的就存储在堆中。
>
> 对于 `equals` 相等的字符串，在常量池中永远只有一份，在堆中可以有多份。
>
> 
>
> jdk 1.8 之后
>
> 以前的永久代是用来保存类的信息的，然后 Java8 将其一分为二，一部分是元空间，另一部分放到堆中。
>
> 元空间存储的是类的元信息，堆里面存储了静态变量和常量。





##### 2、查找内存泄漏

- shell 命令 + LeakCanary + MAT
- Profile Memory



> 使用 Android Studio  profiler 时 App 崩溃
>
> 设备：荣耀V20
>
> Android版本：Android 10
>
> 解决方案：Android Studio 右下角 Device File Explorer，删除 data/local/tmp/perfd 文件夹（未测试），但是貌似不能 dump



##### 3、常见内存泄漏场景

- 资源性对象未关闭

- 注册对象未注销

- 类的静态变量持有大数据对象

- 单例造成的内存泄漏

- 非静态内部类的静态实例

- Handler 内存泄漏

  未处理的消息 Message，持有 Handler 的引用，如果是非静态内部类，将持有外部类 Activity 的引用，导致 Activity 退出时无法被回收。

  - 使用静态 Handler 内部类，对 Handler 持有的对象（一般为 Activity）使用弱引用；
  - 在 Activity 的 onDestroy() 中移除未处理的消息；

- 容器中的对象没清理造成的内存泄漏

  在退出程序之前，将集合里的数据 clear，然后置为 null，再退出程序。

- WebView 内存泄漏

  在应用中只要使用一次 WebView，内存就不会被释放掉。可以为 WebView 开启一个独立的进程，使用 AIDL 与应用的主进程进行通信，WebView 所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。

- 使用 ListView 时造成的内存泄漏

  在构造 adapter 时，使用缓存 convertView



##### 4、内存泄漏监控

LeakCanary

> 弱引用和引用队列
>
> LeakCanary 监听 Activity、Fragment 的生命周期，在 onDestroy() 之后，将其放入到一个弱引用中，并关联引用队列。如果实例进行了回收，那么弱引用就会放入到引用队列当中，并将已经回收的对象从 `watchedObjects` 集合中删除，然后剩下的就是没有被回收，发生内存泄漏的。如果一段时间后，所监控的实例还未在引用队列中出现，则证明出现了内存泄漏导致了实例没有被回收，然后执行 `dump` 指令分析内存。



#### 四、优化内存空间

##### 1、对象引用

- 强引用
- 软引用
- 弱引用
- 虚引用

##### 2、减少不必要的内存开销

- 自动装箱

  > 自动装箱是把基础数据类型转换成对应的复杂类型。在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。比如 HashMap 这类容器进行增删改查操作时，都会产生大量的自动装箱操作。

  检测方式：

  使用 TraceView 查看耗时，如果发现调用了大量的 integer.value()，就说明发生了自动装箱。

- 内存复用

  - 资源复用

    通用的字符串、颜色定义、简单页面布局的复用；

  - 视图复用

    可以使用 ViewHolder 实现 ConvertView 复用；

  - 对象池

    显示创建对象池，实现复用逻辑，对相同的类型数据使用同一块内存空间；

  - Bitmap 对象的复用

    使用 inBitmap 属性可以告知 Bitmap 解码器尝试使用已经存在的内存区域，新解码的 bitmap 会尝试使用之前那张 bitmap 在 heap 中占据的 pixel data 内存区域；

##### 3、使用最优的数据类型

1. **HashMap 和 ArrayMap、SparseArray**

   - HashMap

     - HashMap 数组+链表（红黑树）的结构，插入对象时散列冲突的问题；

     - 查询低效？

     - 扩容机制，初始 16 的数组，size > 容量*加载因子时，扩大为原来的2倍，数据很大的扩容，浪费内存

     - HashMap 插入基础数据类型时，自动装箱，key 和 value 都是 Object 类型，比如：

       ```java
       private HashMap<String, Integer> map = new HashMap();
       private void test() {
           map.put("age",18);//自动装箱，int -> Integer
       }
       ```

   - SparseArray

     > 内部通过两个数组来存储数据，一个存key，一个存value，且只能存储key类型为 int 的数据，在存储和读取数据时，采用了二分查找。
     >
     > 在某些条件下性能比 HashMap 更好，主要是它避免了对 key 的自动装箱。

     应用场景：

     - 数据量不大，最好在千级以内；
     - key 必须为 int 类型；

   - ArrayMap

     > 内部使用2个数组进行存储，一个存储 key 的 hash 值，一个存储 value 值，它和 SparseArray 一样，也会对 key 使用二分查找进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找得到相应的 index，然后通过 index 来进行添加、查找、删除等操作，所以使用场景和 SparseArray 类似。
     >
     > 1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用
     >
     > 2、如果key类型为其它的类型，则使用ArrayMap

2. **使用 IntDef 和 StringDef 替代枚举类型**

   > 枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：IntDef和StringDef，用来提供编译期的类型检查。

3. **LruCache**

4. **图片内存优化**

   - 图片规格
   - inSampleSize，位图的缩放功能，通过 BitmapFactory.options 设置
   - inScaled、inDensity 和 inTargetDensity 实现更细的缩放功能

5. **inBitmap**

6. **图片放置优化**

   > 只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。

7. **在 App 可用内存过低时主动释放内存**

   > 在 App 退到后台内存紧张即将被 Kill 掉时选择重写 onTrimMemory/onLowMemory 方法释放掉图片缓存、静态缓存来自保。

8. **item 被回收不可见时释放掉对图片的引用**

   - ListView
   - RecyclerView

9. **避免创建不必要的对象**

   > 比如字符串拼接时使用 StringBuilder、StringBuffer等

10. **自定义 View 中的内存优化**

    > 在 onDraw() 中不要执行对象的创建，一般都在自定义View的构造器中创建。

11. **其它的内存优化注意事项**

    - 尽使用static final 优化成员变量。
    - 使用增强型for循环语法。
    - 在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。
    - 在合适的时候适当采用软引用和弱引用。
    - 采用内存缓存和磁盘缓存。
    - 尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。



### 启动优化

#### 一、应用启动流程

##### 1、应用启动类型

- **冷启动**

  从点击应用图标到 UI 界面完全显示且用户可操作的全部过程。

  **特点**：耗时最多，**衡量标准**

  **启动流程：**

  Click Event  -> IPC -> Process.start -> ActivityThread -> bindApplication -> LifeCycle -> ViewRootImpl

- **热启动**

  直接从后台切换到前台。

  **特点：**启动速度最快。

- **温启动**

  只会重走 Activity 的生命周期，而不会重走进程的创建、Application 的创建及生命周期。

  **特点：**较快，介于冷启动和热启动之间。



##### 2、冷启动分析及优化方向

**冷启动前**

- 启动 App
- 加载空白 Window
- 创建进程

> 这些都是系统行为，一般情况是无法直接干预的。

**随后任务**

- 创建 Application
- 启动主线程
- 创建 MainActivity
- 加载布局
- 布置屏幕
- 首帧绘制

**优化方向**

Application 和 Activity 的生命周期 这个阶段。



#### 二、启动耗时监测

##### 1、adb shell

```
// 其中的AppstartActivity全路径可以省略前面的packageName
adb shell am start -W [packageName]/[AppstartActivity全路径]
```

执行后会得：

```
Status: ok
LaunchState: COLD
Activity: com.xht.androidnote/.SplashActivity
TotalTime: 236		//表示所有Activity启动耗时。
WaitTime: 237		//表示AMS启动Activity的总耗时。
Complete
```

一般来说，只需查看得到的TotalTime，即应用的启动时间，其包括 **创建进程 + Application初始化 + Activity初始化到界面显示** 的过程。



##### 2、代码打点（函数插桩）

可以写一个统计耗时的工具类来记录整个过程的耗时情况。其中需要注意的有：

- 在上传数据到服务器时**建议根据用户ID的尾号来抽样上报**。
- 在项目中**核心基类的关键回调函数和核心方法**中加入打点。

主要在以下几个方面需要打点：

- **应用程序的生命周期节点**。
- **启动时需要初始化的重要方法**，例如数据库初始化，读取本地的一些数据。
- **其他耗时的一些算法**。

> **特点**：精确，可带到线上，但是代码有侵入性，修改成本高。



##### 3、AOP（Aspect Oriented Programming）打点

面向切面编程，**通过预编译和运行期动态代理实现程序功能统一维护**的一种技术。



##### 4、TraceView

主要做热点分析，用来得到以下两种数据：

- **单次执行最耗时的方法**。
- **执行次数最多的方法**。

##### 5、Systrace

- 主要用于**分析绘制性能方面的问题**。
- 分析**系统关键方法和应用方法耗时**。



#### 三、启动优化常规方案

##### 1、主题

使用Activity的windowBackground主题属性预先设置一个启动图片（layer-list实现），在启动后，在Activity的onCreate()方法中的super.onCreate()前再setTheme(R.style.AppTheme)。

**优点**

- 使用**简单**。
- **避免了启动白屏和点击启动图标不响应的情况**。

**缺点**

- **治标不治本**，表面上产生一种快的感觉。
- **对于中低端机，总的闪屏时间会更长，建议只在Android6.0/7.0以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验**。



##### 2、第三方库懒加载



##### 3、线程优化

###### 3.1 线程调度原理

- 任意时刻，**只有一个线程占用CPU，处于运行状态**；
- 多线程并发，轮流获取 CPU 使用权；
- JVM 负责线程调度，按照特定机制分配 CPU 使用权；



###### 3.2 Android 异步方式

1. Thread
2. HandlerThread
3. IntentService
4. AsyncTask
5. 线程池
6. RxJava

推荐度从后往前，正确场景使用正确的方式。



###### 3.3 线程使用准则

- 严禁使用 new Thread 方式；
- 提供 **基础线程池** 供各个业务线使用，避免各个业务线各自维护一套线程池，导致线程数过多；
- **根据任务类型选择合适的异步方式**：优先级低，长时间执行，HandlerThread；定时任务、耗时任务，线程池；
- 创建线程必须 **命名**，以方便 **定位线程归属**，在运行期 **Thread.currentThread().setName** 修改名字；
- 关键异步任务监控，注意 **异步不等于耗时**，建议使用 **AOP** 的方式来做监控；
- **重视优先级设置（根据任务具体情况），Process.setThreadPriority() 可以设置多次**；



###### 3.4 如何锁定线程创建者

**锁定线程创建背景**：

- 项目变大之后收敛线程；
- 项目源码、三方库、aar 中都有线程创建者；

**锁定线程创建方案**：

找 Hook 点：构造函数或者特定方法，如 Thread 的构造函数。

> 可以使用维数的 [epic](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftiann%2Fepic) 对Thread进行Hook。在attachBaseContext中调用DexposedBridge.hookAllConstructors方法即可。
>
> 从log找到线程创建信息，根据堆栈信息跟相关业务方沟通解决方案。



###### 3.5 线程收敛方案

- 根据线程创建堆栈考量合理性，使用统一线程库；
- 各业务线下掉自己的线程库；



基础库使用线程：

- 基础库内部暴露 API，setExecutor()；
- 初始化时注入统一的线程库；

统一线程库时区分任务类型：

- **IO密集型任务**：IO密集型任务不消耗CPU，核心池可以很大。常见的IO密集型任务如文件读取、写入，网络请求等等。
- **CPU密集型任务**：核心池大小和CPU核心数相关。常见的CPU密集型任务如比较复杂的计算操作，此时需要使用大量的CPU计算单元。



###### 3.6 线程优化核心问题

项目发展阶段忽视基础设施建设，没有采用统一线程池，导致线程数量过多。

**表现形式**：

异步任务执行太耗时，导致主线程卡顿。

**原因**：

- Java 线程调度是抢占式的，线程优先级比较重要，需要区分；
- 没有区分 IO 和 CPU 密集型任务，导致主线程抢不到 CPU；

**优化方案：**

核心：线程收敛

- 通过 Hook 方式找到对应线程的堆栈信息，和业务方讨论是否应该单独起一个线程，尽可能使用统一线程池；
- 每个基础库都暴露一个设置线程池的方法，以避免线程库更新导致基础库需要更新的问题；
- 统一线程池应该注意 IO、CPU 密集型任务区分；
- 其他细节：重要异步任务统计耗时、注重异步任务优先级和线程名的设置；



##### 4、异步初始化

###### 4.1 核心思想

子线程分担主线程任务，并行减少时间。

###### 4.2 异步优化注意点

1. 不符合异步要求；
2. 需要在某个阶段完成（采用 CountDownLatch 确保异步任务完成后才到下一个阶段）；
3. 如出现主线程使用时还没初始化则在此次使用前初始化；
4. 区分 CPU 密集型和 IO 密集型；

###### 4.3 异步初始化方案演进

1. new Thread
2. IntentService
3. 线程池
4. 异步启动器

###### 4.4 异步优化最优解：异步启动器

**异步启动器核心思想**：

充分利用 CPU 多核，自动梳理任务顺序。

**异步启动器流程**：

1. **任务Task化，启动逻辑抽象成Task**（Task即对应一个个的初始化任务）。
2. **根据所有任务依赖关系排序生成一个有向无环图**：例如上述说到的推送SDK初始化任务需要依赖于获取设备id的初始化任务，各个任务之间都可能存在依赖关系，所以将它们的依赖关系排序生成一个有向无环图能将**并行效率最大化**。
3. **多线程按照排序后的优先级依次执行**：例如必须先初始化获取设备id的初始化任务，才能去进行推送SDK的初始化任务。



##### 5、延迟初始化

###### 5.1 常规方案

**利用闪屏页的停留时间进行部分初始化**

- new Handler().postDelayed()
- 界面 UI 展示后调用

**常规延迟初始化问题**

1. 时机不容易控制，handler#postDelayed() 指定的延迟时间不好估计
2. 导致界面 UI 卡顿，此时用户可能还在滑动列表



**延迟最优解**：延迟启动器

**核心思想**：利用 IdleHandler 特性，在 CPU 空闲时执行，对延迟任务进行分批初始化。

使用队列保存添加的 task，当 CPU 空闲时，IdleHandler 会回调自身的 queueIdle()，这个时候我们可以将 task 一个一个的拿出来并执行。这种分批执行的好处在于每一个 task 占用主线程的时间相对来说很短暂，并且此时 CPU 是空闲的，这样能更有效地避免 UI 卡顿，真正的提升用户体验。

> 能异步的 task 优先使用异步启动器在 Application 的 onCreate() 方法中加载（或者是必须在 Application 的 onCreate 方法完成前执行完的非异步 task）
>
> 对于不能异步的 task，可以利用延迟启动器进行加载。
>
> 如果任务可以到用时再加载，可以使用懒加载的方式。

**延迟启动器优势：**

- 执行时机明确；
- 缓解界面 UI 卡顿；



##### 6、Multidex 预加载优化

5.0 以下一些机型会出现 ANR 或者长时间卡顿不进入引导页，原因是 MultiDex.install()  的 dexopt 过程耗时长，因此需要在初次启动时做特别处理。

5.0 以上不会出现，因为使用 ART，采用 Ahead-of-time（AOT）compilation 技术，系统在 APK 安装过程中会使用自带的 dex2oat 工具对 APK 中可用的 DEX 文件进行编译并生成一个可在本地机器上运行的文件，提高了启动速度，不过安装时间会边长。

###### 6.1 优化步骤

1. 启动时单独开一个进程去异步进行 Multidex 的第一次加载，即 Dex 提取和 Dexopt 操作；
2. 此时，主进程 Application 进入 while 循环，不断检测 Multidex 操作是否完成；
3. 执行到Multidex时，则已经发现提取并优化好了Dex，直接执行。MultiDex执行完之后主进程Application继续执行ContentProvider初始化和Application的onCreate方法。

###### 6.2 dex-opt 过程

主要包括inline以及quick指令的优化。

**inline**：使编译器在函数调用处用函数体代码代替函数调用指令。

**inline作用**：函数调用的转移操作有一定的时间和空间方面的开销，特别是对于一些函数体不大且频繁调用的函数，解决其效率问题更为重要，引入inline函数就是为了解决这一问题。



###### 6.3 抖音 BoostMultiDex 优化

在第一次启动的时候，直接加载没有经过 OPT 优化的原始 DEX，先使得 App 能够正常启动。然后在后台启动一个单独进程，慢慢的做完 dex 的 opt 工作，尽可能避免影响到前台 App 的正常使用。

绕过 ODEX 直接加载 DEX 的方案：

1. 从 APK 中解压获取原始 Secondary DEX 文件字节码；
2. 通过 dlsym 获取 dvm_dalvik_system_DexFile 数组；
3. 在数组中查询得到 Dalvik_dalvik_system_DexFile_openDexFile_bytearray函数；
4. 调用该函数，逐个传入之前从 APK 获取的 DEX 字节码，完成 DEX 加载，得到合法的DexFile对象；
5. 把DexFile对象都添加到 APP 的PathClassLoader的 pathList 里；



##### 7、类预加载优化

在 Application 中提前异步加载初始化耗时较长的类。

> 替换系统的 ClassLoader，打印类加载的时间，按需选取需要异步加载的类。



##### 8、WebView 启动优化

- WebView首次创建比较耗时，需要预先创建WebView提前将其内核初始化。
- 使用WebView缓存池，用到WebView的时候都从缓存池中拿，注意内存泄漏问题。
- 本地离线包，即预置静态页面资源。



##### 9、页面数据加载

在主页空闲时，将其它页面的数据加载好保存到内存或数据库，等到打开该页面时，判断已经预加载过，就直接从内存或数据库取数据并显示。



##### 10、启动阶段不启动子进程

子进程会共享CPU资源，导致主进程CPU紧张。此外，在多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作。

> **注意启动顺序**
>
> App onCreate之前是ContentProvider初始化。



##### 11、闪屏页与主页的绘制优化

- 布局优化
- 过度绘制优化



### 布局优化

#### 一、优化工具

##### 1.1 Systrace



##### 1.2 LayoutInspector



##### 1.3 Choreographer



#### 二、布局加载原理

以 AppCompatActivity 中的 setContentView(layoutResID) 为例

- 调用了代理类 AppCompatDelegate 的抽象方法 setContentView，具体实现在 AppCompatDelegateImpl 中

  ```java
  @Override
  public void setContentView(int resId) {
      LayoutInflater.from(mContext).inflate(resId, contentParent);
  }
  ```

  将传入的布局 id，解析加载到 decorView 上的 contentParent里，即 id 为 content 的 FrameLayout。

- 进入 LayoutInflater#inflate()

  ```java
  public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
      final Resources res = getContext().getResources();
  
      //1
      XmlResourceParser parser = res.getLayout(resource);
      try {
          //2
          return inflate(parser, root, attachToRoot);
      } finally {
          parser.close();
      }
  }
  ```

  - 通过 Resources 实例 res.getLayuout(resource) 获得 xmlResourceParser；
    - 具体实现在 ResourcesImpl#loadXmlResourceParser()，其中调用了 AssetManager#openXmlBlockAsset()
    - 其中调用了本地方法 nativeOpenXmlAsset，**即读取 xml 文件是通过 IO 流的方式进行的**。所以这里是 Android 布局加载流程的一个耗时点。
  - 













