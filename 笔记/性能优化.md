## 性能优化

### 内存优化

https://juejin.cn/post/6844904096541966350

#### 一、Android 内存管理机制

##### 1、Java 内存分配模型

- 程序计数器

  线程私有，当前线程所执行的字节码的行号指示器，存储当前线程执行目标方法执行到了第几行；

- 虚拟机栈

  线程私有，生命周期与线程相同。每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

  局部变量表存放了编译期可知的各种基本数据类型、对象引用和 returnAddress 类型。

- 本地方法栈

  和虚拟机栈类似，为虚拟机用到的 Native 方法服务；

- 堆

  线程共享，虚拟机所管理的内存中最大的一块，用于存放对象实例，几乎所有的对象实例都在堆中分配（逃逸分析，栈上分配），垃圾收集器管理的主要区域。

- 方法区

  线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- 运行时常量池

  方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

##### 2、Java 内存回收算法

- **标记-清除算法**

  实现原理：

  - 标记出所有需要回收的对象
  - 统一回收所有被标记的对象

  特点：

  - 标记和清除效率不高
  - 产生大量不连续的内存碎片

- **复制算法**

  实现原理：

  - 将内存划分为大小相等的两块
  - 一块内存用完之后复制存活对象至另一块
  - 清理另一块内存

  特点：

  - 实现简单，运行高效
  - 浪费一半空间，代价大

- **标记-整理算法**

  实现原理：

  - 标记过程与 “标记-清除” 算法一样
  - 存活对象往一端进行移动
  - 清理其余内存

  特点：

  - 避免 “标记-清除” 算法导致的内存碎片
  - 避免复制算法的空间浪费

- **分代收集算法**

  - 结合多种算法的优势
  - 新生代对象存活率低，采用 “复制算法”（这里每一次的复制比例都是可以调整的，如一次仅复制30%的存活对象）
  - 老年代对象存活率高，采用 “标记-整理” 算法

> - Partial GC：并不收集整个GC堆的模式；
>   - Young GC：只收集 young gen 的 GC。
>   - Old GC：只收集 old gen 的 GC。只有 CMS 的 concurrent collection 是这个模式；
> - Full GC：收集整个堆，包括 young  gen、old gen、perm gen（如果存在的话）等所有部分的模式；
>
> Major GC 通常是跟 Full GC 是等价的，收集整个 GC 堆。
>
> Minor GC 等价于 Young GC 吧。
>
> 不过有的文章里说 Minor GC 发生在 Eden 区，Young GC 发生在 Eden、S0、S1 区。Major GC 发生在 old generation。



**Minor GC，Full GC 触发条件：**

- Minor GC 触发条件：当 Eden 区满时触发；
- Full GC 触发条件：
  - 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；
  - 老年代空间不足；
  - 方法区空间不足；
  - 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存；
  - 当 Eden 区、From Survivor 区向 To Survivor 区复制时，对象大小大于 To Survivor 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。



#### 二、内存优化的意义

- 减少 OOM，提高应用稳定性；
- 减少卡顿，提高应用流畅性；
- 减少内存占用，提高应用后台运行时的存活率；
- 减少异常发生和代码逻辑隐患；



#### 三、避免内存泄漏

##### 1、内存泄漏的定义

GC 会选择一些还存活的对象作为内存遍历的根节点 GC Roots，通过对 GC Roots 的可达性来判断是否需要回收。**内存泄漏就是在当前应用周期内不再使用的对象被 GC Roots 引用，导致不能回收，使实际可用内存变小**。

**可以作为 GC Roots 的对象**：

GC 管理的主要区域是 Java 堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法栈不被 GC 所管理，因此选择这些区域内的对象作为 GC Roots，被 GC Roots 引用个对象不被 GC 回收。

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；

  > 每个方法执行时，都会创建一个栈帧，栈帧中包含这个方法内部使用的所有对象的引用（这就是虚拟机栈中引用的对象）；
  >
  > 一旦该方法执行完后，该栈帧就会从虚拟机栈中弹出，这些局部（临时）对象的引用也就不存在了，或者说没有任何 GC Root 指向这些临时对象，所以这些对象在下一次 gc 时就会被回收掉。

- 方法区中静态属性引用的对象（一般指被static修饰的对象，加载类的时候就加载到内存中）；

  > 因为该对象是类的全局属性，所以会存在于方法区中，每个线程共享，可以作为 GC Root 对象。
  >
  > 比如单例模式的懒汉式和饿汉式的写法：
  >
  > - ```java
  >   private static User user = new User();//懒汉式
  >   ```
  >
  > - ```java
  >   private static User user;//饿汉式
  >   ```
  >
  > Java 8 后静态变量存储的地方改为堆。

- 方法区中常量引用的对象；

  > 是否是静态常量？

- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象；



**各种变量存储的位置：**

> 静态变量：位于方法区。
>
> 实例变量：作为对象的一部分，保存在堆中。
>
> 临时变量：保存于栈中，栈随线程的创建而被分配。
>
> 栈内存中存放局部变量（基本数据类型和对象引用)，而堆内存用于存放对象（实体）
>
> 对于字符串而言，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中；如果是运行期（new出来的）才能确定的就存储在堆中。
>
> 对于 `equals` 相等的字符串，在常量池中永远只有一份，在堆中可以有多份。
>
> 
>
> jdk 1.8 之后
>
> 以前的永久代是用来保存类的信息的，然后 Java8 将其一分为二，一部分是元空间，另一部分放到堆中。
>
> 元空间存储的是类的元信息，堆里面存储了静态变量和常量。





##### 2、查找内存泄漏

- shell 命令 + LeakCanary + MAT
- Profile Memory



> 使用 Android Studio  profiler 时 App 崩溃
>
> 设备：荣耀V20
>
> Android版本：Android 10
>
> 解决方案：Android Studio 右下角 Device File Explorer，删除 data/local/tmp/perfd 文件夹（未测试），但是貌似不能 dump



##### 3、常见内存泄漏场景

- 资源性对象未关闭

- 注册对象未注销

- 类的静态变量持有大数据对象

- 单例造成的内存泄漏

- 非静态内部类的静态实例

- Handler 内存泄漏

  未处理的消息 Message，持有 Handler 的引用，如果是非静态内部类，将持有外部类 Activity 的引用，导致 Activity 退出时无法被回收。

  - 使用静态 Handler 内部类，对 Handler 持有的对象（一般为 Activity）使用弱引用；
  - 在 Activity 的 onDestroy() 中移除未处理的消息；

- 容器中的对象没清理造成的内存泄漏

  在退出程序之前，将集合里的数据 clear，然后置为 null，再退出程序。

- WebView 内存泄漏

  在应用中只要使用一次 WebView，内存就不会被释放掉。可以为 WebView 开启一个独立的进程，使用 AIDL 与应用的主进程进行通信，WebView 所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。

- 使用 ListView 时造成的内存泄漏

  在构造 adapter 时，使用缓存 convertView



##### 4、内存泄漏监控

LeakCanary

> 弱引用和引用队列
>
> LeakCanary 监听 Activity、Fragment 的生命周期，在 onDestroy() 之后，将其放入到一个弱引用中，并关联引用队列。如果实例进行了回收，那么弱引用就会放入到引用队列当中，并将已经回收的对象从 `watchedObjects` 集合中删除，然后剩下的就是没有被回收，发生内存泄漏的。如果一段时间后，所监控的实例还未在引用队列中出现，则证明出现了内存泄漏导致了实例没有被回收，然后执行 `dump` 指令分析内存。



#### 四、优化内存空间

##### 1、对象引用

- 强引用
- 软引用
- 弱引用
- 虚引用

##### 2、减少不必要的内存开销

- 自动装箱

  > 自动装箱是把基础数据类型转换成对应的复杂类型。在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。比如 HashMap 这类容器进行增删改查操作时，都会产生大量的自动装箱操作。

  检测方式：

  使用 TraceView 查看耗时，如果发现调用了大量的 integer.value()，就说明发生了自动装箱。

- 内存复用

  - 资源复用

    通用的字符串、颜色定义、简单页面布局的复用；

  - 视图复用

    可以使用 ViewHolder 实现 ConvertView 复用；

  - 对象池

    显示创建对象池，实现复用逻辑，对相同的类型数据使用同一块内存空间；

  - Bitmap 对象的复用

    使用 inBitmap 属性可以告知 Bitmap 解码器尝试使用已经存在的内存区域，新解码的 bitmap 会尝试使用之前那张 bitmap 在 heap 中占据的 pixel data 内存区域；

##### 3、使用最优的数据类型

1. **HashMap 和 ArrayMap、SparseArray**

   - HashMap

     - HashMap 数组+链表（红黑树）的结构，插入对象时散列冲突的问题；

     - 查询低效？

     - 扩容机制，初始 16 的数组，size > 容量*加载因子时，扩大为原来的2倍，数据很大的扩容，浪费内存

     - HashMap 插入基础数据类型时，自动装箱，key 和 value 都是 Object 类型，比如：

       ```java
       private HashMap<String, Integer> map = new HashMap();
       private void test() {
           map.put("age",18);//自动装箱，int -> Integer
       }
       ```

   - SparseArray

     > 内部通过两个数组来存储数据，一个存key，一个存value，且只能存储key类型为 int 的数据，在存储和读取数据时，采用了二分查找。
     >
     > 在某些条件下性能比 HashMap 更好，主要是它避免了对 key 的自动装箱。

     应用场景：

     - 数据量不大，最好在千级以内；
     - key 必须为 int 类型；

     > 

   - ArrayMap

     > 内部使用2个数组进行存储，一个数组记录key hash过后的顺序列表，另外一个数组按key的顺序记录Key-Value值，它和 SparseArray 一样，也会对 key 使用二分查找进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找得到相应的 index，然后通过 index 来进行添加、查找、删除等操作，所以使用场景和 SparseArray 类似。
     >
     > 1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用
     >
     > 2、如果key类型为其它的类型，则使用ArrayMap
     >
     > 
     >
     > HashMap内部有一个HashMapEntry[]对象，每一个键值对都存储在这个对象里，当使用put方法添加键值对时，就会new一个HashMapEntry对象
     >
     > ArrayMap的存储中没有Entry这个东西，他是由两个数组来维护的，mHashes数组中保存的是每一项的HashCode值，mArray中就是键值对，每两个元素代表一个键值对，前面保存key，后面的保存value
     >
     > 添加数据时扩容时的处理不一样
     >
     > HashMap 是创建一个新的容量是之前二倍的对象，然后将之前的数据移动到新的。
     >
     > ArrayMap用的是copy数据，所以效率相对要高，ArrayMap提供了数组收缩的功能，在clear或remove后，会重新收缩数组，节省空间。
     >
     > 
     >
     > 
     >
     > 1.查找效率
     >
     > HashMap因为其根据hashcode的值直接算出index，所以其查找效率是随着数组长度增大而增加的。
     >
     > ArrayMap使用的是二分法查找，所以当数组长度每增加一倍时，就需要多进行一次判断，效率下降。
     >
     > 所以对于Map数量比较大的情况下，推荐使用
     >
     > 
     >
     > 2.扩容数量
     >
     > HashMap初始值16个长度，每次扩容的时候，直接申请双倍的数组空间。
     >
     > ArrayMap每次扩容的时候，如果size长度大于8时申请size*1.5个长度，大于4小于8时申请8个，小于4时申请4个。
     >
     > 这样比较ArrayMap其实是申请了更少的内存空间，但是扩容的频率会更高。因此，如果当数据量比较大的时候，还是使用HashMap更合适，因为其扩容的次数要比ArrayMap少很多。
     >
     > 
     >
     > 3.扩容效率
     >
     > HashMap每次扩容的时候时重新计算每个数组成员的位置，然后放到新的位置。
     >
     > ArrayMap则是直接使用System.arraycopy。
     >
     > 所以效率上肯定是ArrayMap更占优势。
     >
     > 这里需要说明一下，网上有一种传闻说因为ArrayMap使用System.arraycopy更省内存空间，这一点我真的没有看出来。arraycopy也是把老的数组的对象一个一个的赋给新的数组。当然效率上肯定arraycopy更高，因为是直接调用的c层的代码。
     >
     > 
     >
     > 4.内存耗费
     >
     > 以ArrayMap采用了一种独特的方式，能够重复的利用因为数据扩容而遗留下来的数组空间，方便下一个ArrayMap的使用。而HashMap没有这种设计。
     >
     > 由于ArrayMap只缓存了长度是4和8的时候，所以如果频繁的使用到Map，而且数据量都比较小的时候，ArrayMap无疑是相当的节省内存的。
     > 原文链接：https://blog.csdn.net/rzleilei/article/details/51658938
     >
     > 
     >
     > 5.remove()
     >
     > 调用 remove() 方法可以删除 ArrayMap 的一项数据，主要逻辑如下：
     >
     > 1.如果当前 ArrayMap 只有一项数据，则会置空 mHashes、mArray，将 mSize 置为 0 。
     >
     > 2.如果当前 ArrayMap 容量过大（大于 8）并且持有数据量过小（不足 1/3）则降低 ArrayMap 的容量，减少内存占用。
     >
     > 3.上述情况都不满足时，则从 mHashes 删除相应的值，将 mArray 中对应的索引置为 null。
     >
     > 
     >
     > **总结**：
     >
     > ArrayMap 根据官方文档的定义就是为了更加有效的利用内存，从源码剖析可以看出无论从插入数据的的扩容策略还是删除数据的回收策略都是尽可能的减小大容量的申请，并且增加缓存提高内存利用率,另外无论是插入删除还是查找都涉及的二分查找以及数组搬运，因此效率较低，因此要区分不同的使用场景来选择是使用ArrayMap还是HashMap。
     > 链接：https://juejin.cn/post/7049631659116888094

2. **使用 IntDef 和 StringDef 替代枚举类型**

   > 枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：IntDef和StringDef，用来提供编译期的类型检查。

3. **LruCache**

4. **图片内存优化**

   - 图片规格
   - inSampleSize，位图的缩放功能，通过 BitmapFactory.options 设置
   - inScaled、inDensity 和 inTargetDensity 实现更细的缩放功能

5. **inBitmap**

6. **图片放置优化**

   > 只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。

7. **在 App 可用内存过低时主动释放内存**

   > 在 App 退到后台内存紧张即将被 Kill 掉时选择重写 onTrimMemory/onLowMemory 方法释放掉图片缓存、静态缓存来自保。

8. **item 被回收不可见时释放掉对图片的引用**

   - ListView
   - RecyclerView

9. **避免创建不必要的对象**

   > 比如字符串拼接时使用 StringBuilder、StringBuffer等

10. **自定义 View 中的内存优化**

    > 在 onDraw() 中不要执行对象的创建，一般都在自定义View的构造器中创建。

11. **其它的内存优化注意事项**

    - 尽使用static final 优化成员变量。
    - 使用增强型for循环语法。
    - 在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。
    - 在合适的时候适当采用软引用和弱引用。
    - 采用内存缓存和磁盘缓存。
    - 尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。



#### 五、OOM

大致分为3类：

- 线程数太多
- 打开太多文件
- 内存不足

##### 1、线程数太多

- 查看系统对每个进程的线程数限制
- 查看当前进程运行的线程数

##### 2、线程优化

- **禁用 new Thread**，统一使用线程池

  - 无法解决老代码的 new Thread；
  - 对于第三方库无法控制；

- **无侵入性的 new Thread 优化**

  Java层的`Thread`只是一个普通的对象，只有调用了`start`方法，才会调用native 层去创建线程，

  所以理论上我们可以自定义Thread，重写start方法，不去启动线程，而是将任务放到线程池中去执行，为了做到无侵入性，需要在编译期通过字节码插桩的方式，将所有`new Thread`字节码都替换成`new 自定义Thread`。

- **无侵入的线程池优化**

  - 限制空闲线程存活时间，keepAliveTime 设置小一点；
  - 允许核心线程在空闲时自动销毁；

  为了做到无侵入性，同样采用 ASM 操作字节码

- **线程监控**

  假如线程优化后还存在创建线程OOM问题，那我们就需要监控是否存在线程泄漏的情况。

  - 线程泄漏监控
  - 线程上报

##### 3、打开太多文件

##### 4、内存不足

内存不足导致的OOM，一般都是由于Java堆内存不足，绝大部分对象都是在堆中分配内存，除此之外，大数组、以及Android3.0-7.0的Bitmap像素数据，都是存放在堆中。

Java堆内存不足导致的OOM问题，线上难以复现，往往比较难定位到问题，绝大部分设备都是8.0以下的，主要也是由于**Android 3.0-7.0 Bitmap像素内存是存放在堆中**导致的。

基于这个结论，关于Java堆内存不足导致的OOM问题，**优化方案主要是图片加载优化、内存泄漏监控**。

###### 4.1 图片加载优化

- **常规的图片优化方式**

  - 软引用

  - onLowMemory

    当内存不足的时候，Activity、Fragment会调用`onLowMemory`方法，可以在这个方法里去清除缓存；

  - Bitmap 像素存储位置

    Android 3.0到8.0 之间Bitmap像素数据存在Java堆，而8.0之后像素数据存到native堆中。

    Android 8.0 之后Bitmap像素内存放在native堆，Bitmap导致OOM的问题基本不会在8.0以上设备出现了（没有内存泄漏的情况下）。

    > Fresco 使用匿名共享内存来保存Bitmap数据，首先将图片数据拷贝到匿名共享内存中，然后使用Fresco自己写的加载Bitmap的方法。

- 无侵入性自动压缩图片

  无侵入性自动压缩图片，主流的方案是利用Gradle 的Task原理，在编译过程中，`mergeResourcesTask` 这个任务是将所以aar、module的资源进行合并，我们可以在`mergeResourcesTask` 之后可以拿到所有资源文件，具体做法：

  1. 在`mergeResourcesTask`这个任务后面，增加一个图片处理的Task，拿到所有资源文件；
  2. 拿到所有资源文件后，判断如果是图片文件，则通过压缩工具进行压缩，压缩后如果图片有变小，就将压缩过的图片替换掉原图。

###### 4.2 大图监控

- **从图片框架侧监控**

  如果想监控某个图片框架， 那么我们需要熟读源码，找到hook点。

  对于Glide，可以通过hook `SingleRequest`，它里面有个`requestListeners`，我们可以注册一个自己的监听，图片加载完做一个大图检测。

- **从 ImageView 侧监控**

  假如项目中使用到的图片加载框架太多，有些第三方SDK内部可能自己搞了图片加载，

  这种情况下我们可以从`ImageView`控件侧做监控，监听`setImageDrawable`等方法，计算图片大小如果大于控件本身大小，debug包可以弹窗提示需要修改。

  方案如下：

  1. 自定义ImageView，重写`setImageDrawable、setImageBitmap、setImageResource、setBackground、setBackgroundResource`这几个方法，在这些方法里面，检测Drawable大小；
  2. 编译期，修改字节码，将所有`ImageView`的创建都替换成自定义的`ImageView`；
  3. 为了不影响主线程，可以使用`IdleHandler`，在主线程空闲的时候再检测；

###### 4.3 内存泄漏监控

- **LeakCanary**

  LeakCanary只能在debug环境使用，因为它是在当前进程dump内存快照，`Debug.dumpHprofData(path);`会冻结当前进程一段时间，整个 APP 会卡死约5～15s，低端机上可能要几十秒的时间。

- **ResourceCanary**

  微信对LeakCanary做了一些改造，将检测和分析分离，客户端只负责检测和dump内存镜像文件，文件裁剪后上报到服务端进行分析。

- **KOOM**

  线上内存泄漏监控方案

  - 检测时机

    - 间隔 5s 检测一次
    - 触发内存镜像采集的条件：
      - 当内存使用率达到 80% 以上
      - 两次检测时间内（例如5s内），内存使用率增加5%

  - 内存镜像采集

    我们知道LeakCanary检测内存泄漏，不能用于线上，是因为它dump内存镜像是在当前进程进行操作，会冻结App一段时间。

    所以，作为线上OOM监控，dump内存镜像需要单独开一个进程。

  - 内存镜像分析

###### 4.4 Native 内存泄漏监控





















### 启动优化

#### 一、应用启动流程

##### 1、应用启动类型

- **冷启动**

  从点击应用图标到 UI 界面完全显示且用户可操作的全部过程。

  **特点**：耗时最多，**衡量标准**

  **启动流程：**

  Click Event  -> IPC -> Process.start -> ActivityThread -> bindApplication -> LifeCycle -> ViewRootImpl

- **热启动**

  直接从后台切换到前台。

  **特点：**启动速度最快。

- **温启动**

  只会重走 Activity 的生命周期，而不会重走进程的创建、Application 的创建及生命周期。

  **特点：**较快，介于冷启动和热启动之间。



##### 2、冷启动分析及优化方向

**冷启动前**

- 启动 App
- 加载空白 Window
- 创建进程

> 这些都是系统行为，一般情况是无法直接干预的。

**随后任务**

- 创建 Application
- 启动主线程
- 创建 MainActivity
- 加载布局
- 布置屏幕
- 首帧绘制

**优化方向**

Application 和 Activity 的生命周期 这个阶段。



#### 二、启动耗时监测

##### 1、adb shell

```
// 其中的AppstartActivity全路径可以省略前面的packageName
adb shell am start -W [packageName]/[AppstartActivity全路径]
```

执行后会得：

```
Status: ok
LaunchState: COLD
Activity: com.xht.androidnote/.SplashActivity
TotalTime: 236		//表示所有Activity启动耗时。
WaitTime: 237		//表示AMS启动Activity的总耗时。
Complete
```

一般来说，只需查看得到的TotalTime，即应用的启动时间，其包括 **创建进程 + Application初始化 + Activity初始化到界面显示** 的过程。



##### 2、代码打点（函数插桩）

可以写一个统计耗时的工具类来记录整个过程的耗时情况。其中需要注意的有：

- 在上传数据到服务器时**建议根据用户ID的尾号来抽样上报**。
- 在项目中**核心基类的关键回调函数和核心方法**中加入打点。

主要在以下几个方面需要打点：

- **应用程序的生命周期节点**。
- **启动时需要初始化的重要方法**，例如数据库初始化，读取本地的一些数据。
- **其他耗时的一些算法**。

> **特点**：精确，可带到线上，但是代码有侵入性，修改成本高。



##### 3、AOP（Aspect Oriented Programming）打点

面向切面编程，**通过预编译和运行期动态代理实现程序功能统一维护**的一种技术。



##### 4、TraceView

主要做热点分析，用来得到以下两种数据：

- **单次执行最耗时的方法**。
- **执行次数最多的方法**。

> 可以使用 Android Studio 中的 profiler 查看 CPU
>
> https://blog.csdn.net/qq_23049111/article/details/121611781

##### 5、Systrace

- 主要用于**分析绘制性能方面的问题**。
- 分析**系统关键方法和应用方法耗时**。



#### 三、启动优化常规方案

##### 1、主题

使用Activity的windowBackground主题属性预先设置一个启动图片（layer-list实现），在启动后，在Activity的onCreate()方法中的super.onCreate()前再setTheme(R.style.AppTheme)。

**优点**

- 使用**简单**。
- **避免了启动白屏和点击启动图标不响应的情况**。

**缺点**

- **治标不治本**，表面上产生一种快的感觉。
- **对于中低端机，总的闪屏时间会更长，建议只在Android6.0/7.0以上才启用“预览闪屏”方案，让手机性能好的用户可以有更好的体验**。



##### 2、第三方库懒加载



##### 3、线程优化

###### 3.1 线程调度原理

- 任意时刻，**只有一个线程占用CPU，处于运行状态**；
- 多线程并发，轮流获取 CPU 使用权；
- JVM 负责线程调度，按照特定机制分配 CPU 使用权；



###### 3.2 Android 异步方式

1. Thread
2. HandlerThread
3. IntentService
4. AsyncTask
5. 线程池
6. RxJava

推荐度从后往前，正确场景使用正确的方式。



###### 3.3 线程使用准则

- 严禁使用 new Thread 方式；
- 提供 **基础线程池** 供各个业务线使用，避免各个业务线各自维护一套线程池，导致线程数过多；
- **根据任务类型选择合适的异步方式**：优先级低，长时间执行，HandlerThread；定时任务、耗时任务，线程池；
- 创建线程必须 **命名**，以方便 **定位线程归属**，在运行期 **Thread.currentThread().setName** 修改名字；
- 关键异步任务监控，注意 **异步不等于耗时**，建议使用 **AOP** 的方式来做监控；
- **重视优先级设置（根据任务具体情况），Process.setThreadPriority() 可以设置多次**；



###### 3.4 如何锁定线程创建者

**锁定线程创建背景**：

- 项目变大之后收敛线程；
- 项目源码、三方库、aar 中都有线程创建者；

**锁定线程创建方案**：

找 Hook 点：构造函数或者特定方法，如 Thread 的构造函数。

> 可以使用维数的 [epic](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Ftiann%2Fepic) 对Thread进行Hook。在attachBaseContext中调用DexposedBridge.hookAllConstructors方法即可。
>
> 从log找到线程创建信息，根据堆栈信息跟相关业务方沟通解决方案。



###### 3.5 线程收敛方案

- 根据线程创建堆栈考量合理性，使用统一线程库；
- 各业务线下掉自己的线程库；



基础库使用线程：

- 基础库内部暴露 API，setExecutor()；
- 初始化时注入统一的线程库；

统一线程库时区分任务类型：

- **IO密集型任务**：IO密集型任务不消耗CPU，核心池可以很大。常见的IO密集型任务如文件读取、写入，网络请求等等。
- **CPU密集型任务**：核心池大小和CPU核心数相关。常见的CPU密集型任务如比较复杂的计算操作，此时需要使用大量的CPU计算单元。



###### 3.6 线程优化核心问题

项目发展阶段忽视基础设施建设，没有采用统一线程池，导致线程数量过多。

**表现形式**：

异步任务执行太耗时，导致主线程卡顿。

**原因**：

- Java 线程调度是抢占式的，线程优先级比较重要，需要区分；
- 没有区分 IO 和 CPU 密集型任务，导致主线程抢不到 CPU；

**优化方案：**

核心：线程收敛

- 通过 Hook 方式找到对应线程的堆栈信息，和业务方讨论是否应该单独起一个线程，尽可能使用统一线程池；
- 每个基础库都暴露一个设置线程池的方法，以避免线程库更新导致基础库需要更新的问题；
- 统一线程池应该注意 IO、CPU 密集型任务区分；
- 其他细节：重要异步任务统计耗时、注重异步任务优先级和线程名的设置；



##### 4、异步初始化

###### 4.1 核心思想

子线程分担主线程任务，并行减少时间。

###### 4.2 异步优化注意点

1. 不符合异步要求；
2. 需要在某个阶段完成（采用 CountDownLatch 确保异步任务完成后才到下一个阶段）；
3. 如出现主线程使用时还没初始化则在此次使用前初始化；
4. 区分 CPU 密集型和 IO 密集型；

###### 4.3 异步初始化方案演进

1. new Thread
2. IntentService
3. 线程池
4. 异步启动器

###### 4.4 异步优化最优解：异步启动器

**异步启动器核心思想**：

充分利用 CPU 多核，自动梳理任务顺序。

**异步启动器流程**：

1. **任务Task化，启动逻辑抽象成Task**（Task即对应一个个的初始化任务）。
2. **根据所有任务依赖关系排序生成一个有向无环图**：例如上述说到的推送SDK初始化任务需要依赖于获取设备id的初始化任务，各个任务之间都可能存在依赖关系，所以将它们的依赖关系排序生成一个有向无环图能将**并行效率最大化**。
3. **多线程按照排序后的优先级依次执行**：例如必须先初始化获取设备id的初始化任务，才能去进行推送SDK的初始化任务。



##### 5、延迟初始化

###### 5.1 常规方案

**利用闪屏页的停留时间进行部分初始化**

- new Handler().postDelayed()
- 界面 UI 展示后调用

**常规延迟初始化问题**

1. 时机不容易控制，handler#postDelayed() 指定的延迟时间不好估计
2. 导致界面 UI 卡顿，此时用户可能还在滑动列表



**延迟最优解**：延迟启动器

**核心思想**：利用 IdleHandler 特性，在 CPU 空闲时执行，对延迟任务进行分批初始化。

使用队列保存添加的 task，当 CPU 空闲时，IdleHandler 会回调自身的 queueIdle()，这个时候我们可以将 task 一个一个的拿出来并执行。这种分批执行的好处在于每一个 task 占用主线程的时间相对来说很短暂，并且此时 CPU 是空闲的，这样能更有效地避免 UI 卡顿，真正的提升用户体验。

> 能异步的 task 优先使用异步启动器在 Application 的 onCreate() 方法中加载（或者是必须在 Application 的 onCreate 方法完成前执行完的非异步 task）
>
> 对于不能异步的 task，可以利用延迟启动器进行加载。
>
> 如果任务可以到用时再加载，可以使用懒加载的方式。

**延迟启动器优势：**

- 执行时机明确；
- 缓解界面 UI 卡顿；



##### 6、Multidex 预加载优化

5.0 以下一些机型会出现 ANR 或者长时间卡顿不进入引导页，原因是 MultiDex.install()  的 dexopt 过程耗时长，因此需要在初次启动时做特别处理。

5.0 以上不会出现，因为使用 ART，采用 Ahead-of-time（AOT）compilation 技术，系统在 APK 安装过程中会使用自带的 dex2oat 工具对 APK 中可用的 DEX 文件进行编译并生成一个可在本地机器上运行的文件，提高了启动速度，不过安装时间会边长。

###### 6.1 优化步骤

1. 启动时单独开一个进程去异步进行 Multidex 的第一次加载，即 Dex 提取和 Dexopt 操作；
2. 此时，主进程 Application 进入 while 循环，不断检测 Multidex 操作是否完成；
3. 执行到Multidex时，则已经发现提取并优化好了Dex，直接执行。MultiDex执行完之后主进程Application继续执行ContentProvider初始化和Application的onCreate方法。

###### 6.2 dex-opt 过程

主要包括inline以及quick指令的优化。

**inline**：使编译器在函数调用处用函数体代码代替函数调用指令。

**inline作用**：函数调用的转移操作有一定的时间和空间方面的开销，特别是对于一些函数体不大且频繁调用的函数，解决其效率问题更为重要，引入inline函数就是为了解决这一问题。



###### 6.3 抖音 BoostMultiDex 优化

在第一次启动的时候，直接加载没有经过 OPT 优化的原始 DEX，先使得 App 能够正常启动。然后在后台启动一个单独进程，慢慢的做完 dex 的 opt 工作，尽可能避免影响到前台 App 的正常使用。

绕过 ODEX 直接加载 DEX 的方案：

1. 从 APK 中解压获取原始 Secondary DEX 文件字节码；
2. 通过 dlsym 获取 dvm_dalvik_system_DexFile 数组；
3. 在数组中查询得到 Dalvik_dalvik_system_DexFile_openDexFile_bytearray函数；
4. 调用该函数，逐个传入之前从 APK 获取的 DEX 字节码，完成 DEX 加载，得到合法的DexFile对象；
5. 把DexFile对象都添加到 APP 的PathClassLoader的 pathList 里；



##### 7、类预加载优化

在 Application 中提前异步加载初始化耗时较长的类。

> 替换系统的 ClassLoader，打印类加载的时间，按需选取需要异步加载的类。



##### 8、WebView 启动优化

- WebView首次创建比较耗时，需要预先创建WebView提前将其内核初始化。
- 使用WebView缓存池，用到WebView的时候都从缓存池中拿，注意内存泄漏问题。
- 本地离线包，即预置静态页面资源。



##### 9、页面数据加载

在主页空闲时，将其它页面的数据加载好保存到内存或数据库，等到打开该页面时，判断已经预加载过，就直接从内存或数据库取数据并显示。



##### 10、启动阶段不启动子进程

子进程会共享CPU资源，导致主进程CPU紧张。此外，在多进程情况下一定要可以在onCreate中去区分进程做一些初始化工作。

> **注意启动顺序**
>
> App onCreate之前是ContentProvider初始化。



##### 11、闪屏页与主页的绘制优化

- 布局优化
- 过度绘制优化



### 绘制优化

卡顿造成绘制不流畅，造成卡顿的原因：

**界面绘制**

- 绘制层级深
- 页面复杂
- 刷新不合理

**数据处理**

- 数据处理在 UI  线程
- 占用 CPU 高，导致主线程不能拿到时间片
- 内存增加导致频繁 GC，从而引起卡顿

#### 一、Android系统显示原理

Android的显示过程可以简单概括为：**Android应用程序把经过测量、布局、绘制后的surface缓存数据、通过SurfaceFlinger把数据渲染到显示屏幕上，通过Android的刷新机制来刷新数据。**

##### 1、绘制原理

**应用层**

在Android的每个View都会经过Measure和Layout来确定当前需要绘制的View所在的大小和位置，然后，再通过Draw绘制到surface上。在Android系统中整体的绘制源码是在ViewRootImpl类的performTraversals()方法，通过这个方法可以看出Measure和Layout都是递归来获取View的大小和位置，并且以深度作为优先级。显然，层级越深，元素越多，耗时就越长。

对于绘制，Android支持两种绘制方式：

- 软件绘制（CPU）
- 硬件绘制（GPU）



硬件加速从Android 3.0开始支持，它在UI显示和绘制效率方面远高于软件绘制。但它的局限如下：

- 耗电：GPU功耗高于CPU。
- 兼容性：不兼容某些接口和函数。
- 内存大：使用OpenGL的接口需要占用内存8MB。



**系统层**

将数据渲染到屏幕上是通过系统级进程中的SurfaceFlinger服务来实现的，它的主要工作流程如下：

- **响应客户端事件，创建Layer与客户端的Surface建立连接**。
- **接收客户端数据和属性，修改Layer属性，如尺寸、颜色、透明度等**。
- **将创建的Layer内容刷新到屏幕上**。
- **维持Layer的序列，并对Layer的最终输出做裁剪计算**。

绘制的过程首先是 **CPU准备数据，通过Driver层把数据交给CPU渲染，其中CPU主要负责Measure、Layout、Record、Execute的数据计算工作，GPU负责Rasterization（栅格化）、渲染。因为图形API不允许CPU直接和GPU通信，所以要通过一个图形驱动的中间层来进行连接，在图形驱动里面维护了一个队列，CPU把display list（待显示的数据列表）添加到队列中，GPU从这个队列中取出数据进行绘制，最终才在显示屏上显示出来**。

Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，如果每次渲染都成功，这样就能够达到流畅画面所需的60FPS。



##### 2、刷新机制

在4.1版本的Project Butter中对Android Display系统进行了重构，引入了三个核心元素：VSYNC（Vertical Synchronization）、Triple Buffer（三级缓冲）、Choreographer。其中作为核心的VSYNC，即**垂直同步可认为是一种定时中断**。**而Choreographer起调度的作用，将绘制工作统一到VSYNC的某个时间点上，使应用的绘制工作有序**。

**双缓冲**

在Linux上通常使用 **Framebuffer** 来做显示输出，当用户进程更新Framebuffer中的数据后，显示驱动会把FrameBuffer中每个像素点的值更新到屏幕，**但是如果上一帧数据还没显示完，Framebuffer中的数据又更新了，就会带来残影的问题，用户会觉得有闪烁感，所以采用了双缓冲技术**。

**双缓冲其中一个称为Front Buffer，另一个称为Back Buffer。UI总是先在Back Buffer中绘制，然后再和Front Buffer交换，渲染到显示设备中。即只有当另一个buffer的数据准备好后，才会通过io_ctl系统调用来通知显示设备切换Buffer**。



**Choreographer的作用**

当收到VSYNC信号时，调用用户设置的回调函数。回调类型的优先级从高到低为CALLBACK_INPUT、CALLBACK_ANIMATION、CALLBACK_TRAVERSAL。



##### 3、卡顿的根本原因

- 绘制任务太重、绘制一帧内容耗时太长；
- 主线程太忙，导致 VSync 信号到来时还没有准备好数据从而导致丢帧；



#### 二、性能分析工具

##### 1、卡顿检测工具 Profile GPU Rendering

##### 2、TraceView

它主要用来分析函数的调用过程，可以对Android的应用程序以及Framework层代码进行性能分析。

使用TraceView查看耗时，主要**关注Calls + Recur Calls / Total和（该方法调用次数+递归次数）和Cpu Time / Call（该方法耗时）这两个值，然后优化这些方法的逻辑和调用次数，减少耗时**。

> RealTime（实际时长）的实际执行时间要比CPU Time要长，因为它包括了CPU的上下文切换、阻塞、GC等时间消耗。

##### 3、Systrace UI 性能分析

Systrace是Android 4.1及以上版本提供的性能数据采样和分析工具，它的主要作用可以归结为如下两点：

- 收集Android关键子系统（如surfaceflinger、WindowManagerService等Framework部分关键模块、服务、View系统等）的运行信息，这样可以更直观地分析系统瓶颈，改进性能。
- 跟踪系统的I/0操作、内核工作队列、CPU负载等，在UI显示性能分析上提供很好的数据，特别是在动画播放不流畅、渲染卡顿等问题上。



#### 三、布局优化方式

##### 1、减少层级

- **合理使用RelativeLayout和LinearLayout**

  RelativeLayout也存在性能低的问题，原因是RelativeLayout会对子View做两次测量。但如果在LinearLayout中有weight属性，也需要进行两次测量，但是因为没有更多的依赖关系，所以仍然会比RelativeLayout的效率高。

- **合理使用Merge**

  merge的原理：在Android布局的源码中，如果是Merge标签，那么直接将其中的子元素添加到Merge标签Parent中。

  > - Merge只能用在布局XML文件的根元素。
  > - 使用merge来加载一个布局时，必须指定一个ViewGroup作为其父元素，并且要设置加载的attachToRoot参数为true。
  > - 不能在ViewStub中使用Merge标签。原因就是ViewStub的inflate方法中根本没有attachToRoot的设置。



##### 2、提高显示速度

ViewStub是一个轻量级的View，它是一个看不见的，并且不占布局位置，占用资源非常小的视图对象。可以为ViewStub指定一个布局，加载布局时，只有ViewStub会被初始化，然后**当ViewStub被设置为可见时，或是调用了ViewStub.inflate()时，ViewStub所指向的布局才会被加载和实例化，然后ViewStub的布局属性都会传给它指向的布局**。

> - ViewStub只能加载一次，之后ViewStub对象会被置为空。所以它不适用于需要按需显示隐藏的情况。
> - ViewStub只能用来加载一个布局文件，而不是某个具体的View。
> - ViewStub中不能嵌套Merge标签。



##### 3、布局复用

include 标签

##### 4、布局优化总结

- 使用标签加载一些不常用的布局。
- 尽可能少用wrap_content，wrap_content会增加布局measure时的计算成本，已知宽高为固定值时，不用wrap_content。
- 使用TextView替换RL、LL。
- 使用低端机进行优化，以发现性能瓶颈。
- 使用TextView的行间距替换多行文本：lineSpacingExtra/lineSpacingMultiplier。
- 使用Spannable/Html.fromHtml替换多种不同规格文字。
- 尽可能使用LinearLayout自带的分割线。
- 使用Space添加间距。
- 多利用lint + alibaba规约修复问题点。
- 嵌套层级过多可以考虑使用约束布局。



#### 四、避免过度绘制

导致过度绘制的主要原因一般有如下两点：

- XML布局：控件有重叠且都有设置背景。
- View自绘：View.OnDraw里面同一个区域被绘制多次。

##### 1、过度绘制检测工具

打开手机开发者选项中的Show GPU Overdraw选项，会有不同的颜色来表示过度绘制次数，依次是无、蓝、绿、淡红、深红，分别对应0-4次过度绘制。

##### 2、避免过度绘制

- **布局上的优化**

  - 移除 xml 中非必须的背景，或根据条件设置；
  - 有选择性地移除窗口背景：getWindow().setBackgroundDrawable(null)。
  - 按需显示占位背景图片。

  > 比如：在获取Avatar的图像之后，把ImageView的Background设置为Transparent，只有当图像没有获取到时，才设置对应的Background占位图片。

- **自定义 View 优化**

  通过canvas.clipRect()来帮助系统识别那些可见的区域。这个方法可以指定一块矩形区域，只有在这个区域内才会被绘制。并且，它还可以节约CPU和GPU资源，在clipRect区域之外的绘制指令都不会被执行。

  在绘制一个单元之前，首先判断该单元的区域是否在Canvas的剪切域内。若不在，直接返回，避免CPU和GPU的计算和渲染工作。



#### 五、合理刷新机制

##### 1、减少刷新次数

- 控制刷新频率
- 避免没有必要的刷新

##### 2、避免后台线程的影响

如通过监听ListView的onScrollStateChanged事件，在滚动时暂停图片下载线程工作，结束后再开始，可以提高ListView的滚动平滑度，RecyclerView同理。

##### 3、缩小刷新区域

如自定义View一般采用invalidate方法刷新，可以使用以下重载方法指定要刷新的区域：

- invalidate(Rect dirty);
- invalidate(int left, int top, int right, int bottom);



#### 六、提升动画性能

提升动画性能主要从以下三个纬度着手：

- 流畅度：控制每一帧动画在16m内完成。
- 内存：避免内存泄漏，减小内存开销。
- 耗电：减小运算量，优化算法，减小CPU占用。



##### 1、帧动画

消耗资源最多，效果最差，能不用就不用。

##### 2、补间动画

使用补间动画实现导致View重绘非常频繁，更新DisplayList的次数过多，且有以下缺点：

- 只能用于View对象。
- 只有4种动画操作。
- 只是改变View的显示效果，但是不会真正改变View的属性。

##### 3、属性动画

相比于补间动画，属性动画重绘明显会少很多，应优先使用。

**属性动画实现原理：**

- Android属性动画通过监听帧刷新事件，在下一帧开始绘制前更新属性值；
- Android 帧刷新统一由Choreographer 指挥，在每一帧到来时，依次处理input、animation、traversal和commit事件，属性动画在animation 阶段进行属性值更新；
- Android属性更新分为两阶段，第一阶段：将动画已播放时长百分比通过时间插值器转换为动画完成百分比（即属性变化的百分比）；第二阶段：将属性变化的百分比通过类型估值器映射为特定的属性值；
- android界面绘制由两种模型：软件绘制和硬件加速绘制，软件绘制时，主线程负责执行绘制工作；硬件加速时，主线程将要绘制的内容交给渲染线程，由渲染线程执行绘制的工作。针对特定属性动画时，开启硬件加速可以提升动画流畅性；

##### 4、使用硬件加速



#### 七、卡顿监控方案

##### 1、监控原理

利用主线程的消息队列处理机制，通过自定义Printer，然后在Printer中获取到两次被调用的时间差，这个时间差就是执行时间。如果该时间超过设定的卡顿阈值（如1000ms）时，主线程卡顿发生，并抛出各种有用信息，供开发者分析。（此外，也可以在UI线程以外开启一个异步线程，定时向UI线程发送一个任务，并记下发送时间。任务的内容是将执行时间同步到发送线程，如果UI线程被阻塞，那么发送过去的任务不能被准时执行。但此方法会增加系统开销，不可取）





### 布局优化

#### 一、优化工具

##### 1.1 Systrace



##### 1.2 LayoutInspector



##### 1.3 Choreographer



#### 二、布局加载原理

##### 1、布局加载源码分析

以 AppCompatActivity 中的 setContentView(layoutResID) 为例

- 调用了代理类 AppCompatDelegate 的抽象方法 setContentView，具体实现在 AppCompatDelegateImpl 中

  ```java
  @Override
  public void setContentView(int resId) {
      LayoutInflater.from(mContext).inflate(resId, contentParent);
  }
  ```

  将传入的布局 id，解析加载到 decorView 上的 contentParent里，即 id 为 content 的 FrameLayout。

- 进入 LayoutInflater#inflate()

  ```java
  public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
      final Resources res = getContext().getResources();
  
      //1
      XmlResourceParser parser = res.getLayout(resource);
      try {
          //2
          return inflate(parser, root, attachToRoot);
      } finally {
          parser.close();
      }
  }
  ```

  - 通过 Resources 实例 res.getLayuout(resource) 获得 xmlResourceParser；

    - 具体实现在 ResourcesImpl#loadXmlResourceParser()，其中调用了 AssetManager#openXmlBlockAsset()
    - 其中调用了本地方法 nativeOpenXmlAsset，**即读取 xml 文件是通过 IO 流的方式进行的**。所以这里是 Android 布局加载流程的一个耗时点。

  - inflate(parser, root, attachToRoot)，内部通过 XmlPull 解析的方式对布局的每个节点创建对应的视图；

    - 先判断节点是否是 merge，如果是 merge 标签则进行校验，如果 merge 节点不是当前布局的父节点，则抛出异常；

    - createViewFromTag() 根据每一个标签创建对应的视图；

      - tryCreateView() 中首先判断 mFactory2 是否为空，不为空则调用其 onCreateView()，为空则判断 mFactory 是否为空，不为空则调用其 onCreateView()，否则返回 null；
      - 如果此时的tag是一个Fragment，则会调用mPrivateFactory的onCreateView方法；

    - createViewFromTag() 返回空，则调用 LayoutInflater#createView()

      通过类加载器创建对应的 class 实例，并获得对应的构造器实例，通过调用构造器实例的 instance 方法创建爱对应的 View 对象。

      **在视图节点的创建过程中采用到了反射**，反射是比较耗性能的，**过多的反射可能会导致布局加载过程变慢**，这也是后续优化的一个方向。

**布局加载流程总结**：

1. 在setContentView方法中，会通过LayoutInflater的inflate方法去加载对应的布局。
2. inflate方法中首先会调用Resources的getLayout方法去通过IO的方式去加载对应的Xml布局解析器到内存中。
3. 接着，会通过createViewFromTag根据每一个tag创建具体的View对象。
4. 它内部主要是按优先顺序为Factory2和Factory的onCreatView、createView方法进行View的创建，而createView方法内部采用了构造器反射的方式实现。



**布局加载可优化点**：

1. 布局文件解析中的 IO 过程；
2. 创建 View 对象时的反射过程；

##### 2、LayoutInflater.Factory 分析

LayoutInflater.Factory是layoutInflater中创建View的一个Hook，Hook即挂钩，我们可以利用它在创建View的过程中加入一些日志或进行其它更高级的定制化处理：比如可以**全局替换自定义的TextView等等**。

Factory与Factory2的区别：

- Factory2继承与Factory。
- Factory2比Factory的onCreateView方法多一个parent的参数，即当前创建View的父View。



#### 三、布局耗时监控

##### 1、常规方式

获取每个界面的加载耗时，在 setContentView() 方法前后进行手动埋点。

缺点：

1. 不优雅
2. 代码有侵入性



##### 2、AOP



##### 3、LayoutInflater.setFactory2()

如果需要监控每一个控件的加载耗时，可以**在基类 Activity 的 onCreate() 中直接使用 LayoutInflaterCompat.setFactory2() 对 Factory2 的 onCreateView() 进行重写**。

```java
LayoutInflaterCompat.setFactory2(getLayoutInflater(), new LayoutInflater.Factory2() {
    @Override
    public View onCreateView(View parent, String name, Context context, AttributeSet attrs) {
        if (TextUtils.equals(name, "TextView")) {
            // 生成自定义TextView
        }
        long time = System.currentTimeMillis();
        // 1
        View view = getDelegate().createView(parent, name, context, attrs);
        LogHelper.i(name + " cost " + (System.currentTimeMillis() - time));
        return view;
    }

    @Override
    public View onCreateView(String name, Context context, AttributeSet attrs) {
        return null;
    }
});
//setFactory2方法需在super.onCreate方法前调用，否则无效
```

> 在 LayoutInflaterCompat.setFactory2() 的 onCreateView() 回调中，调用了 getDelegate().createView()，这是个抽象方法，具体实现在 AppCompatDelegateImpl 中，最终调用了 AppCompatViewInflater#createView()。
>
> 在AppCompatViewInflater对象的createView方法中系统根据不同的tag名字创建出了对应的AppCompat兼容控件。看到这里，我们明白了Android系统是使用了LayoutInflater的Factor2/Factory结合了AppCompat兼容类来进行高级版本控件的兼容适配的。



#### 四、布局优化常规方案

##### 1、布局 Inflate 优化方案演进

- **代码动态创建 View**

- **替换 MessageQueue 来实现异步创建 View**

  在使用子线程创建视图控件的时候，我们可以把子线程 Looper 里的 MessageQueue 替换成主线程的 MessageQueue，在创建完需要的视图控件后记得将子线程 Looper 中的 MessageQueue 恢复为原来的。

- **AsynclayoutInflater 异步创建 View**

  布局加载过程中的两个耗时点：

  - 布局文件读取慢：IO过程。
  - 创建View慢：使用反射，比直接new的方式要慢3倍。布局嵌套层级越多，控件个数越多，反射的次数就会越频繁。

  很明显，我们无法从根本上去解决这两个问题，但是Google提供了一个从侧面解决的方案:使用AsyncLayoutInflater去异步加载对应的布局，它的特点如下：

  - 工作线程加载布局。
  - 回调主线程。
  - 节省主线程时间。

  > AsyncLayoutInflater 构造函数中创建了三个实例，一个 BasicInflater 用来加载解析布局，一个 InflaterThread 工作线程，一个 Handler 用来将创建好的 View 实例及其相关信息回调给主线程；
  >
  > 问题：
  >
  > - 不能设置LayoutInflater.Factory，需要通过自定义AsyncLayoutInflater的方式解决，由于它是一个final，所以需要将代码直接拷处进行修改。
  > - 因为是异步加载，所以需要注意在布局加载过程中不能有依赖于主线程的操作。

- **使用 X2C 进行布局优化**

  X2C框架保留了XML的优点，并解决了其IO操作和反射的性能问题。开发人员只需要正常写XML代码即可，在编译期，X2C会利用APT工具将XML代码翻译为Java代码。

##### 2、使用 ConstraintLayout 降低布局嵌套层级

- 实现几乎完全扁平化的布局。
- 构建复杂布局性能更高。
- 具有RelativeLayout和LinearLayout的特性。

其他减少布局层级和复杂度的方法：

- 不嵌套使用 RelativeLayout
- 不在嵌套使用 LinearLayout 中使用 weight
- 使用 merge 标签，减少层级，不过只能用于根 View

##### 3、过度绘制优化

- 使用ViewStub、Merge，ViewStub是一种高效占位符，用于延迟初始化。
- onDraw中避免创建大对象，进行耗时操作。
- TextView的优化，比如利用它的drawableLeft属性。

##### 4、使用标签

- **include**

  - include 标签可以将一个指定的布局文件加载到当前的布局文件中。

  - include 标签只支持以 android:layout_ 开头的属性，比如 android:layout_width，其他属性是不支持的，比如 android:background；

    如果 include 标签指定了 android:layout_* 这种属性，那么要求 android:layout_width 和 android:layout_height 必须存在，否则其它 android:layout 形式的属性无法生效；

  - android:id 这个属性是特例，如果 include 指定了这个 id 属性，同时被包含的布局文件的根元素也指定了 id 属性，那么以 include 指定的 id 属性为准；

  > LayoutInflater 解析布局文件时，会在 inflate()--->rInflate() 中解析各种tag，如 parseInclude()，会判断提示 include can only be used inside of a ViewGroup，然后解析 include 标签中 layout 属性下的xml；

- **merge**

  - merge 标签一般和 include 标签一起使用从而减少布局的层级；
  - 使用 merge 标签时，merge 标签必须是布局文件的根节点；
  - 将 merge 标签的布局文件，生成为视图时，root 必须存在，并且 attachToRoot 必须为 true，否则就会抛出 InflateException 异常；
  - 在解析布局文件时，正常情况下会以根标签对象为根，递归遍历它的 xml 子视图；而在使用 merge 标签时，则是以 root 为根（作为参数），传递给 rInflate 方法创建子视图。这一点就是 merge 标签会少一层的秘密；
  - 在 merge 标签上设置的属性无效；

  ```java
  if (TAG_MERGE.equals(name)) {
      if (root == null || !attachToRoot) {
          throw new InflateException("<merge /> can be used only with a valid "
                                     + "ViewGroup root and attachToRoot=true");
      }
  
      rInflate(parser, root, inflaterContext, attrs, false);
  }  else {
      // Temp is the root view that was found in the xml
      final View temp = createViewFromTag(root, name, inflaterContext, attrs);
  
      ViewGroup.LayoutParams params = null;
      if (root != null) {
          // Create layout params that match root, if supplied
          params = root.generateLayoutParams(attrs);
          if (!attachToRoot) {
              // Set the layout params for temp if we are not
              // attaching. (If we are, we use addView, below)
              temp.setLayoutParams(params);
          }
      }
      // Inflate all children under temp against its context.
      rInflateChildren(parser, temp, attrs, true);
  }
  ```

- **ViewStub**

  ViewStub 继承自 View，它非常轻量级且宽高都为 0，因此它本身不参与任何的布局和绘制过程。ViewStub 的意义在于按需加载所需的布局文件，在使用的时候再加载，提高了程序初始化的性能。

  如果遇到不需要显示的控件或者是布局的时候挺通常我们都会将其设置为View.Gone或者是View.INVISIBLE来达到我们想要的目的的，这样做的优点就是逻辑简单而且控制起来比较灵活，但是其缺点就是耗资源，其实在内部Xml解析的时候同样也会将其解析并且实例化、设置属性的，同样还是会消耗系统资源的。

  如果我们需要显示ViewStub 中布局文件的话，可以**调用inflate 方法**或者**调用 ViewStub.setVisibility(View.VISIBLE)**就能将布局显示出来。

  - 构造函数

    ```java
       public final class ViewStub extends View {
       
       .......
       //一般ViewStub 在xml中引用的话，都是走这个构造方法的。
       public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
           super(context);
           final TypedArray a = context.obtainStyledAttributes(attrs,
                   R.styleable.ViewStub, defStyleAttr, defStyleRes);
           saveAttributeDataForStyleable(context, R.styleable.ViewStub, attrs, a, defStyleAttr,
                   defStyleRes);
           //首先获取 inflateId 编号
           mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);
           //然后获取自定义属性 inflatedId 也就是 布局文件（xml 文件）
           mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0);
           //获取 ViewStub 定义的 id 编号
           mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);
           //记住这里需要回收（因为编译器会提示说这里内存泄漏）
           a.recycle();
           //这是是核心关键，首先设置 当前的View隐藏，同时设置自己不参与绘制，接着我们在 onDraw方法
           setVisibility(GONE);
           setWillNotDraw(true);
       }
       
       @Override
       protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
           setMeasuredDimension(0, 0);
       }
    
       @Override
       public void draw(Canvas canvas) {
       }
    }
    ```

    通过上面的代码我们可以知道 ViewStub 不参与在View的绘制中，首先是设置了View.GONE，接着调用了View方法里面的 setWillNotDraw 不参与界面绘制，而且自己的 draw方法也未任何的实现。最后将自己的宽度和高度都设置为了0。

  - setVisibility() 方法显示界面

    ```java
    public void setVisibility(int visibility) {
        //首先第一次调用的 mInflatedViewRef 是为空的，所以就进入else 分支
        if (mInflatedViewRef != null) {
            View view = mInflatedViewRef.get();
            if (view != null) {
                view.setVisibility(visibility);
            } else {
                throw new IllegalStateException("setVisibility called on un-referenced view");
            }
        } else {
            //首先这里会直接调用 view的 setVisibility方法
            super.setVisibility(visibility);
            //接着判断我们传进来的 visibility的值，如果还是 GONE的话则不做处理，最后还是调用inflate
            if (visibility == VISIBLE || visibility == INVISIBLE) {
                inflate();
            }
        }
    }
    ```

    setVisibility() 最后调用的还是 inflate()

  - inflate()

    ```java
    public View inflate() {
        final ViewParent viewParent = getParent();
        //首先判断 ViewStub是否存在父控件，同时父控件是否 ViewGroup
        if (viewParent != null && viewParent instanceof ViewGroup) {
           //同时必须设置 ViewStub的layout 信息，不能单独设置 View。
            if (mLayoutResource != 0) {
                final ViewGroup parent = (ViewGroup) viewParent;
                //将 ViewStub 的layout布局文件转化为 View，但是不添加到 parent中
                final View view = inflateViewNoAdd(parent);
                //最后在viewParen中找到ViewStub的位置，同时将inflate出来的View替换ViewStub。
                replaceSelfWithView(view, parent);
                mInflatedViewRef = new WeakReference<>(view);
                if (mInflateListener != null) {
                    mInflateListener.onInflate(this, view);
                }
    
                return view;
            } else {
                throw new IllegalArgumentException("ViewStub must have a valid layoutResource");
            }
        } else {
          //ViewStub 不能单独使用，比如是 ViewGroup的一个子View。
            throw new IllegalStateException("ViewStub must have a non-null ViewGroup viewParent");
        }
    }
    ```

    最后将实例化出来的view替换ViewStub在viewParent中的位置。

    ```java
    private void replaceSelfWithView(View view, ViewGroup parent) {
         //首先获取ViewStub 在 parent中的位置
         final int index = parent.indexOfChild(this);
         //同时将其从父控件中移除
         parent.removeViewInLayout(this);
         //注意这里获取的是 ViewStub的 LayoutParams，也就是 layout出来的参数是没效果的。只能设置ViewStub的参数才行。
         final ViewGroup.LayoutParams layoutParams = getLayoutParams();
         if (layoutParams != null) {
             parent.addView(view, index, layoutParams);
         } else {
             parent.addView(view, index);
         }
     }
    ```

  总结：

  > 首先通过 ViewStub占住位置而且又不绘制和显示在界面（原因看分析），接着我们在需要的时候调用ViewStub的setVisible方法和inflate方法来将页面显示，其原理就是将 layout 文件渲染成 view然后添加到其父控件（ViewGroup中），主要是替换之前ViewStub之前占用的位置来达到显示界面。

  ViewStub 注意事项：

  - 使用ViewStub需要在xml中设置android:layout，不是layout，否则会抛出异常；
  
  - ViewStub不能作为根布局，它需要放在ViewGroup中, 否则会抛出异常；
  
  - 一旦调用setVisibility(View.VISIBLE)或者inflate()方法之后，该ViewStub将会从视图中被移除（此时调用findViewById()是找不到该ViewStub对象)；
  
    > replaceSelfWithView() 中 parent.removeViewInLayout(this);   将自己替换为 View；
  
  - 如果指定了mInflatedId , 被inflate的layoutView的id就是mInflatedId；
  
  - 被inflate的layoutView的layoutParams与ViewStub的layoutParams相同；



#### 五、布局优化进阶方案

##### 1、使用异步布局框架 Litho

- 声明式：它使用了**声明式的API**来定义UI组件。
- 异步布局：它可以**提前布局UI**，而不会阻塞UI线程。
- 视图扁平化：它使用了Facebook开源的另一款**布局引擎Yoga进行布局**，以**自动减少UI包含的ViewGroup数量**。
- 细粒度的回收：**可以回收文本或图形等任何组件，并可以在用户界面的任何位置重复使用**。
- 内部不仅支持使用View来渲染视图，还可以使用更轻量的Drawable来渲染视图。**Litho实现了大量使用Drawable来渲染的基础组件，可以进一步使布局扁平化**。

##### 2、使用Flutter实现高性能的UI布局

##### 3、使用 RenderThread 与 RenderScript

在Android 5.0之后，Android引进了**RenderThread**，它能够实现**动画的异步渲染**。但是目前支持RenderThread完全渲染的动画，只有两种，即**ViewPropertyAnimator和CircularReveal（揭露动画）**。



#### 六、布局优化常见问题

##### 1、你在做布局优化的过程中用到了哪些工具？

我在做布局优化的过程中，用到了很多的工具，但是每一个工具都有它不同的使用场景，不同的场景应该使用不同的工具。下面我从线上和线下两个角度来进行分析。

比如说，我要统计线上的FPS，我使用的就是Choreographer这个类，它具有以下特性：

- 1、能够获取整体的帧率。
- 2、能够带到线上使用。
- 3、它获取的帧率几乎是实时的，能够满足我们的需求。

同时，在线下，如果要去优化布局加载带来的时间消耗，那就需要检测每一个布局的耗时，对此我使用的是AOP的方式，它没有侵入性，同时也不需要别的开发同学进行接入，就可以方便地获取每一个布局加载的耗时。如果还要更细粒度地去检测每一个控件的加载耗时，那么就需要使用LayoutInflaterCompat.setFactory2这个方法去进行Hook。

此外，我还使用了LayoutInspector和Systrace这两个工具，Systrace可以很方便地看到每帧的具体耗时以及这一帧在布局当中它真正做了什么。而LayoutInspector可以很方便地看到每一个界面的布局层级，帮助我们对层级进行优化。

##### 2、布局为什么会导致卡顿，你又是如何优化的？

分析完布局的加载流程之后，我们发现有如下四点可能会导致布局卡顿：

- 1、首先，系统会将我们的Xml文件通过**IO**的方式映射的方式加载到我们的内存当中，而IO的过程可能会导致卡顿。
- 2、其次，布局加载的过程是一个反射的过程，而反射的过程也会可能会导致卡顿。
- 3、同时，这个布局的层级如果比较深，那么进行布局遍历的过程就会比较耗时。
- 4、最后，不合理的嵌套RelativeLayout布局也会导致重绘的次数过多。

对此，我们的优化方式有如下几种：

- 1、针对布局加载Xml文件的优化，我们使用了异步Inflate的方式，即AsyncLayoutInflater。它的核心原理是在子线程中对我们的Layout进行加载，而加载完成之后会将View通过Handler发送到主线程来使用。所以不会阻塞我们的主线程，加载的时间全部是在异步线程中进行消耗的。而这仅仅是一个从侧面缓解的思路。
- 2、后面，我们发现了一个从根源解决上述痛点的方式，即使用X2C框架。它的一个核心原理就是在开发过程我们还是使用的XML进行编写布局，但是在编译的时候它会使用APT的方式将XML布局转换为Java的方式进行布局，通过这样的方式去写布局，它有以下优点：1、它省去了使用IO的方式去加载XML布局的耗时过程。2、它是采用Java代码直接new的方式去创建控件对象，所以它也没有反射带来的性能损耗。这样就从根本上解决了布局加载过程中带来的问题。
- 3、然后，我们可以使用ConstraintLayout去减少我们界面布局的嵌套层级，如果原始布局层级越深，它能减少的层级就越多。而使用它也能避免嵌套RelativeLayout布局导致的重绘次数过多。
- 4、最后，我们可以使用AspectJ框架（即AOP）和LayoutInflaterCompat.setFactory2的方式分别去建立线下全局的布局加载速度和控件加载速度的监控体系。

##### 3、做完布局优化有哪些成果产出？

- 1、首先，我们建立了一个体系化的监控手段，这里的体系还指的是线上加线下的一个综合方案，针对线下，我们使用AOP或者ARTHook，可以很方便地获取到每一个布局的加载耗时以及每一个控件的加载耗时。针对线上，我们通过Choreographer.getInstance().postFrameCallback的方式收集到了FPS，这样我们可以知道用户在哪些界面出现了丢帧的情况。
- 2、然后，对于布局监控方面，我们设立了FPS、布局加载时间、布局层级等一系列指标。
- 3、最后，在每一个版本上线之前，我们都会对我们的核心路径进行一次Review，确保我们的FPS、布局加载时间、布局层级等达到一个合理的状态。





### 卡顿优化

#### 一、卡顿检测工具

##### 1、CPU Profiler

**优势：**

- 图形的形式展示执行时间、调用栈等。
- 信息全面，包含所有线程。

**劣势：**

运行时开销严重，整体都会变慢，可能会带偏我们的优化方向。

```java
Debug.startMethodTracing("");
// 需要检测的代码片段
...
Debug.stopMethodTracing();
//最终生成的生成文件在sd卡：Android/data/packagename/files。
```

##### 2、Systrace



##### 3、StrictMode



#### 二、自动化卡顿监测方案

##### 1、卡顿检测方案原理

一个线程不管有多少Handler，它只会有一个Looper存在，主线程执行的任何代码都会通过Looper.loop()方法执行。而在Looper函数中，它有一个mLogging对象，这个对象在每个message处理前后都会被调用。主线程发生了卡顿，那一定是在dispatchMessage()方法中执行了耗时操作。

- **首先，我们需要使用Looper.getMainLooper().setMessageLogging()去设置我们自己的Printer实现类去打印输出logging。这样，在每个message执行的之前和之后都会调用我们设置的这个Printer实现类。**
- **如果我们匹配到">>>>> Dispatching to "之后，我们就可以执行一行代码：也就是在指定的时间阈值之后，我们在子线程去执行一个任务，这个任务就是去获取当前主线程的堆栈信息以及当前的一些场景信息，比如：内存大小、电脑、网络状态等。** 
- **如果在指定的阈值之内匹配到了"<<<<< Finished to "，那么说明message就被执行完成了，则表明此时没有产生我们认为的卡顿效果，那我们就可以将这个子线程任务取消掉。**

##### 2、AndroidPerformanceMonitor

- **BlockCanary 优势**：

  - 非侵入式。
  - 方便精准，能够定位到代码的某一行代码。

  > - 通过 Looper 提供的 setMessageLogging(printer) 函数传入一个自定义的 LooperMonitor；
  > - 在 Message 执行前开始 dump 线程堆栈和 CPU 信息；
  > - 在 Message 执行后停止 dump，并利用时间差判断是否卡顿；
  > - 如果发生了卡顿，就将 dump 的数据进行解析并通过回调传递给开发者；
  > - 开发者可以根据这些数据分析卡顿出现的原因；
  >

- **问题**：

  在卡顿的周期之内，应用确实发生了卡顿，但是获取到的卡顿信息可能会不准确，和我们的OOM一样，也就是**最后的堆栈信息仅仅只是一个表象，并不是真正发生问题时的一个堆栈**。

- **优化方案**

  **获取卡顿周期内的多个堆栈**，而不仅仅是最后一个，这样的话，如果发生了卡顿，我们就可以**根据这些堆栈信息来清晰地还原整个卡顿现场**。

  - 首先，我们会通过startMonitor方法对这个过程进行监控。
  - 接着，我们就开始**高频采集堆栈信息。如果发生了卡顿，我们就会调用endMonitor方法**。
  - 然后，将之前我们采集的多个堆栈信息记录到文件中。
  - 最后，在合适的时机上报给我们的服务器。

- **如何减少服务端对堆栈信息的处理量**

  在出现卡顿的情况下，我们**采集到了多个堆栈，大概率的情况下，可能会存在多个重复的堆栈**，而这个重复的堆栈信息才是我们应该关注的地方。我们可以**对一个卡顿下的堆栈进行能hash排重，找出重复的堆栈**。这样，**服务器需要处理的数据量就会大大减少，同时也过滤出了我们需要重点关注的对象**。



#### 三、ANR

##### 1、ANR

ANR(Application Not responding)。Android中，主线程(UI线程)如果在规定时内没有处理完相应工作，就会出现ANR。

ANR会在以下几种情况中出现：

1. 输入事件(按键和触摸事件)5s内没被处理

   Input event dispatching timed out

2. BroadcastReceiver的事件(onRecieve方法)在规定时间内没处理完(前台广播为10s，后台广播为60s)

   超时定义在 ActivityManagerService 中

3. service 前台20s，后台200s未完成启动，定义在 ActiveServices

   Timeout executing service

   > 在onCreate生命周期开始执行前，启动超时监测，如果在指定的时间onCreate没有执行完毕（该该方法中执行耗时任务），就会调用ActiveServices.serviceTimeout()方法报告ANR；如果在指定的时间内onCreate执行完毕，那么就会调用ActivityManagerService.serviceDoneExecutingLocked()方法移除SERVICE_TIMEOUT_MSG消息，说明Service.onCreate方法没有发生ANR，Service是由AMS调度，利用Handler和Looper，设计了一个TIMEOUT消息交由AMS线程来处理。

4. ContentProvider的publish在10s内没进行完

   timeout publishing content providers

   超时时间定义在 ContentResolver 中 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MILLIS =  10*1000

发生ANR到弹框在不同的组件之间时间定义是不一样的，按键是5秒。前台广播10秒，后台广播60秒。前台服务20秒，后台服务200秒。这些数据都定义在AMS中。

**ANR 发生的原因：**

- 主线程被其它线程锁：调用了 thread.sleep()、wait() 等方法，导致线程等待超时；
- 系统资源被占用：其他进程系统资源（CPU、RAM、IO）占用率高，导致该进程无法抢占到足够的系统资源；
- 主线程耗时工作导致线程卡死：例如大量的数据库读写、耗时的网络情况、高强度的硬件计算等；

##### 2、ANR 机制

##### 3、ANR线上监控

##### 4、ANR-WatchDog 原理

- 首先，我们调用了ANR-WatchDog的start方法，然后这个线程就会开始工作。
- 然后，我们**通过主线程的Handler post一个消息将主线程的某个值进行一个加值的操作**。
- post完成之后呢，我们这个线程就sleep一段时间。
- **在sleep之后呢，它就会来检测我们这个值有没有被修改，如果这个值被修改了，那就说明我们在主线程中执行了这个message，即表明主线程没有发生卡顿，否则，则说明主线程发生了卡顿**。
- 最后，ANR-WatchDog就会判断发生了ANR，抛出一个异常给我们。

##### 5、Hook Native

ANR-WatchDog解决了在高版本系统没有权限读取 /data/anr/traces.txt 文件的问题，但是**在Java层去获取所有线程堆栈以及各种信息非常耗时，对于卡顿场景不一定合适**，它可能会进一步加剧用户的卡顿。如果是**对性能要求比较高的应用,可以通过Hook Native层的方式去获得所有线程的堆栈信息**，具体为如下两个步骤：

- 通过libart.so、dlsym调用[ThreadList::ForEach](https://link.juejin.cn?target=http%3A%2F%2Fandroidxref.com%2F9.0.0_r3%2Fxref%2Fart%2Fruntime%2Fthread_list.cc%231501)方法，拿到所有的 Native 线程对象。
- 遍历线程对象列表，调用[Thread::DumpState](https://link.juejin.cn?target=http%3A%2F%2Fandroidxref.com%2F9.0.0_r3%2Fxref%2Fart%2Fruntime%2Fthread.cc%231615)方法。

通过这种方式就大致模拟了系统打印 ANR 日志的流程，但是由于采用的是Hook方式，所以可能会产生一些异常甚至崩溃的情况，这个时候就需要通过 **fork 子进程方式去避免这种问题**，而且使用 子进程去获取堆栈信息的方式可以做到完全不卡住我们主进程。

但是需要注意的是，**fork 进程会导致进程号发生改变，此时需要通过指定 /proc/[父进程 id]的方式重新获取应用主进程的堆栈信息**。

通过 Native Hook 的 方式我们实现了一套“无损”获取所有 Java 线程堆栈与详细信息的卡顿监控体系。**为了降低上报数据量，建议只有主线程的 Java 线程状态是 WAITING、TIME_WAITING 或者 BLOCKED 的时候，才去使用这套方案**。



### 包体积优化

#### 一、Apk组成

- **代码相关**：**classes.dex**，项目中所有的 Java 文件，经过编译后生成一个 **.class** 文件，所有的 .class 文件，最终经过 **dx** 工具编译生成 **classes.dex**；

- **资源相关**：**res、assets**、编译后的二进制资源文件 **resources.arsc** 和清单文件等。

  **res** 和 **assets** 的不同在于 **res** 目录下的文件会在 **.R** 文件中生成对应的资源 **ID**，而 **assets** 不会自动生成对应的 ID，而是通过 **AssetManager** 类的接口来获取。

  每当在 **res** 文件夹下放一个文件时，**aapt** 就会自动生成对应的 **ID** 并保存在 **.R** 文件中，**但 .R 文件仅仅只是保证编译程序不会报错，实际上在应用运行时，系统会根据 ID 寻找对应的资源路径，而 resources.arsc 文件就是用来记录这些 ID 和资源文件位置对应关系的文件**。

- **So 相关**：**lib** 目录下的文件；

- **META-INF**，存放了应用的 **签名信息**：

  - **MANIFEST.MF**
  - **CERT.SF**
  - **CERT.RSA**

#### 二、代码瘦身方案

##### 1、Dex

**Dex** 是 **Android** 系统的可执行文件，包含 **应用程序的全部操作指令以及运行时数据**。当 **Java** 程序被编译成 **class** 文件之后，还需要使用 **dx** 工具将所有的 **class** 文件整合到一个 **dex** 文件中，这样 **dex 文件就将原来每个 class 文件中都有的共有信息合成了一体**，这样做的目的是 **保证其中的每个类都能够共享数据**，这在一定程度上 **降低了信息冗余**，同时也使得 **文件结构更加紧凑**。



##### 2、ProGuard

代码混淆也被称为 **花指令**，它 **将计算机程序的代码转换成一种功能上等价，但是难以阅读和直接理解的形式**。混淆器的 **作用** 不仅仅是 **保护代码**，它也有 **精简编译后程序大小** 的作用，其 **通过缩短变量和函数名以及丢失部分无用信息等方式，能使得应用包体积减小**。

在 **Android SDK** 里面集成了一个工具 — **Proguard**，它是一个免费的 **Java** 类文件 **压缩、优化、混淆、预先校验** 的工具。它的 **主要作用** 大概可以概括为 **两点**：

- **瘦身：它可以检测并移除未使用到的类、方法、字段以及指令、冗余代码，并能够对字节码进行深度优化。最后，它还会将类中的字段、方法、类的名称改成简短无意义的名字**。
- **安全：增加代码被反编译的难度，一定程度上保证代码的安全**。

具体细分为三点：

- 压缩（Shrinking）

  默认开启，以减小应用体积，移除未被使用的类和成员，并且 **会在优化动作执行之后再次执行**，因为优化后可能会再次暴露一些未被使用的类和成员。

- 优化（Optimization）

  默认开启，在 **字节码级别执行优化**，让应用 **运行的更快**。

- 混淆（Obfuscation）

  默认开启，增大反编译难度，类和类成员会被随机命名，除非用 优化字节码 等规则进行保护。



##### 3、D8 与 R8

###### 3.1 D8

优化效果：

- Dex 的编译时间更短
- .dex 文件更小
- D8 编译的 .dex 文件拥有更好的运行时性能
- 包含 Java 8 语言支持的处理

> **Android Studio 3.1** 或之后的版本 **D8** 将会被作为默认的 **Dex** 编译器。



###### 3.2 R8

**R8 是 Proguard 压缩与优化部分的替代品**，并且它仍然使用与 **Proguard** 一样的 **keep** 规则。

Android Studio 3.4 或 Android Gradle 插件 3.4.0 及其更高版本，R8 会作为默认编译器。否则，我们 **必须要在 gradle.properties 中配置如下代码让 App 的混淆去支持 R8**

> android.enableR8=true
> android.enableR8.libraries=true



##### 4、去除 debug 信息与行号信息

**Dex** 文件的结构主要分为 **四大块：header 区，索引区，data 区，map 区**。而我们的 **debug** 与行号信息就保存在 **data 区中的 debugItems 区域**。而 **debug_items** 里面主要包含了 **两种信息**，如下所示：

- **调试的信息：包含函数的参数和所有的局部变量**。
- **排查问题的信息：包含所有的指令集行号与源文件行号的对应关系**。



##### 5、Dex 分包优化

当我们的 **APK** 过大时，**Dex** 的方法数就会超过65536个，因此，必须采用 **mutildex** 进行分包，但是此时每一个 **Dex** 可能会调用到其它 **Dex** 中的方法，这种 **跨 Dex 调用的方式会造成许多冗余信息**，具体有如下两点：

- 多余的 method id：跨 Dex 调用会导致当前dex保留被调用dex中的方法id，这种冗余会导致每一个dex中可以存放的class变少，最终又会导致编译出来的dex数量增多，而dex数据的增加又会进一步加重这个问题。
- 其它跨dex调用造成的信息冗余：除了需要多记录被调用的method id之外，还需多记录其所属类和当前方法的定义信息，这会造成 string_ids、type_ids、proto_ids 这几部分信息的冗余。

为了减少跨 **Dex** 调用的情况，我们必须 **尽量将有调用关系的类和方法分配到同一个 Dex 中**。

> **ReDex** 的 [CrossDexDefMinimizer](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Ffacebook%2Fredex%2Fblob%2Fmaster%2Fopt%2Finterdex%2FCrossDexRefMinimizer.cpp) 类分析了类之间的调用关系，并 **使用了贪心算法去计算局部的最优解（编译效果和dex优化效果之间的某一个平衡点）。使用 "InterDexPass" 配置项可以把互相引用的类尽量放在同个 Dex，增加类的 pre-verify，以此提升应用的冷启动速度**。

**使用 ReDex 进行分包优化、去除 debug 信息及行号信息**。



##### 6、使用 XZ Utils 进行 Dex 压缩

##### 7、三方库处理

- 统一三方库
- 尽量选择比较小的库来实现形同的功能
- 只引入部分需要的代码

##### 8、移除无用的代码

- 使用 AOP 判断哪些类在线上环境下用户不会用到；

  对于 Activity，只需要在每个 Activity 的 onCreate() 中加上统计；对于不是 Activity 的类，统计它们的构造函数；

- 使用 Lint 检测无效的代码

##### 9、避免产生 Java access 方法

为了能提供内部类和其外部类直接访问对方的私有成员的能力，又不违反封装性要求，**Java 编译器在编译过程中自动生成 package 可见性的静态 access$xxx 方法，并且在需要访问对方私有成员的地方改为调用对应的 access 方法**。

**避免产生 access 方法的方式**

主要有 **两种方式** 避免产生 **access** 方法：

- 在开发过程中需要注意在可能产生 access 方法的情况下适当调整，比如去掉 private，改为 package 可见性。
- 使用 ASM 在编译时删除生成的 access 方法。



##### 10、利用 ByteX Gradle 插件平台中的代码优化插件



#### 三、资源瘦身方案

**Android** 构建工具链中使用了 **AAPT/AAPT2** 工具来对资源进行处理，**Manifest、Resources、Assets 的资源经过相应的 ManifesMerger、ResourcesMerger、AssetsMerger 资源合并器将多个不同 moudule 的资源合并为了 MergedManifest、MergedResources、MergedAssets。然后，它们被 AAPT 处理后生成了 R.java、Proguard Configuration、Compiled Resources**。

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1e134ae18c474d1cbcc522110be213f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)



##### 1、冗余资源优化

- 使用 Lint 的 Remove Unused Resource

  > **Android Lint 不会分析 assets 文件夹下的资源，因为 assets 文件可以通过文件名直接访问，不需要通过具体的引用，Lint 无法判断资源是否被用到**。

- 优化 shrinkResources 流程真正去除无用资源

  shrinkResources true 来 开启资源压缩，资源压缩工具只会把无用的资源替换成预定义的版本而不是移除。

  可以 **在 Android 构建工具执行 package${flavorName}Task 之前通过修改 Compiled Resources 来实现自动去除无用资源**。



##### 2、重复资源优化

##### 3、图片压缩

我们可以在 [tinypng](https://link.juejin.cn?target=https%3A%2F%2Ftingpng.com%2F) 这个网站进行图片压缩，但是如果 **App** 的图片过多，一个个压缩也是很麻烦的。因此，我们可以 **使用 [McImage](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FsmallSohoSolo%2FMcImage%2Fblob%2Fmaster%2FREADME-CN.md)、[TinyPngPlugin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2FDeemonser%2FTinyPngPlugin) 或 [TinyPIC_Gradle_Plugin](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmeili%2FTinyPIC_Gradle_Plugin%2Fblob%2Fmaster%2FREADME.zh-cn.md) 来对图片进行自动化批量压缩**。但是，需要注意的是，**在 Android 的构建流程中，AAPT 会使用内置的压缩算法来优化 res/drawable/ 目录下的 PNG 图片，但这可能会导致本来已经优化过的图片体积变大**，因此，可以通过在 **build.gradle** 中 **设置 cruncherEnabled 来禁止 AAPT 来优化 PNG 图片**，代码如下所示：

```groovy
aaptOptions {
    cruncherEnabled = false
}
```

普遍使用更多的 **png** 或者是 **jpg** 格式来说，相同的图片转换为 **webp** 格式之后会有大幅度的压缩。**对于 png 来说，它是一个无损格式，而 jpg 是有损格式。jpg 在处理颜色图片很多时候根据压缩率的不同，它有时候会去掉我们肉眼识别差距比较小的颜色，但是 png 会严格地保留所有的色彩**。所以说，在图片尺寸大，或者是色彩鲜艳的时候，**png** 的体积会明显地大于 **jpg**。



##### 4、使用针对性的图片格式

如果能用 VectorDrawable 来表示的话，则优先使用 VectorDrawable；否则，看是否支持 WebP，支持则优先用 WebP；如果也不能使用 WebP，则优先使用 PNG，而 PNG 主要用在展示透明或者简单的图片，对于其它场景可以使用 JPG 格式。



##### 5、资源混淆

同代码混淆类似，资源混淆将 **资源路径混淆成单个资源的路径**，这里我们可以使用 **AndroidResGuard**，它可以使冗余的资源路径变短，例如将 **res/drawable/wechat** 变为 **r/d/a**。

资源混淆工具主要是通过 **短路径的优化**，以达到 **减少  resources.arsc、metadata 签名文件以及 ZIP 文件大小** 的效果，其效果分别如下所示：

- **resources.arsc**：它记录了资源文件的名称与路径，使用混淆后的短路径  res/s/a，可以减少文件的大小。
- **metadata 签名文件：**签名文件 MANIFEST.MF 与 CERT.SF 需要记录所有文件的路径以及它们的哈希值，使用短路径可以减少这两个文件的大小。
- **ZIP 文件：ZIP **文件格式里面通过其索引记录了每个文件 Entry 的路径、压缩算法、CRC、文件大小等等信息。短路径的优化减少了记录文件路径的字符串大小。



##### 6、R Field 的内联优化

可以通过内联 **R Field** 来进一步对代码进行瘦身，此外，它也**解决了 R Field 过多导致 MultiDex 65536 的问题**。要想实现内联 **R Field**，我们需要 **通过 Javassist 或者 ASM 字节码工具在构建流程中内联 R Field**。

> 实现原理为：
>
> **android 中的 R 文件，除了 styleable 类型外，所有字段都是 int 型变量/常量，且在运行期间都不会改变。所以可以在编译时，记录 R 中所有字段名称及对应值，然后利用 ASM 工具遍历所有 Class，将除 R$styleable.class 以外的所有 R.class 删除掉，并且在引用的地方替换成对应的常量**，从而达到缩减包大小和减少 **Dex** 个数的效果。此外，最近 **ByteX** 也增加了 [shrink_r_class](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbytedance%2FByteX%2Fblob%2Fmaster%2Fshrink-r-plugin%2FREADME-zh.md) 的 **gradle** 插件，它不仅可以在编译阶段对 **R** 文件常量进行内联，而且还可以 **针对 App 中无用 Resource 和无用 assets 的资源进行检查**。



##### 7、资源合并方案

##### 8、资源最少化配置

根据 App 目前所支持的语言版本去选用合适的语言资源，通过 resConfig 来配置使用哪些语言，从而让构建工具移除指定语言之外的所有资源。同理，也可以使用 resConfigs 去配置你应用需要的图片资源文件类。

##### 9、尽量每张图片只保留一份

我们统一只把图片放到 **xhdpi** 这个目录下，那么 **在不同的分辨率下它会做自动的适配**，即 **等比例地拉伸或者是缩小**。

##### 10、资源在线化

我们可以 **将一些图片资源放在服务器**，然后 **结合图片预加载** 的技术手段，这些 既可以满足产品的需要，同时可以减小包大小。

##### 11、统一应用风格

如设定统一的 **字体、尺寸、颜色和按钮按压效果、分割线 shape、selector 背景** 等等。



#### 四、So 瘦身方案

##### 1、So 移除方案

**So** 是 **Android** 上的动态链接库，在我们 **Android** 应用开发过程中，有时候 **Java** 代码不能满足需求，比如一些 **加解密算法或者音视频编解码功能**，这个时候就必须要通过 **C** 或者是 **C++** 来实现，之后生成 **So** 文件提供给 **Java** 层来调用，在生成 **So** 文件的时候就需要考虑生成市面上不同手机 **CPU** 架构的文件。目前，**Android** 一共 **支持7种不同类型的 CPU 架构**，比如常见的 **armeabi、armeabi-v7a、X86** 等等。理论上来说，**对应架构的 CPU 它的执行效率是最高的**，但是这样会导致 **在 lib 目录下会多存放了各个平台架构的 So 文件**，所以 **App** 的体积自然也就更大了。

因此，我们就需要对 **lib** 目录进行缩减，我们 **在 build.gradle 中配置这个 abiFiliters 去设置 App 支持的 So 架构**。

##### 2、So 移除方案优化版

对于性能敏感的模块，它使用到的 So，我们都放在 armeabi 目录当中随着 Apk 发出去，然后我们在代码中来判断一下当前设备所属的 CPU 类型，根据不同设备 CPU 类型来加载对应架构的 So 文件。

##### 3、使用 XZ Utils 对 Native Library 进行压缩

##### 4、对 Native Library 进行合并

##### 5、删除 Native Library 中无用的导出 symbol

##### 6、So 动态下载

将部分 So 文件使用动态下发的形式进行加载。



#### 五、其它优化方案

##### 1、插件化

可以使用插件化的手段 **对代码结构进行调整**，如果我们 **App** 当中的每一个功能都是一个插件，并且都是可以从服务器下发下来的，那 **App** 的包体积肯定会小很多。

##### 2、业务梳理

评估删除无用业务

##### 3、转变开发模式

采用 H5、小程序等模式

#### 六、总结

- **代码：Proguard、统一三方库、三方库仅引入需要的功能、无用代码删除**。
- **资源：无用资源删除、资源混淆、图片压缩、资源在线化**。
- **So：只保留 Armeabi、更优方案、So 动态下载**。





### 网络优化

#### 一、网络层次结构

##### 1、OSI 七层模型

| **OSI**    | 功能                               |
| ---------- | ---------------------------------- |
| 应用层     | 为计算机用户提供接口和服务。       |
| 表示层     | 数据处理：编解码、加解密等等。     |
| 会话层     | 管理（建立、维护、重连）通信会话。 |
| 传输层     | 管理端到端的通信连接。             |
| 网络层     | 数据路由：决定数据在网络中的路径。 |
| 数据链路层 | 管理相邻节点之间的数据通信。       |
| 物理层     | 数据通信的光电物理特性。           |

##### 2、TCP/IP 四层模型

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7454df8807f8402f8fea938f3efbf62f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)



#### 二、应用层

**传输层与之下的层已经提供了完整的通信服务**。而应用层是面向用户的一层。它主要是用来 **定义应用间通信的规则**，例如应用进程的报文类型（请求报文、应答报文）、报文的语法、格式、应用进程发送数据的时机、规则等等。

##### 1、DNS(Domain Name System)域名系统服务

域即对应的网络号，名即对应的主机名字。

- 功能

  通过把没有规则的点分十进制 IP 地址转换为可以理解的一些域名。

- 域名

  - 使用域名可以帮助记忆。
  - 域名通过 DNS 服务可以被转换成 IP 地址。
  - 域名是由点、字母和数字组成的。
  - 点分割不同的域。
  - **域名可以分为顶级域、二级域、三级域...，例如：[www.taobao.com](https://link.juejin.cn/?target=http%3A%2F%2Fwww.taobao.com) => - 三级域.二级域.顶级域**。

  **顶级域常见分类**

  - 国家
    - cn
    - us
  - 通用
    - com
    - net
    - gov
    - org

  **二级域**

  例如：qq、aliyun、taobao、google、facebook 等等。

  **顶级域、二级域、三级域组成了一个树状结构。且在顶级域名服务器上面还有一个根域名服务器**。

- 域名服务器

  只要有一个外网的服务器就可以搭建一个域名的服务器。

##### 2、DHCP(Dynamic Host Configuratin Protocol) 动态主机设置协议

##### 3、HTTP(HyperText Tranfsfer Protocol) 超文本传输协议

###### 3.1 HTTP

- HyperText 即超文本、超链接，Http 是指在电脑中显示的、**含有可以指向其他文本的链接文本**。
- 对于这些内容都有一个统一的路径，例如： `http(s)://<主机>:<端口>/<路径>`。
- **HTTP 协议底层是 TCP 协议，因此它是可靠的数据传输协议**。

###### 3.2 Web 服务器

分为硬件部分（计算机或云上的虚拟设备）和软件部分（Nginx、Apache)。

**过程**：

1. 接收客户端连接
2. 接收请求报文
3. 处理请求
4. 访问 Web 资源
5. 构造应答
6. 发送应答

###### 3.3 HTTP 请求方法

**GET 和 POST 的区别**

- get参数通过url传递，post放在request body中。
- get请求在url中传递的参数是有长度限制的，而post没有。
- get比post更不安全，因为参数直接暴露在url中，所以不能用来传递敏感信息。
- get请求只能进行url编码，而post支持多种编码方式。
- get请求会浏览器主动cache，而post支持多种编码方式。
- get请求参数会被完整保留在浏览历史记录里，而post中的参数不会被保留。
- GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。

###### 3.4 HTTP请求、响应、请求头、响应码：

- HTTP请求：请求行、请求头、空行、请求数据
  - 请求行 `GET /index.html HTTP/1.1` 包含请求方法、URL字段、HTTP协议版本
- HTTP响应：状态行、消息报头、空行、响应正文
- 常见请求头
  - Host：主机和端口号
  - Connection：连接类型
  - User-Agent：浏览器类型
  - Accept：传输文件类型
  - Referer：页面跳转处
  - Cookie
  - Content-Length：请求消息正文的长度
- 常见响应码
  - 1xx--临时响应：表示临时响应并需要请求者继续执行操作的状态码
  - 2xx--成功：表示成功处理了请求的状态码
    - 200：ok，服务器已成功处理了请求
    - 204：no content，请求处理成功，但没有资源可返回
    - 206：Partial Content，表示客户端进行了范围请求，而服务器成功执行了这部分请求，响应报文中包含由 Content-Range 指定范围的实体内容。
  - 3xx--重定向：表示要完成请求，需要进一步操作
    - 304：no modified，表示客户端发送附带条件（请求报文中包含 If-Match、If-Modified-Since等请求头标签）的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3xx 类别中，但是和重定向没有关系。
  - 4xx--客户端错误：表示请求可能出错，服务器无法处理请求
    - 400：bad request，表示请求报文中存在语法错误，服务器无法理解这个请求；
    - 401：unauthorized，表示发送的请求需要有通过HTTP认证的认证信息；
    - 403：forbidden，表示对请求资源的访问被服务器拒绝了；
    - 404：not found，表示服务器上无法找到请求的资源；
  - 5xx--服务器错误：表示服务器在尝试处理请求时发生内部错误
    - 500：internal server error，表示服务器在执行请求时发生了错误；
    - 503：service unavailable，表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求；

##### 4、HTTPS

###### 4.1 加密模型

- 对称加密

  加密和解密都是使用同一个秘钥，如  AES；

- 非对称加密

  公钥加密，私钥解密，并且公钥与私钥是拥有一定数学关系的一组秘钥。

  - 私钥：自己使用，不对外公开；
  - 公钥：给大家使用，对外公开；

  如 RSA 非对称加密

- 此外，还有 Hash 加密算法

  HASH 算法：MD5，SHA1，SHA256

  > HTTPS = HTTP + SSL，HTTPS 的加密就是在 SSL 中完成的

4.2 数字证书 签名校验

数字证书是可信任组织颁发给特定对象的认证。而可信任组织即客户端与服务端都认为安全的组织。

数字证书格式

- 证书格式、版本号
- 证书序列号
- 签名算法
- 有效期
- 对象名称
- 对象公开秘钥

###### 4.3 SSL（Secure Sockets Layer）安全套接层

**SSL 位于传输层与应用层之间，它是一个子层，作用主要有两点**：

- 数据安全（保证数据不会被泄漏）与数据完整（保证数据不会被篡改）。
- 对数据进行加密后传输。

**HTTPS 的通信过程**

1. 443 端口的 TCP 连接；
2. SSL 安全参数握手；
3. 客户端发送数据；
4. 服务端发送数据；

**SSL 握手建立过程：**

1. 客户端和服务端建立 SSL 握手，客户端通过 CA 证书来确认服务器的身份；
2. 互相传递三个随机数，之后通过这随机数来生成一个密钥；
3. 互相确认密钥，然后握手结束；
4. 数据通讯开始，都是用同一个对话密钥来加解密；

> **HTTPS 综合地运用了对称加密与非对称加密，在进行随机数校验的阶段是使用了非对称加密来进行通信的，然后等双方都确定了三个随机数之后，就可以使用相同的算法来生成对称秘钥进行加密通信了。HTTPS 的优势在于双端分别生成了秘钥，没有经过传输，减少了秘钥泄漏的可能性**。



##### 5、Http2

特点：

- 头部压缩

- 多路复用

  多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。

- 提升访问速度

- 二进制分帧

- 设置请求优先级

- 服务端推送



##### 6、cookie

HTTP 是一个无状态协议，因此 Cookie 的最大的作用就是存储 sessionId 用来唯一标识用户。并且，Cookie 本质上就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储。

**生存周期**

通过 Expires 和 Max-Age 两个属性来设置：

- Expires：过期时间。
- Max-Age：表示一段时间间隔，单位是秒，从浏览器收到报文开始计算。

#### 三、传输层

当设备 A 与 设备 B 相互通信时，我们可以认为它们就是通过一个虚拟的互连网络进行连接的。**在虚拟的互连网络里面已经解决了网络拓扑、数据路由的走向等问题。在传输层重点解决的是两个设备它们直接是如何进行通信的**。

##### 1、传输层的主要功能

###### 1.1 进程与进程的通信

不同于在单个操作系统内使用的进程间通信（Unix 域套接字、共享内存），网络通信可以跨设备、跨网络进行通信。

###### 1.2 端口的概念

- 使用端口来标记不同的网络进程。
- 端口使用16比特位表示（0~65535）。

常见的协议端口：FTP 21、HTTP 80、HTTPS 443、DNS 53、TELNET 23

##### 2、UDP(User Datagram Protocol)用户数据报协议

###### 2.1 功能

UDP 协议不会对数据报进行任何的处理，既不合并，也不拆分数据；

###### 2.2 特点

- **无连接**，通信时不需要提前建立连接；
- **不保证可靠的数据交付**，想发就发，无法保证数据在网络传输过程中是否会丢失；
- **面向报文传输**，不对数据做任何处理，而是直接将应用层数据塞进报文里面；
- **没有拥塞控制**，不管网络是否堵塞，它都会把数据交付出去；
- **首部开销很小**，首部仅仅占用 8 个字节；

##### 3、TCP(Transmission Control Protocol) 传输控制协议

###### 3.1 特点

- **面向连接**
- **点对点通信**
- **可靠的传输服务**
- **全双工通信**，两个设备在连接时，它们都可以同时的发送数据与接收数据
- **面向字节流的协议**，TCP 处理的是一个一个的字节，所以TCP 很可能会取出数据中的某一段进行传输，而剩下的数据会把它放到第二个及之后的 TCP 报文中进行传输。因此 TCP 协议可能会对用户的数据进行合并或分拆。

##### 4、可靠传输的基本原理

###### 4.1 停止等待协议

- 当发送方发送一个消息时，接收方接收到了并将确认信息发给发送方，这个过程中 **发送方需要停止等待接收方的确认信息**。
- 超时重传

###### 4.2 连续 ARQ（Automatic Repeat Request）自动重传请求协议



##### 5、TCP 协议的可靠传输

TCP 的可靠传输基于连续 ARQ 协议：

- 滑动窗口
- 累计确认
- 选择重传



##### 6、TCP 的连接、释放

###### 6.1 TCP 的连接建立 - 三次握手

> 1、客户端向服务器申请建立TCP连接，向服务发送一个SYN报文，作为第一次握手。客户端把这段连接的SYN设定为随机数A。
>
> 2、服务器端收到SYN报文后，会向客户端发送一个报文。报文中ACK的确认码为A+1，同时发送另一个SYN为随机序号B。
>
> 3，此时，客户端收到ACK为A+1的报文，将之与发送的SYN包进行比对，如果满足+1的关系，则在客户端判断连接已建立。并给服务器发送确认数据包，SYN为A+1，表明已收到上一报文，ACk为B+1，通知服务器进入连接状态。

###### 6.2 TCP 的连接释放 - 四次挥手

> 1、客户端向服务器发送一个FIN报文，作为第一次挥手。通知服务器，我已经没有数据还要发送。但不确认服务器是否仍有数据返回，所以连接仍是建立状态。
> 2、服务器收到FIN报文，返回一个ACK报文，告诉客户端，我知道你已经没有东西要发送了，但我还要再确认一下我是不是还有东西要给你。
> 3、服务器判断自己也没有报文需要发送给客户端，发送FIN报文，告诉客户端，好了，这下我也没有东西要给你了，你可以终结连接了。此时服务器不确认客户端是否收到信息，继续保持连接。
> 4、客户端收到ACK和FIN消息后，得知服务器已经知道自己要终结，并无更新内容，便给服务器发送一个ACK说我知道了，你也终结吧，客户机便终结连接。服务器在收到一条ACK后，也终结连接。



##### 7、TCP 与 UDP 的区别

- UDP 通常用于多媒体信息分发，即视频、语音、实时信息 等等。而 TCP 通常用于可靠信息的传输，应用场景包括金融交易、可靠通信、MQ 等等。
- TCP 面向连接，UDP 是无连接的。
- TCP 提供可靠的服务，也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。
- TCP 的逻辑通信信道是全双工的可靠信道；UDP 则是不可靠信道。
- 每一条 TCP 连接只能是点到点的；UDP 支持一对一，一对多，多对一和多对多的交互通信。
- TCP 面向字节流（可能出现黏包问题），实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的（不会出现黏包问题）。
- UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 IP 电话，实时视频会议等）
- TCP 首部开销20字节；UDP 的首部开销小，只有 8 个字节。



##### 8、套接字

###### 8.1 Socket 概念

- 套接字是一个抽象的概念，表示 TCP 连接的一端。
- 通过套接字可以进行数据的发送或接收。
- TCP = { Socket1:Socket2} = {{IP:Port}{IP:Port}}，可以看到，TCP 由两个套接字组成。

###### 8.2 Socket 编程

- 服务端编程
  - 创建 Socket
  - 绑定 Socket
  - 监听 Socket
  - 接收 & 处理信息
- 客户端编程
  - 创建 Socket
  - 连接 Socket
  - 发送消息



#### 四、网络优化纬度

##### 1、流量优化

精确获取网络流量的消耗量，解决整体均值掩盖单点异常流量的问题。

##### 2、网络监控

建设全面的网络监控，因为粗粒度的监控不能够帮助我们发现和解决问题。

##### 3、流量消耗

- 精准获取一段时间的流量消耗、网络类型、前后台。
- 用户流量消耗均值、异常率（消耗多、次数多）。
- 完整链路全监控（Request、Response）、主动上报。

##### 4、网络请求质量

- 请求时长、业务成功率、失败率、TOP 失败接口，导致请求失败的原因通常有两种情况：
  - 弱信号：可以简单看成手机信号只有一两格的时候，这是不仅仅是信令（无线网络通信的都是一个个的信令）发出去困难，还可能导致不断切换网络、基站。App 只能在应用层做重试，因为弱信号一般都是一时的。
  - 拥塞网络：可以类比为堵车、排队的场景，数据包排队，信令也在排队。这时 App 不断重试，只会使得拥塞网络更为严重。我们只能让自己的非核心业务不要去排队，并让核心业务的数据量更少，协议来回更少。
- 用户体验
- 请求速度、成功率
- 弱网：网络不稳定时如何最大程度上保证网络的连通性
- 安全：如何防止被第三方劫持、窃听甚至篡改

##### 5、其他

- 公司成本
- 带宽、服务器数量、CDN
- 耗电



#### 五、网络优化工具

##### 1、Network Profiler

**特点**

- 显示实时网络活动：发送、接收数据及连接数。
- 需启动高级分析。
- 仅支持 HttpURLConnection 与 OkHttp

**打开高级分析**

> Run => Edit Cofigurations => 界面最右边 Profiling => 打开 Enable advanced profiling （required for API level < 26 only）



##### 2、Charles

- 断点功能
- Map Local
- 弱网环境模拟



##### 3、Wireshark

##### 4、TcpDump

##### 5、Stetho

##### 6、其它的性能检测工具



#### 六、精准获取流量消耗

##### 1、如何判断 App 流量消耗偏高？

- 绝对值看不出高低。
- 对比竞品，相同 Case 对比流浪消耗。
- 异常监控超过正常指标。

##### 2、测试方案

- 打开手机设置 => 流量管理 => 仅允许目标 App 联网
- 可以查找出大多数的问题，但是线上场景线下可能遇不到。

##### 3、线上流量获取方案

- **TrafficStats**

  特点：

  - API 18 以上；
  - 记录手机重启以来的数据流量；

  缺点：

  > 无法获取某个时间段的流量消耗；

- **NetworkStatsManager**

  API 23 之后。

  **特点**

  - 获取指定时间间隔内的流量信息。
  - 获取不同网络类型下的消耗。

  **NetUtils.getStats**

  获取指定时间间隔的 蜂窝 + WIFI 流量总信息

##### 4、前后台流量获取方案

**实现原理**

> 后台定时任务 => 获取时间间隔内流量 => 记录前后台 => 分别计算 => 上报 APM 后台 => 流量治理依据

**小结**

- 该方案无法获取应用在前后台切换时的流量，因此有一定的误差，但这个误差是可以接受的。
- 结合精细化的流量异常报警针对性的解决后台跑流量的问题。



#### 七、网络请求流量优化

##### 1、常见使用网络的场景

- **数据压缩**

  POST 请求 Body 使用 GZip 压缩，同时服务端返回 Body 也使用 GZip 压缩。

  > OkHttp会自动进行Gzip处理，如果请求中加入 GZip，则需要自己解压，OkHttp 不再解压；
  >
  > OkHttp会根据响应头中指定的编码来处理字符数据，如果响应头中没有编码，OkHttp 默认 UTF-8；

- **图片**

  - 图片上传前压缩。
  - 图片使用策略细化：让 服务端/CDN 云服务器 优先使用缩略图/WebP格式图片。

- **性能日志上报：批量 + 特定场景上报**

  APM 相关、单点问题相关。例如埋点数据可以等到某一时机点（例如 开启了 WIFI、数据量过大必须上传一部分时）再上传。

- **数据缓存**

  服务端返回加上过期时间，避免每次重新获取。 节约流量且大幅提高数据访问速度，更好的用户体验。

  **Request 缓存设置**

  1. Pragma:no-cache：去服务器拉取最新的资源，不使用缓存。
  2. If-Modified-Since:datetime：如果资源在客户端提供的时间后发生改变，服务器会返回新的资源，否则使用缓存。
  3. If-None-Match:etagvalue：如果资源的标识和服务器的不同，返回新的资源。

  当 Request 的头部是 2 和 3 时，如果服务器的资源没有修改，则服务器会返回 HTTP/304 Not Modified，客户端会使用缓存的 Response。

  **Response 缓存设置**

  HTTP Response 是否可以缓存是由 Response 的头部控制的，服务器可以通过 Expires 和 Cache-Control 控制 Response 如何在客户端缓存。

  **Expires**

  Expires 头部会包含一个日期，即该资源缓存的有效期，客户端有新的相同请求时，如果资源缓存没有过期，则使用缓存资源，服务器不会返回任何东西。

  **Cache-Control**

  Cache-Control 可以标明 Response 如何存储及其如何使用，其选项如下所示：

  - public：Response 可以存储在任何 Cache 中，包括共享的 Cache。
  - private：Response 存储在私有 Cache 中，只能被一个用户使用。
  - no-cache：Response 将来不会被使用。
  - no-store：Response 将来不会被使用，也不会写到磁盘上。
  - max-age=#seconds：Response 在设定的时间内可以被重复使用。
  - must-revalidate：和原始服务器确认 Response 是最新后，可以使用缓存。

  **OkHttp 无网数据缓存实现**

  ```java
  File cacheFile = new File(Constants.PATH_CACHE);
  Cache cache = new Cache(cacheFile, 1024 * 1024 * 50);
  Interceptor cacheInterceptor = chain -> {
      Request request = chain.request();
      if (!CommonUtils.isNetworkConnected()) {
          // 无网时强制使用数据缓存，以提升用户体验。
          request = request.newBuilder()
                  .cacheControl(CacheControl.FORCE_CACHE)
                  .build();
      }
      Response response = chain.proceed(request);
      if (CommonUtils.isNetworkConnected()) {
          int maxAge = 0;
          // 有网络时, 不缓存, 最大保存时长为0
          response.newBuilder()
                  .header("Cache-Control", "public, max-age=" + maxAge)
                  .removeHeader("Pragma")
                  .build();
      } else {
          // 无网络时，设置超时为4周
          int maxStale = 60 * 60 * 24 * 28;
          response.newBuilder()
                  .header("Cache-Control", "public, only-if-cached, max-stale=" + maxStale)
                  .removeHeader("Pragma")
                  .build();
      }
      return response;
  };
  // 缓存优化
  builder.addNetworkInterceptor(cacheInterceptor);
  builder.addInterceptor(cacheInterceptor);
  builder.cache(cache);
  ```

- **离线包、增量数据更新**

  加上版本的概念，仅传输有变化的数据。

- ##### 请求头压缩

  如果请求头不变，服务端可以使用映射缓存 请求头 MD5 : 请求头，之后请求头都是用 MD5 即可。

- **优化发送频率和时机**

- **合并网络请求、减少请求次数**

- **流量兜底能力**

  如果发现流量异常，我们可以通过后台服务器终止协议交互，以避免问题恶化。



#### 八、其他网络相关问题

##### 1、从输入网址到页面显示的过程

1. 输入网址
2. DNS解析
3. 建立tcp连接
4. 客户端发送HTPP请求
5. 服务器处理请求
6. 服务器响应请求
7. 浏览器展示HTML
8. 浏览器发送请求获取其他在HTML中的资源。

