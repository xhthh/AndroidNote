## 性能优化

### 内存优化

https://juejin.cn/post/6844904096541966350

#### 一、Android 内存管理机制

##### 1、Java 内存分配模型

- 程序计数器

  线程私有，当前线程所执行的字节码的行号指示器，存储当前线程执行目标方法执行到了第几行；

- 虚拟机栈

  线程私有，生命周期与线程相同。每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

  局部变量表存放了编译期可知的各种基本数据类型、对象引用和 returnAddress 类型。

- 本地方法栈

  和虚拟机栈类似，为虚拟机用到的 Native 方法服务；

- 堆

  线程共享，虚拟机所管理的内存中最大的一块，用于存放对象实例，几乎所有的对象实例都在堆中分配（逃逸分析，栈上分配），垃圾收集器管理的主要区域。

- 方法区

  线程共享，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

- 运行时常量池

  方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

##### 2、Java 内存回收算法

- **标记-清除算法**

  实现原理：

  - 标记出所有需要回收的对象
  - 统一回收所有被标记的对象

  特点：

  - 标记和清除效率不高
  - 产生大量不连续的内存碎片

- **复制算法**

  实现原理：

  - 将内存划分为大小相等的两块
  - 一块内存用完之后复制存活对象至另一块
  - 清理另一块内存

  特点：

  - 实现简单，运行高效
  - 浪费一半空间，代价大

- **标记-整理算法**

  实现原理：

  - 标记过程与 “标记-清除” 算法一样
  - 存活对象往一端进行移动
  - 清理其余内存

  特点：

  - 避免 “标记-清除” 算法导致的内存碎片
  - 避免复制算法的空间浪费

- **分代收集算法**

  - 结合多种算法的优势
  - 新生代对象存活率低，采用 “复制算法”（这里每一次的复制比例都是可以调整的，如一次仅复制30%的存活对象）
  - 老年代对象存活率高，采用 “标记-整理” 算法

> - Partial GC：并不收集整个GC堆的模式；
>   - Young GC：只收集 young gen 的 GC。
>   - Old GC：只收集 old gen 的 GC。只有 CMS 的 concurrent collection 是这个模式；
> - Full GC：收集整个堆，包括 young  gen、old gen、perm gen（如果存在的话）等所有部分的模式；
>
> Major GC 通常是跟 Full GC 是等价的，收集整个 GC 堆。
>
> Minor GC 等价于 Young GC 吧。
>
> 不过有的文章里说 Minor GC 发生在 Eden 区，Young GC 发生在 Eden、S0、S1 区。Major GC 发生在 old generation。



**Minor GC，Full GC 触发条件：**

- Minor GC 触发条件：当 Eden 区满时触发；
- Full GC 触发条件：
  - 调用 System.gc 时，系统建议执行 Full GC，但是不必然执行；
  - 老年代空间不足；
  - 方法区空间不足；
  - 通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存；
  - 当 Eden 区、From Survivor 区向 To Survivor 区复制时，对象大小大于 To Survivor 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。



#### 二、内存优化的意义

- 减少 OOM，提高应用稳定性；
- 减少卡顿，提高应用流畅性；
- 减少内存占用，提高应用后台运行时的存活率；
- 减少异常发生和代码逻辑隐患；



#### 三、避免内存泄漏

##### 1、内存泄漏的定义

GC 会选择一些还存活的对象作为内存遍历的根节点 GC Roots，通过对 GC Roots 的可达性来判断是否需要回收。**内存泄漏就是在当前应用周期内不再使用的对象被 GC Roots 引用，导致不能回收，使实际可用内存变小**。

**可以作为 GC Roots 的对象**：

GC 管理的主要区域是 Java 堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法栈不被 GC 所管理，因此选择这些区域内的对象作为 GC Roots，被 GC Roots 引用个对象不被 GC 回收。

- 虚拟机栈（栈帧中的本地变量表）中引用的对象；

  > 每个方法执行时，都会创建一个栈帧，栈帧中包含这个方法内部使用的所有对象的引用（这就是虚拟机栈中引用的对象）；
  >
  > 一旦该方法执行完后，该栈帧就会从虚拟机栈中弹出，这些局部（临时）对象的引用也就不存在了，或者说没有任何 GC Root 指向这些临时对象，所以这些对象在下一次 gc 时就会被回收掉。

- 方法区中静态属性引用的对象（一般指被static修饰的对象，加载类的时候就加载到内存中）；

  > 因为该对象是类的全局属性，所以会存在于方法区中，每个线程共享，可以作为 GC Root 对象。
  >
  > 比如单例模式的懒汉式和饿汉式的写法：
  >
  > - ```java
  >   private static User user = new User();//懒汉式
  >   ```
  >
  > - ```java
  >   private static User user;//饿汉式
  >   ```
  >
  > Java 8 后静态变量存储的地方改为堆。

- 方法区中常量引用的对象；

  > 是否是静态常量？

- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象；



**各种变量存储的位置：**

> 静态变量：位于方法区。
>
> 实例变量：作为对象的一部分，保存在堆中。
>
> 临时变量：保存于栈中，栈随线程的创建而被分配。
>
> 栈内存中存放局部变量（基本数据类型和对象引用)，而堆内存用于存放对象（实体）
>
> 对于字符串而言，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中；如果是运行期（new出来的）才能确定的就存储在堆中。
>
> 对于 `equals` 相等的字符串，在常量池中永远只有一份，在堆中可以有多份。
>
> 
>
> jdk 1.8 之后
>
> 以前的永久代是用来保存类的信息的，然后 Java8 将其一分为二，一部分是元空间，另一部分放到堆中。
>
> 元空间存储的是类的元信息，堆里面存储了静态变量和常量。





##### 2、查找内存泄漏

- shell 命令 + LeakCanary + MAT
- Profile Memory



> 使用 Android Studio  profiler 时 App 崩溃
>
> 设备：荣耀V20
>
> Android版本：Android 10
>
> 解决方案：Android Studio 右下角 Device File Explorer，删除 data/local/tmp/perfd 文件夹（未测试），但是貌似不能 dump



##### 3、常见内存泄漏场景

- 资源性对象未关闭

- 注册对象未注销

- 类的静态变量持有大数据对象

- 单例造成的内存泄漏

- 非静态内部类的静态实例

- Handler 内存泄漏

  未处理的消息 Message，持有 Handler 的引用，如果是非静态内部类，将持有外部类 Activity 的引用，导致 Activity 退出时无法被回收。

  - 使用静态 Handler 内部类，对 Handler 持有的对象（一般为 Activity）使用弱引用；
  - 在 Activity 的 onDestroy() 中移除未处理的消息；

- 容器中的对象没清理造成的内存泄漏

  在退出程序之前，将集合里的数据 clear，然后置为 null，再退出程序。

- WebView 内存泄漏

  在应用中只要使用一次 WebView，内存就不会被释放掉。可以为 WebView 开启一个独立的进程，使用 AIDL 与应用的主进程进行通信，WebView 所在的进程可以根据业务的需要选择合适的时机进行销毁，达到正常释放内存的目的。

- 使用 ListView 时造成的内存泄漏

  在构造 adapter 时，使用缓存 convertView



##### 4、内存泄漏监控

LeakCanary

> 弱引用和引用队列
>
> LeakCanary 监听 Activity、Fragment 的生命周期，在 onDestroy() 之后，将其放入到一个弱引用中，并关联引用队列。如果实例进行了回收，那么弱引用就会放入到引用队列当中，并将已经回收的对象从 `watchedObjects` 集合中删除，然后剩下的就是没有被回收，发生内存泄漏的。如果一段时间后，所监控的实例还未在引用队列中出现，则证明出现了内存泄漏导致了实例没有被回收，然后执行 `dump` 指令分析内存。



#### 四、优化内存空间

##### 1、对象引用

- 强引用
- 软引用
- 弱引用
- 虚引用

##### 2、减少不必要的内存开销

- 自动装箱

  > 自动装箱是把基础数据类型转换成对应的复杂类型。在自动装箱转化时，都会产生一个新的对象，这样就会产生更多的内存和性能开销。比如 HashMap 这类容器进行增删改查操作时，都会产生大量的自动装箱操作。

  检测方式：

  使用 TraceView 查看耗时，如果发现调用了大量的 integer.value()，就说明发生了自动装箱。

- 内存复用

  - 资源复用

    通用的字符串、颜色定义、简单页面布局的复用；

  - 视图复用

    可以使用 ViewHolder 实现 ConvertView 复用；

  - 对象池

    显示创建对象池，实现复用逻辑，对相同的类型数据使用同一块内存空间；

  - Bitmap 对象的复用

    使用 inBitmap 属性可以告知 Bitmap 解码器尝试使用已经存在的内存区域，新解码的 bitmap 会尝试使用之前那张 bitmap 在 heap 中占据的 pixel data 内存区域；

##### 3、使用最优的数据类型

1. **HashMap 和 ArrayMap、SparseArray**

   - HashMap

     - HashMap 数组+链表（红黑树）的结构，插入对象时散列冲突的问题；

     - 查询低效？

     - 扩容机制，初始 16 的数组，size > 容量*加载因子时，扩大为原来的2倍，数据很大的扩容，浪费内存

     - HashMap 插入基础数据类型时，自动装箱，key 和 value 都是 Object 类型，比如：

       ```java
       private HashMap<String, Integer> map = new HashMap();
       private void test() {
           map.put("age",18);//自动装箱，int -> Integer
       }
       ```

   - SparseArray

     > 内部通过两个数组来存储数据，一个存key，一个存value，且只能存储key类型为 int 的数据，在存储和读取数据时，采用了二分查找。
     >
     > 在某些条件下性能比 HashMap 更好，主要是它避免了对 key 的自动装箱。

     应用场景：

     - 数据量不大，最好在千级以内；
     - key 必须为 int 类型；

   - ArrayMap

     > 内部使用2个数组进行存储，一个存储 key 的 hash 值，一个存储 value 值，它和 SparseArray 一样，也会对 key 使用二分查找进行从小到大排序，在添加、删除、查找数据的时候都是先使用二分查找得到相应的 index，然后通过 index 来进行添加、查找、删除等操作，所以使用场景和 SparseArray 类似。
     >
     > 1、如果key的类型已经确定为int类型，那么使用SparseArray，因为它避免了自动装箱的过程，如果key为long类型，它还提供了一个LongSparseArray来确保key为long类型时的使用
     >
     > 2、如果key类型为其它的类型，则使用ArrayMap

2. **使用 IntDef 和 StringDef 替代枚举类型**

   > 枚举最大的优点是类型安全，但在Android平台上，枚举的内存开销是直接定义常量的三倍以上。所以Android提供了注解的方式检查类型安全。目前提供了int型和String型两种注解方式：IntDef和StringDef，用来提供编译期的类型检查。

3. **LruCache**

4. **图片内存优化**

   - 图片规格
   - inSampleSize，位图的缩放功能，通过 BitmapFactory.options 设置
   - inScaled、inDensity 和 inTargetDensity 实现更细的缩放功能

5. **inBitmap**

6. **图片放置优化**

   > 只需要UI提供一套高分辨率的图，图片建议放在drawable-xxhdpi文件夹下，这样在低分辨率设备中图片的大小只是压缩，不会存在内存增大的情况。如若遇到不需缩放的文件，放在drawable-nodpi文件夹下。

7. **在 App 可用内存过低时主动释放内存**

   > 在 App 退到后台内存紧张即将被 Kill 掉时选择重写 onTrimMemory/onLowMemory 方法释放掉图片缓存、静态缓存来自保。

8. **item 被回收不可见时释放掉对图片的引用**

   - ListView
   - RecyclerView

9. **避免创建不必要的对象**

   > 比如字符串拼接时使用 StringBuilder、StringBuffer等

10. **自定义 View 中的内存优化**

    > 在 onDraw() 中不要执行对象的创建，一般都在自定义View的构造器中创建。

11. **其它的内存优化注意事项**

    - 尽使用static final 优化成员变量。
    - 使用增强型for循环语法。
    - 在没有特殊原因的情况下，尽量使用基本数据类型来代替封装数据类型，int比Integer要更加有效，其它数据类型也是一样。
    - 在合适的时候适当采用软引用和弱引用。
    - 采用内存缓存和磁盘缓存。
    - 尽量采用静态内部类，可避免潜在由于内部类导致的内存泄漏。



