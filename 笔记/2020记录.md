滴滴

1. 沉浸式标题栏，上滑背景渐变怎样实现？
2. 动态换肤怎样实现？
3. RecyclerView+ScrollView 为什么会滑动冲突？
4. 动画
5. webview + 原生评论为什么会卡？
6. activity 栈
7. Binder 速度为什么快？Messenger怎样实现同步？
8. RN 和 Flutter 区别？



1. synchronized 修饰静态方法和普通方法的区别
2. RN 和 H5 的区别
3. RN 实现原理
4. 加密
5. 三种图片加载框架对比
6. 防止参数被抓包



探探

1. 泛型

2. 多态

3. 内存泄漏

4. 软引用的使用

5. HashMap#put() 时间复杂度

6. 怎样限制三方库的大小

7. 原子性

8. MVC、MVP、MVVM

9. **http 报文**

   https://blog.csdn.net/yutiab69/article/details/82869239

   - 请求报文
     - 请求行
     - 请求头
       - Accept，接收的数据类型。
       - Accept-Language，接收的语言。
       - Accept-Encoding，客户端的编码方式。
       - Connection，长连接还是短链接。
       - Host，客户端的主机和端口号。
       - Referer，请求来源网站。
       - User-Agent，客户端的系统和浏览器的信息。
       - Cache-Control，缓存设置（重点）。
       - Cookie，存储用户信息。Range，获取的数据部分。
     - 空行
     - 请求体
   - 响应报文
     - 状态行
     - 响应头
     - 空行
     - 响应体

10. service 生命周期

11. onSaveInstance() 什么时候被调用

12. RecyclerView 和 ListView 的区别

13. ConstraintLayout 和 RelativeLayout 区别

14. MVP 减少接口的方法

15. 优化网络请求

16. **SSL 加密过程**
    SSL：安全套接字协议，TLS：安全传输层协议

    - 认证服务器

      一些主流浏览器会内置一个受信任的CA机构（如[GeoTrust](https://www.idcspy.com/geotrust.html)、[Comodo](https://www.idcspy.com/comodo.html)、[GlobalSign](https://www.idcspy.com/globalsign.html)等）列表，并会保存相关CA机构的[SSL证书](https://www.anxinssl.com/)。当用户在访问部署了SSL证书的网站时，服务器会提供经CA机构颁发的SSL证书，如果认证该服务器证书的CA机构是存在于浏览器的受信任CA机构列表当中，并且该SSL证书中的所有信息均与当前证在访问的网站所有信息一致，那么浏览器就会认为服务端是可信的，并从[SSL证书](https://www.anxinssl.com/)中取得公钥（也就是CSR文件），用于后面的流程，这是SSL加密的第一步。

    - 协商会话秘钥

      在服务器认证完获取公钥之后，SSL加密利用公钥与服务器进行加密通信，协商出两个会话秘钥，用于加密客户端和加密服务端互发数据时的会话秘钥。这个秘钥是随机生成的，每一次协商产生的结果都不一样，所以安全性也是比较高的。

    - 加密传输

      当客户端和服务器端都拥有了协商的会话密钥之后，进行数据传输时，都是以密文的方式进行传输。这样的传输方式，保证了数据的私密性和完整性，再也不用担心数据在传输过程中被第三者窃取和篡改了。

    ![img](https://img-blog.csdnimg.cn/img_convert/a9c9d8365611d09adf3b893d98537f1f.png)

17. **https和http区别**

    - HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
    - 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
    - HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
    - http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
    - HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

18. 进程间通信的方式



1. Retrofit 解析数据

2. Fragment 之间传递数据

3. Jetpack

4. 打包

5. DNS解析

6. ViewGroup onDraw() 会执行吗

   ViewGroup 没有实现 onDraw()，由各个实现类如 LinearLayout 来实现



1. **okhttp 连接池**

   - 连接池是为了解决频繁的进行建立Sokcet连接（TCP三次握手）和断开Socket（TCP四次分手）。
   - Okhttp的连接池支持最大5个链路的keep-alive连接，并且默认keep-alive的时间是5分钟。
   - 连接池实现的类是RealConnectionPool，它负责存储与清除的工作，存储是通过ArrayDeque的双端队列存储，删除交给了线程池处理cleanupRunnable的任务。
   - 在每次创建RealConnection或从连接池中拿一次RealConnection会给RealConnection的 transmitters 集合添加一个弱引用的transmitter对象，添加它主要是为了后面判断该连接是否在使用中

   - 在连接池中找连接的时候会对比连接池中相同host的连接。
   - 如果在连接池中找不到连接的话，会创建连接，创建完后会存储到连接池中。
   - 在把连接放入连接池中时，会把清除操作的任务放入到线程池中执行，删除任务中会判断当前连接有没有在使用中，有没有正在使用通过RealConnection的transmitters集合的size是否为0来判断，如果不在使用中，找出空闲时间最长的连接，如果空闲时间最长的连接超过了keep-alive默认的5分钟或者空闲的连接数超过了最大的keep-alive连接数5个的话，会把存活时间最长的连接从连接池中删除。保证keep-alive的最大空闲时间和最大的连接数。

2. **网络层**

   - 应用层

     应用层决定了向用户提供应用服务时通信的活动；

     - HTTP
     - FTP

   - 传输层

     传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输；

     - TCP（Transmission Control Protocol，传输控制协议）

       是一种面向连接的、可靠的、基于字节流的传输层通信协议。

     - UDP（User Data Protocol，用户数据报协议）

       是一种面向无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。

   - 网络层

     网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据传送给对方。

   - 链路层

     用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡，及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。

3. **SSL**

   SSL(Secure Sockets Layer 安全套接层协议),及其继任者[传输层安全](https://baike.baidu.com/item/传输层安全)（Transport Layer Security，TLS）是为[网络通信](https://baike.baidu.com/item/网络通信/9636548)提供安全及[数据完整性](https://baike.baidu.com/item/数据完整性/110071)的一种安全协议。TLS与SSL在[传输层](https://baike.baidu.com/item/传输层/4329536)与[应用层](https://baike.baidu.com/item/应用层/16412033)之间对网络连接进行加密。

4. **https 加密算法**

   - 对称加密
     - DES
     - AES
   - 非对称加密
     - RSA
   - 混合加密
     - AES + RSA

5. **TCP 连接状态**

   ![img](https://img-blog.csdnimg.cn/2020120210533216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3bDE1ODQ2NzE0MTM=,size_16,color_FFFFFF,t_70)

   各种状态的解释

   LISTEN：侦听来自远方TCP端口的连接请求

   SYN-SENT：发送连接请求后等待匹配的连接请求

   SYN-RECEIVED（syn已经收到的）：收到和发送给一个连接请求后等待对连接请求的确认

   ESTABLISHED(已建立的)：代表一个打开的连接，数据可以传送给客户

   FIN-WAIT-1：等待远程TCP的连接中断请求，或者先前的连接中断请求的确认

   FIN-WAIT-2：从远程TCP等待连接中断请求

   CLOSE-WAIT：等待从本地用户发来的连接中断请求

   CLOSEING：等待远程TCP对连接中断的确认

   LAST-ACK：等待原来发向远程TCP的连接中断请求的确认

   TIME-WAIT：等待足够的时间一确保远程TCP接受到连接中断请求的确认

   CLOSED：没有任何连接状态

6. **多线程实现方式**

7. **线程创建消耗哪些资源**

8. **合并两个有序链表**



1. 性能优化

2. 设计模式

3. webview js

4. 自定义 View

5. 过度绘制

6. application 上下文能启动 dialog 吗

7. ViewStub

8. 资源混淆

9. 图片加载

10. volatile

11. 反射

12. dialog window 类型

13. EventBus

14. 卡顿

15. Fragment 创建为什么用 setArguments()

    防止横竖屏切换重新创建



1. startActivity 是同步还是异步
2. AMS 发消息是异步的吗
3. 资源 R 文件混淆，怎么不乱
4. 单例模式
5. 链表环、切点、环长
6. 快速排序



1. 堆和栈存放了哪些文件
2. class 文件存在哪儿
3. class 文件组成
4. apk 文件组成
5. 方法区
6. 静态内部类、匿名内部类
7. k个一组反转字符串



1. 方法参数中的 final 起什么作用
2. GC 什么时候会发生？system.gc 会直接发生吗？
3. RN 的原理
4. 内存相关
5. 哪些可以作为 GC root
6. HashMap 和 ArrayMap



美团

1. NestedScrollView 嵌套滑动机制
2. RN
3. HashMap 为什么是 2^n，链表多长变为红黑树
4. Java 包权限
5. ConcurrentHashMap 什么情况下会阻塞





腾讯

1. **输入网址到页面显示的过程**

   - 输入网址，按下回车；

   - DNS域名解析，查找对应服务器的IP地址；

   - TCP 三次握手建立连接；

   - 浏览器给web服务器发送一个HTTP请求；

     - 服务器永久重定向响应；

       服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“http://www.facebook.com/” 而非“http://facebook.com/”

     - 访问重定向地址，发送另一个请求；

   - 服务器处理请求，返回响应；

   - 浏览器解析 HTML，进行页面渲染；

   - 释放连接；

2. 反射效率低的原因？怎么优化

3. Class 文件组成部分

4. message 同步、异步消息，消息屏障

5. recyclerview 复用机制？满屏5个，共20个，onCreateViewHolder() 会执行多少次？

   先复用，再缓存，cacheViews 大小为 2，recyclerPool 大小为 5，cacheViews 只能用于同位置的item复用

6. http 与 https 区别



墨迹天气

1. **okhttp缓存策略**

   CacheInterceptor 负责读取缓存以及更新缓存的。它内部的实现是使用的OKIO是进行读取和写入的。

   1. 读取候选缓存，
   2. 创建缓存策略，强制缓存、对比缓存等
   3. 根据策略，不使用网络，又没有缓存的直接报错，并返回错误码504。
   4. 根据策略，不使用网络，有缓存的直接返回。
   5. 前面两个都没有返回，继续执行下一个Interceptor，即ConnectInterceptor。
   6. 接收到网络结果，如果响应code式304，则使用缓存，返回缓存结果。
   7. 读取网络结果。
   8. 对数据进行缓存。
   9. 返回网络读取的结果。

2. **okhttp超时时间**

   - internal var callTimeout = 0

     - 总超时时间
     - 从发起到结束的总时长。其中不包括 UnknownHostException 情况

   - internal var connectTimeout = 10_000

     - 连接超时时间

     - 三次握手 + SSL建立耗时

       超时时间：默认10s

   - internal var readTimeout = 10_000

     - 读取超时时间
     - 连接建立后，从远端获取数据。TCP 传输

   - internal var writeTimeout = 10_000

     - 写入超时时间
     - 连接建立后，向远端发送数据。TCP 传输

3. 怎样封装 okhttp

4. **okhttp 取消请求**

   - OkHttp 取消请求

     - 可以通过对request的处理，设置tag，传入当前activity
     - 然后在页面销毁时，进行取消请求
     - 然后通过Dispatcher获取正在执行和等待执行的请求队列，如果tag相符，则call.cancel()

   - Retrofit 取消请求

     - 因为 Retrofit 并没有提供可以直接发访问 Call 的方法，所以需要通过自定义 header 和自定义拦截器来处理。

     - 给每个与页面（Activity，Fragment）相关的request加入自定义header，[参考](https://links.jianshu.com/go?to=https%3A%2F%2Fpublicobject.com%2F2016%2F01%2F17%2Fsneaking-data-into-an-okhttp-interceptor%2F)。
        给OkHttpClient添加拦截器。标记出页面的生存状态。如果页面销毁了，则取消对应的request。



APUS

1. 静态内部类和内部类的区别
2. sleep 和 wait、sleep 怎样不放弃时间片
3. 子线程能更新UI吗
4. 子线程能弹toast吗



去哪儿网

1. app启动流程
2. recyclerView 复用机制
3. MVP model层异步请求一个数据，怎样更新到 View
4. android sdk 中 MVC 模式的体现



融360

1. 合并两个有序链表

2. 网络请求加密

3. listview 优化

4. inflate 布局优化方案

5. 反射

6. 泛型作用

7. **TCP三次握手、四次挥手**

   三次握手：

   - 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
   - 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
   - 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

   > 为什么是三次？
   >
   > 为了防止已经失效的连接请求报文突然又传送到服务端，因而产生错误。减小因延迟高拥塞大对报文传输的影响。

   四次挥手

   - 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。
   - 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
   - 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
   - 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

   > 为什么连接的时候是三次握手，关闭的时候却是四次握手？
   >
   > 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
   > 原文链接：https://blog.csdn.net/qq_38950316/article/details/81087809

8. 注解

9. ImageView 怎样显示到屏幕



1. 选择排序

2. jsbridge 协议怎样定义，数据格式

3. 网络优化

4. okhttp 一个请求分几个过程

   - 构建 OkHttpClient 配置参数；

   - 构建 Request 配置请求参数；

   - 异步或同步执行；

   - Dispatcher 进行分发处理；

   - 各个拦截器

     - interceptors

       自定义拦截器，比如自定义日志拦截器、添加header等

     - RetryAndFollowUpInterceptor

       重试与重定向拦截器，

     - BridgeInterceptor

       桥接，负责把应用请求转换成网络请求，把网络响应转换成应用响应，就是添加各种响应头信息的。负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应。 在Request阶段配置用户信息，并添加一些请求头。在Response阶段，进行gzip解压。

     - CacheInterceptor

       用来负责读取缓存以及更新缓存的。它内部的实现是使用的OKIO是进行读取和写入的。

     - ConnectInterceptor

       主要功能是复用连接池里面的连接，创建新的连接，并把读写数据流的对象交由下一个拦截器处理。

     - networkInterceptors

     - CallServerInterceptor

       写入http的请求，读取响应的head和body



1. GC
2. 对象间引用关系



健客网

1. handler 延迟消息原理

2. 发送一个延迟10秒的，再发送一个延迟5秒的，怎么做到先处理5秒的？

   管道机制

3. 插件化，宿主怎样和插件通信

4. 双亲委派，为什么采用这种机制

   安全性、唯一性，先用父类加载器加载，一直往上查，都没有再用自身加载

   防止重写一个系统的类，加载进去

5. **为什么要序列化，两种序列化的区别**

   > 在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象。
   >
   > ```
   > 序列化就是将对象的状态信息转换为可以存储或传输的形式的过程。
   > 序列化的原因：
   > ①永久性保存对象，保存对象的字节序列到本地文件中。
   > ②对象在网络中传递。
   > ③对象在IPC间传递。
   > ```

   

   > Serializable的作用是保存对象的属性到本地文件，数据库，网络流等方便数据传输，也可程序之间传递。
   >
   > parcelable的设计的目的是为了解决Serializable效率不高的问题，内存开销小，所以在内存间传递数据的方式用parcelable，缺点是不能持久化。

   ```xml
   两种序列化方式的选择：
   一般在保存数据到 SD 卡或者网络传输时建议使用 Serializable 即可，虽然效率差一些，好在使用方便。
   而在运行时数据传递时建议使用 Parcelable，比如 Intent，Bundle 等，Android 底层做了优化处理，效率很高。
   
   1.在使用内存的时候Parcelable比Serializable的性能高。
   2.Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC（内存回收）。
   3.Parcelable不能使用在将对象存储在磁盘上这种情况，因为在外界的变化下Parcelable不能很好的保证数据的持续性。
   
   一个是Java API 一个是Android API
   一个效率低     一个效率高
   ```

6. getWidth() 和 getMeasuredWidth() 区别？ScrollView 两种获取到的高度相同吗

   - getWidth() 和 getMeasuredWidth() 一般情况下都是相等的
     - getMeasuredWidth方法获得的值是setMeasuredDimension方法设置的值，它的值在measure方法运行后就会确定
     - getWidth方法获得是layout方法中传递的四个参数中的mRight-mLeft，它的值是在layout方法运行后确定的
     - 一般情况下在onLayout方法中使用getMeasuredWidth方法，而在除onLayout方法之外的地方用getWidth方法。
     - 除非手动在layout() 方法中设置值，否则一般情况下两者相等，只是赋值时机不同；
   - ScrollView getHeight() 和 getMeasuredHeight() 相同，都是屏幕高度

7. **为什么启动一个 activity 要用 intent 传值**

   > 一个Activity启动另一个Activity时，并没有startActivity(Class activityClass)这样看起来似乎更简单、更直接的方法， 而是采用Intent"意图"来表达需要启动哪一个Activity，细想之下你会发现是有很多原因的：
   > 1.“Intent提供了一种统一的编程模型”：不管是要启动一个Activity、要启动一个Service、还是要启动一个BroadcastReceiver，Android提供了统一的Intent对象来封装这种"启动意图"，这与Android本身的理念是相一致的；
   > 2.“Intent方式降低了组件耦合”：有些时候，我们只是想启动某个组件，并不想和这个组件产生耦合，如果采用startActivity(Class activityClass)方式势必会造成一种硬编码耦合，同时也就会不利于解耦；从而也提高了系统的可扩展性、可维护性；
   > 3.“Intent是组件之间通信的重要媒介”：两个Activity之间可以把要交换的数据封装在成Bundle对象，使用Intent携带Bundle对象实现Activity之间的数据交换；



猫眼

1. **recyclerView 复用机制**

2. **说几个线程池**

3. **线程池怎样保证线程安全**

4. **okhttp 责任链怎么实现**

   责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。

   

5. **threadlocal 怎么实现**

6. **ViewPager 懒加载**

7. **MVP 和 MVC 区别，MVP 有什么问题**

8. **设计模式的好处**

9. **ViewPager 三个 Fragment的生命周期**

   默认预加载一个，一进入页面，第一、二个 fragment 都走到 onResume() 第三个不走，当走到第二个的时候，第三个从 onAttach 到 onResume，滑动到第三个时，第一个 onDestroyView



网易

1. RxJava 和 Retrofit 怎么结合

   通过 addCallAdapterFactory() 设置 RxJava2CallAdapterFactory，在调用接口方法时，走动态代理的 invoke() 方法，其中会解析接口方法的返回类型 Observable，注解、方法参数等信息，将 okhttp 请求到的数据转换成 RxJava Observable

2. 线程池有什么限制吗

3. 滑动冲突怎么处理

4. nestedScrollView 怎么处理嵌套 RecyclerView

   子View的测量模式由layoutparams 和 父类的测量模式共同决定，NestedScrollView 传给 RV 的测量模式为 UNSPECIFIED，RV 会不限制自身的高度，即 RV 的窗口高度将会变成所有 item 高度累加后加上 padding 的高度。因此表现出来就是 item 一次性全部加载完成。

5. handler怎么处理延迟消息，时间未到怎么办？时间到了怎么办

6. MVP 有什么问题

7. 四种垃圾回收算法

8. Java 值传递

9. 合并两个有序数组

10. 父 View onInterceptTouchEvent() return  false 后，还会交给父 View 吗

11. 滑动冲突，同向，开始由子view处理滑动，后边想让父View处理滑动，怎么办



小熊博望

1. 静态内部类单例模式怎样保证线程安全

   由 JVM 类加载机制保证，同一个类在加载过程中只能由一个线程去执行这个类的 `<clinit>（）` 方法，其他线程都需要阻塞等待

2. 单向链表给一个头结点，找到中间结点

3. **okhttp 复用，如果已经有这个请求，还会创建新的请求吗**

   连接复用由 ConnectInterceptor 实现，代码依次执行 realChain.call.initExchange --->exchangeFinder.find() ---> findHealthyConnection() ---> findConnection()

   第一步会先判断是否存在可复用的连接，如果有则直接用，如果没有则去连接池里面获取，如果连接池里面没有获取到，则最后才会去创建一个新的连接，并添加到连接池中。

4. 双重锁单例模式，内层判断的意义？如果没有怎么办？

   外层判断，防止无用的同步，浪费资源

   内层判断，作用就是保证单例，只能创建一个对象，没有的话，两个线程都进入sync，一个持有锁，一个等待，等第一个创建完对象，第二个进入锁，没有判断，会重新创建新的对象

5. handler 没有消息会怎样？nativePollonce 每次都会执行吗？怎么唤醒？

6. 如果只采用某种类型 so 库，其它架构的手机会怎样？

7. ReentryLock 和 synchronized 区别

8. okhttp 缓存

9. 事件分发从哪儿开始

10. 自定义 ViewGroup 将传入的 ImageView 最终裁成圆形，需要重写哪些方法

    - 重写 onLayout() 摆放布局
    - 重写 onDraw() 使用 canvas.clipPath()

11. 如何让 viewgroup 和 子 View 都处理事件

12. hashmap 什么时候会冲突



西山居

1. **okhttp源码分为哪几个模块，分别负责什么**

   https://blog.csdn.net/Android_LeeJiaLun/article/details/108326132

   ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTg2MzI0OC1lNzIyNzc5ZTE1MmVmYWI5LnBuZw?x-oss-process=image/format,png)

   - **Interface 接口层**

     主要负责网络请求，用户的网络[框架](https://so.csdn.net/so/search?q=框架&spm=1001.2101.3001.7020)的各种设置也是通过okhttpclient设置的！而整个Application中，应该共享一个okhttpclient 实例。

     - Call
     - RealCall
     - AsyncCall
     - Dispatcher

   - **Protocal 协议层**

     Protocol层负责处理协议逻辑，**OkHttp**支持**Http1、Http2、WebSocket**协议。

     - **Http2 区别于Http1**：
       - Http2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
       - Http2支持多路复用。
       - Http2头部压缩。
       - Http2支持在客户端未经请求许可的情况下，主动向客户端推送内容。

   - **Connection 连接层**

     - RealConnection

   - **Cache-缓存层**

   - **IO 层**

   - **Interceptor 拦截器层**

2. 为什么用 handler

3. 一个点击事件走哪些方法

4. hashmap 的 hash 算法

   ```java
   static final int hash(Object key) {
   	int h;
   	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
   }
   ```

   为了散列更均匀

5. 搭建一个框架需要注意什么

6. hashmap 的优势

   查询速度快 O(1)，动态可变长存储数据

7. **okhttp 有哪些优势**

   - 内置连接池，支持连接复用；
   - 支持gzip压缩响应体；
   - 通过缓存避免重复的请求；
   - 支持http2，对一台机器的所有请求共享同一个[socket](https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020)。

8. okhttp 缓存

9. 事件分发，点击一个 button 滑动到另一个 button 再滑出屏幕

   只会走第一个 button 的事件

10. 多个handler 同时发送消息，怎么处理

11. 数据库版本升级



金山

1. androidx
2. https 和 http 区别
3. 防止抓包 加签加密的方式
4. 非对称加密
5. webview 需要注意的安全问题
6. view的绘制流程
7. draw 先绘制哪些
8. view.post
9. android 版本适配
10. 两个 classLoader 的区别
11. RxJava 是怎样切换线程的
12. retrofit 是怎样切换线程的
13. 反射中的方法，都有哪些作用



搜狐

1. 三个线程同时启动，执行完后再执行一个线程？

2. webview 和 js 交互

3. cancel 事件什么情况下会发生

4. 点再 button 上，onTouchEvent() 的 down 事件返回 true，viewgroup 还能拦截 move 和 up 事件吗

5. tinker 缺陷，第三方 aar 能修复吗

6. **intent 有什么限制**

   > 数据传递大小限制 1024KB
   >
   > 可传递数据类型：
   >
   > - Intent传递基本数据和基本数据数组
   > - Intent传递Parcelable对象
   > - Intent传递Serializable对象
   > - Intent传递String,Integer,CharSequence泛型集合
   > - Intent传递基本自定义对象集合
   >
   > 通过 bundle 来传递

7. activity 与 service 怎样交互

8. activity 的启动

9. 本地广播



易车

1. 数组查找为什么快

2. http1 和 http2 的区别

3. 哈希算法

4. **okhttp 异步请求，等待队列什么时候加入到正在执行的队列**

   取出等待队列中的 call，判断正在执行的 call 数量是否大于最大数 64，且每个 host 上 call 的数量是否大于 5，通过的话，即将待请求的 call 加入到 runningAsyncCalls 里，同时加入到 executableCalls，最后遍历 executableCalls，进行执行；

   执行 runningAsyncCalls.add(asyncCall) 的方法总过被四处调用：

   - enqueue() 异步请求
   - finished() 请求结束
   - maxRequests set方法
   - maxRequestsPerHost set 方法

5. 图片压缩在边以前还是编译后

6. 二分查找

7. 路由

8. 轻量级锁、重量级锁

9. wait notify 在重入锁中对应哪些方法

   newCondition()

10. **okhttp线程池最大数量**

    Int.MAX_VALUE，cacheThreadPool 类型，无核心线程，最大线程数不限，60秒超时

11. 真正执行网络请求的是哪个拦截器

    callServerInterceptor

12. CAS



映客直播

1. **dialog 和 window**

   - Dialog 持有 Window，视图是通过 Window 呈现的，在 Dialog 的构造函数中 创建了 PhoneWindow 对象；
   - Dialog 设置布局是通过 mWindow#setContentView() 来实现的；
   - 在 Dialog 的 show() 方法中，通过 mWindow 后去 DecorView，然后调用 mWindowManager#addView(mDecor, layoutParams) 进行视图的添加；

   > 普通 Dialog 的创建需要传入 Activity 类型的上下文，Application 或 Service 类型的 context 会报错；这样做的好处是防止当你已经关闭页面了，或者已经打开其他app了，这个时候弹出一个操作弹窗，防止误操作。
   >
   > 有个 token 验证问题

2. Java 虚拟机栈中存的是什么

3. JPG 和 png 的区别

4. OOM 发生在哪里

5. requestlayout() 和 invalidate() 的区别

6. Bitmap 存在哪儿

   3.0~8.0之前存在Java 堆中，8.0之后存在 native 堆中

7. 哪些对象可以作为 GC root

8. okhttp 连接复用

9. 多线程、volatile

10. LayoutInflater.inflate() 中 attachToRoot 的作用













美图

1. **calladapter 怎样将 call 转换成 observable**

   - 首先这是通过 Retrofit 适配器模式完成的；
   - 在构建 Retrofit 对象时，可以通过 Builder 的方法 addCallAdapterFactory 添加适配器；
   - 在调用 ApiService 接口中的方法时，由于动态代理会走到 Retrofit#create() 的 invoke() 回调中；
   - loadServiceMethod(method) 会对接口中定义的方法进行解析，注解、参数、返回值类型，这里 返回值类型是 Observable；
   - 取得返回值类型后，会通过 createCallAdapter() 创建 CallAdapter 实例，这里调用的是 Retrofit 中的方法，通过找到之前设置 RxJavaCallAdapterFactory 实例，调用其 get() 方法，创建 RxJava2CallAdapter 实例；
   - 得到 callAdapter 实例后，在 Retrofit#create()#invoke() 中，调用 loadServiceMethod.invoke()；
   - HttpServiceMethod#invoke() 中会先构建一个 OkHttpCall，然后调用 adapt() 方法，即适配器模式，会调用 callAdapter 的 adapt() 方法；
   - 在 RxJava2CallAdapter#adapt() 中会将 Call 转换成 Observable 类型；

2. **hashmap 放5个数据，初始值设置多少合适**

   initialCapacity = (需要存储的元素个数 / 负载因子) + 1，负载因子 0.75

   且应该为 2 的 n 次幂

3. **ConcurrentHashMap 怎样实现线程安全的**

   - JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。

   - JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结

     点）（实现 Map.Entry）。锁粒度降低了。

4. **播放器，电话进来，怎样停止播放，怎样监听**

   - 播放一般会启动一个 Service，在 Service 的 onCreate() 中通过 TelephonyManager 设置 listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);
   - 在 mPhoneStateListener  的回调中，根据不同状态进行暂停、恢复；
   - 在 Service 的 onDestroy() 中删除、释放；

5. **TextView 怎样对 Drawable 进行缩放动画，比如分享文字和分享图标，让图标缩放**

   - 使用属性动画，对某个属性进行操作；
   - 先获取一个 drawable，然后 setCompoundDrawables() 设置给 TextView；
   - 然后属性动画对这个 drawable 进行操作；

6. **自定义View 怎样绘制，设置圆角**

   https://blog.csdn.net/f409031mn/article/details/87211850

   - canvas.clipPath()，canvas.drawBitmap()
   - PorterDuffXfermode 使用图像混合模式，设置画笔，canvas.drawBitmap()
   - BitmapShader 设置画笔，canvas.drawCircle()

7. **fragment 回退栈，怎样监听返回**

   https://blog.csdn.net/harvic880925/article/details/45013501#

   - 在 Fragment 中定义 onBackPressed() 方法，处理逻辑，返回 true or  false；
   - 定义接口，声明一个方法 setSelectedFragment()，将 Fragment 的实例传入；
   - 让 Activity 实现接口，重写方法，接收 Fragment 的实例；
   - 在 Fragment 的 onAttach() 及其之后的生命周期中将 getActivity() 转换成接口类型，并调用 setSelectedFragment(this) 将自己传出去；
   - 在 Activity 的 onBackPressed() 中处理逻辑；







玩吧

1. **ThreadLocalMap 结构，怎样存储 Looper 的？**

   - ThreadLocalMap 是线程内部的数据存储类，在指定线程中存储的数据，只能在指定线程中获取；
   - 有个内部类，ThreadLocalMap，主体结构是 Entry 数组，在 ThreadLocalMap 构造函数中初始化，初始长度为 16，扩容是扩大为原来的 2 倍；
   - set() 方法，先获取当前线程 thread 对象，Thread 中有一个属性 threadLocals，即 ThreadLocalMap；获取 threadLocalMap 对象，为空就创建，然后将 value 存到 map 中，key 为 this，即使 ThreadLocal 本身；

2. **synchronized 和 Lock 的区别？效率问题？**

3. **lock 的使用场景**

4. **自定义 View 的流程**

5. **onSizeChanged 什么情况下会调用**

   当视图大小发生变化的时候会调用，具体看源码是在layout的过程当中出发的，在layout方法中会调用setFrame方法，在setFrame方法中又调用了sizeChange，在该方法里面回调了onSizeChanged，而后才回去回调onLayout过程。

6. **hashmap 怎样通过哈希值得到数组位置**

   index = (n - 1) & hash

7. **==和equals区别**

8. **onNewIntent() 什么时候会被调用？**

   - singleTop 在栈顶，二次进入时
   - singleTask、singleInstance
     - 在栈顶，二次进入，onNewIntent()、onResume()
     - 不在栈顶，二次进入，onNewIntent()、onRestart()、onStart()

9. **常用布局？常用布局效率问题？**

   - RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure
   - RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。
   - 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。
   - FrameLayout 性能最好，可以通过 android:layout_gravity 来摆放子布局。

10. **idlehandler**



爱奇艺

1. **Looper#quit() 做了哪些操作**

   - 调用了 MessageQueue 中的 quit(boolean safe)，用来退出；
   - 是否安全退出的区别在于，是直接退出，还是将消息执行完后再退出；
   - 会回收 message，将其中的属性置为 null；
   - 主线程不能退出；

2. **hashmap 哈希值 异或运算的目的**

   为了散列更均匀，key的哈希值与其右移16位后进行异或运算，右移16位，高位补0；

   - 与运算，1和1才得1，其它为0，结果趋向于0；
   - 或运算，0和0得0，其它为1，结果趋向于1；
   - 异或运算，1和0才得1，相同得0，结果更均匀，异或运算能更好的保留各部分的特征；

   > 右移原因：当数组的长度很短时，**只有低位数的hashcode值能参与运算。而让高16位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率**。**并且使得高16位和低16位的信息都被保留了。**

3. **ConcurrentHashMap 线程安全的原理？1.6和之前的有什么区别？**

   - JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。

   - JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结点）（实现 Map.Entry）。锁粒度降低了。

4. **设计模式？策略模式？**

5. **线程池的种类？分别的作用？**

   - FixedThreadPool

     线程数量固定的线程池，只有核心线程，没有超时机制，当线程处于空闲状态时，不会被回收，能更快的响应外界的请求；

   - CachedThreadPool

     - 线程数量不固定的线程池，最大线程数为 Integer.MAX_VALUE，没有核心线程，60s 超时，超过 60s 闲置线程就会被回收。
     - 当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止，此时是没有线程的，几乎不占用任何系统资源。
     - 适合执行大量的耗时较少的任务。
     - OkHttp 中 Dispatcher 中维护的线程池就是这种类型；

   - ScheduledThreadPool

     - 核心线程数量固定，非核心线程数没有限制；
     - 超时时间为 0，当非核心线程闲置时会被立即回收；
     - 主要用于执行定时任务和具有固定周期的重复任务；

   - SingleThreadExecutor

     - 内部只有一个核心线程，确保所有的任务都在同一个线程中按顺序执行；
     - 意义在于统一所有的外界任务到一个线程池中，这使得在这些任务之间不需要处理线程同步问题；

6. **单链表环长？**

   快慢指针，相等时，再次设置，再相等时及环长。

7. **一个数组最大子序列的和？**

   ```java
   /*
   假设sum<=0，那么后面的子序列肯定不包含目前的子序列，所以令sum = num；
   如果sum > 0对于后面的子序列是有好处的。res = Math.max(res, sum)保证可以找到最大的子序和。
   int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
   res = 6
   */
   private static int maxSubArray(int[] nums) {
       int res = nums[0];
       int sum = 0;
       for (int num : nums) {
           if (sum > 0) {
               sum += num;
           } else {
               sum = num;
           }
           res = Math.max(res, sum);
       }
       return res;
   }
   ```

   

8. **如果 hashmap 初始长度为1000，插入1001条数据，会触发扩容吗？**

   当HashMap中的元素个数超过`capacity(数组长度默认16) * loadFactor(负载因子默认0.75`时，就会进行数组扩容

9. **最大公约数?**

   - 辗转相除法，递归 ，两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。

     当两个整数较大时，做a%b取模运算的性能会比较差。

   - 更相减损术，两个正整数a和b（a>b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。

     - 避免了大整数取模可能出现的性能问题。
     - 更相减损术依靠两数求差的方式来递归，运算次数肯定远大于辗转相除法的取模方式，当两个相差比较大的数进行求公约数时，递归次数会很多；

   - 把辗转相除法和更相减损术的优势结合起来，在更相减损术的基础上使用移位运算。

10. **RN 与 原生交互，上下文怎么传?**













滴滴

1. **自己实现图片加载框架**
   - 异步加载：线程池
   - 切换线程：Handler
   - 缓存：LruCache、DiskLruCache
   - 防止 OOM：软引用、LruCache、图片压缩、Bitmap 像素存储位置
   - 内存泄漏：注意 ImageView 的正确引用、生命周期管理
   - 列表滑动加载问题：加载错乱、队满任务过多问题
   - 加载动画
2. **内存缓存 LruCache**
   - LruCache 采用**最近最少使用算法**，设定一个缓存大小，当缓存达到这个大小之后，会将最老的数据移除，避免图片占用内存过大导致OOM。
   - LruCache 内部用LinkHashMap存取数据，在双向链表保证数据新旧顺序的前提下，设置一个最大内存，往里面put数据的时候，当数据达到最大内存的时候，将最老的数据移除掉，保证内存不超过设定的最大值。
   - LinkHashMap 继承HashMap，在 HashMap的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头header之前，这样就保证了链表头header节点之前的数据都是最近访问的（从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在map中的位置是不变的）。
3. **怎样限制一个账号一小时内登录五次**
4. **设计模式**
5. **一个接口响应很慢怎么去定位**
   - okhttp有超时机制，用 Retrofit 和 RxJava 请求接口，超时会走 onError 回调，可以在 onError() 中打断点，查看哪个接口报错；
   - 用抓包工具，比如 Charles 可以查看一个接口的响应时间；





