滴滴

1. 沉浸式标题栏，上滑背景渐变怎样实现？
2. 动态换肤怎样实现？
3. RecyclerView+ScrollView 为什么会滑动冲突？
4. 动画
5. webview + 原生评论为什么会卡？
6. activity 栈
7. Binder 速度为什么快？Messenger怎样实现同步？
8. RN 和 Flutter 区别？



1. synchronized 修饰静态方法和普通方法的区别
2. RN 和 H5 的区别
3. RN 实现原理
4. 加密
5. 三种图片加载框架对比
6. 防止参数被抓包



探探

1. 泛型
2. 多态
3. 内存泄漏
4. 软引用的使用
5. HashMap#put() 时间复杂度
6. 怎样限制三方库的大小
7. 原子性
8. MVC、MVP、MVVM
9. http 报文
10. service 生命周期
11. onSaveInstance() 什么时候被调用
12. RecyclerView 和 ListView 的区别
13. ConstraintLayout 和 RelativeLayout 区别
14. MVP 减少接口的方法
15. 优化网络请求
16. SSL 加密过程
17. https和http区别
18. 进程间通信的方式



1. Retrofit 解析数据

2. Fragment 之间传递数据

3. Jetpack

4. 打包

5. DNS解析

6. ViewGroup onDraw() 会执行吗

   ViewGroup 没有实现 onDraw()，由各个实现类如 LinearLayout 来实现



1. okhttp 连接池
2. 网络层
3. SSL
4. https 加密算法
5. TCP 连接状态
6. 多线程实现方式
7. 线程创建消耗哪些资源
8. 合并两个有序链表



1. 性能优化

2. 设计模式

3. webview js

4. 自定义 View

5. 过度绘制

6. application 上下文能启动 dialog 吗

7. ViewStub

8. 资源混淆

9. 图片加载

10. volatile

11. 反射

12. dialog window 类型

13. EventBus

14. 卡顿

15. Fragment 创建为什么用 setArguments()

    防止横竖屏切换重新创建



1. startActivity 是同步还是异步
2. AMS 发消息是异步的吗
3. 资源 R 文件混淆，怎么不乱
4. 单例模式
5. 链表环、切点、环长
6. 快速排序



1. 堆和栈存放了哪些文件
2. class 文件存在哪儿
3. class 文件组成
4. apk 文件组成
5. 方法区
6. 静态内部类、匿名内部类
7. k个一组反转字符串



1. 方法参数中的 final 起什么作用
2. GC 什么时候会发生？system.gc 会直接发生吗？
3. RN 的原理
4. 内存相关
5. 哪些可以作为 GC root
6. HashMap 和 ArrayMap



美团

1. NestedScrollView 嵌套滑动机制
2. RN
3. HashMap 为什么是 2^n，链表多长变为红黑树
4. Java 包权限
5. ConcurrentHashMap 什么情况下会阻塞





腾讯

1. 输入网址到页面显示的过程

2. 反射效率低的原因？怎么优化

3. Class 文件组成部分

4. message 同步、异步消息，消息屏障

5. recyclerview 复用机制？满屏5个，共20个，onCreateViewHolder() 会执行多少次？

   先复用，再缓存，cacheViews 大小为 2，recyclerPool 大小为 5，cacheViews 只能用于同位置的item复用

6. http 与 https 区别



墨迹天气

1. okhttp缓存策略

2. **okhttp超时时间**

   - internal var callTimeout = 0

     - 总超时时间
     - 从发起到结束的总时长。其中不包括 UnknownHostException 情况

   - internal var connectTimeout = 10_000

     - 连接超时时间

     - 三次握手 + SSL建立耗时

       超时时间：默认10s

   - internal var readTimeout = 10_000

     - 读取超时时间
     - 连接建立后，从远端获取数据。TCP 传输

   - internal var writeTimeout = 10_000

     - 写入超时时间
     - 连接建立后，向远端发送数据。TCP 传输

3. 怎样封装 okhttp

4. okhttp 取消请求



APUS

1. 静态内部类和内部类的区别
2. sleep 和 wait、sleep 怎样不放弃时间片
3. 子线程能更新UI吗
4. 子线程能弹toast吗



去哪儿网

1. app启动流程
2. recyclerView 复用机制
3. MVP model层异步请求一个数据，怎样更新到 View
4. android sdk 中 MVC 模式的体现



1. 合并两个有序链表
2. 网络请求加密
3. listview 优化
4. inflate 布局优化方案
5. 反射
6. 泛型作用
7. TCP三次握手、四次挥手
8. 注解
9. ImageView 怎样显示到屏幕



1. 选择排序
2. jsbridge 协议怎样定义，数据格式
3. 网络优化
4. okhttp 一个请求分几个过程



1. GC
2. 对象间引用关系



健客网

1. handler 延迟消息原理

2. 发送一个延迟10秒的，再发送一个延迟5秒的，怎么做到先处理5秒的？

   管道机制

3. 插件化，宿主怎样和插件通信

4. 双亲委派，为什么采用这种机制

   安全性、唯一性，先用父类加载器加载，一直往上查，都没有再用自身加载

   防止重写一个系统的类，加载进去

5. **为什么要序列化，两种序列化的区别**

   > 在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象。
   >
   > ```
   > 序列化就是将对象的状态信息转换为可以存储或传输的形式的过程。
   > 序列化的原因：
   > ①永久性保存对象，保存对象的字节序列到本地文件中。
   > ②对象在网络中传递。
   > ③对象在IPC间传递。
   > ```

   

   > Serializable的作用是保存对象的属性到本地文件，数据库，网络流等方便数据传输，也可程序之间传递。
   >
   > parcelable的设计的目的是为了解决Serializable效率不高的问题，内存开销小，所以在内存间传递数据的方式用parcelable，缺点是不能持久化。

   ```xml
   两种序列化方式的选择：
   一般在保存数据到 SD 卡或者网络传输时建议使用 Serializable 即可，虽然效率差一些，好在使用方便。
   而在运行时数据传递时建议使用 Parcelable，比如 Intent，Bundle 等，Android 底层做了优化处理，效率很高。
   
   1.在使用内存的时候Parcelable比Serializable的性能高。
   2.Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC（内存回收）。
   3.Parcelable不能使用在将对象存储在磁盘上这种情况，因为在外界的变化下Parcelable不能很好的保证数据的持续性。
   
   一个是Java API 一个是Android API
   一个效率低     一个效率高
   ```

6. getWidth() 和 getMeasuredWidth() 区别？ScrollView 两种获取到的高度相同吗

   - getWidth() 和 getMeasuredWidth() 一般情况下都是相等的
     - getMeasuredWidth方法获得的值是setMeasuredDimension方法设置的值，它的值在measure方法运行后就会确定
     - getWidth方法获得是layout方法中传递的四个参数中的mRight-mLeft，它的值是在layout方法运行后确定的
     - 一般情况下在onLayout方法中使用getMeasuredWidth方法，而在除onLayout方法之外的地方用getWidth方法。
     - 除非手动在layout() 方法中设置值，否则一般情况下两者相等，只是赋值时机不同；
   - ScrollView getHeight() 和 getMeasuredHeight() 相同，都是屏幕高度

7. **为什么启动一个 activity 要用 intent 传值**

   > 一个Activity启动另一个Activity时，并没有startActivity(Class activityClass)这样看起来似乎更简单、更直接的方法， 而是采用Intent"意图"来表达需要启动哪一个Activity，细想之下你会发现是有很多原因的：
   > 1.“Intent提供了一种统一的编程模型”：不管是要启动一个Activity、要启动一个Service、还是要启动一个BroadcastReceiver，Android提供了统一的Intent对象来封装这种"启动意图"，这与Android本身的理念是相一致的；
   > 2.“Intent方式降低了组件耦合”：有些时候，我们只是想启动某个组件，并不想和这个组件产生耦合，如果采用startActivity(Class activityClass)方式势必会造成一种硬编码耦合，同时也就会不利于解耦；从而也提高了系统的可扩展性、可维护性；
   > 3.“Intent是组件之间通信的重要媒介”：两个Activity之间可以把要交换的数据封装在成Bundle对象，使用Intent携带Bundle对象实现Activity之间的数据交换；



猫眼

1. recyclerView 复用机制

2. 说几个线程池

3. 线程池怎样保证线程安全

4. okhttp 责任链怎么实现

5. threadlocal 怎么实现

6. ViewPager 懒加载

7. MVP 和 MVC 区别，MVP 有什么问题

8. 设计模式的好处

9. ViewPager 三个 Fragment的生命周期

   默认预加载一个，一进入页面，第一、二个 fragment 都走到 onResume() 第三个不走，当走到第二个的时候，第三个从 onAttach 到 onResume，滑动到第三个时，第一个 onDestroyView



网易

1. RxJava 和 Retrofit 怎么结合

   通过 addCallAdapterFactory() 设置 RxJava2CallAdapterFactory，在调用接口方法时，走动态代理的 invoke() 方法，其中会解析接口方法的返回类型 Observable，注解、方法参数等信息，将 okhttp 请求到的数据转换成 RxJava Observable

2. 线程池有什么限制吗

3. 滑动冲突怎么处理

4. nestedScrollView 怎么处理嵌套 RecyclerView

   子View的测量模式由layoutparams 和 父类的测量模式共同决定，NestedScrollView 传给 RV 的测量模式为 UNSPECIFIED，RV 会不限制自身的高度，即 RV 的窗口高度将会变成所有 item 高度累加后加上 padding 的高度。因此表现出来就是 item 一次性全部加载完成。

5. handler怎么处理延迟消息，时间未到怎么办？时间到了怎么办

6. MVP 有什么问题

7. 四种垃圾回收算法

8. Java 值传递

9. 合并两个有序数组

10. 父 View onInterceptTouchEvent() return  false 后，还会交给父 View 吗

11. 滑动冲突，同向，开始由子view处理滑动，后边想让父View处理滑动，怎么办



小熊博望

1. 静态内部类单例模式怎样保证线程安全

   由 JVM 类加载机制保证，同一个类在加载过程中只能由一个线程去执行这个类的 `<clinit>（）` 方法，其他线程都需要阻塞等待

2. 单向链表给一个头结点，找到中间结点

3. okhttp 复用，如果已经有这个请求，还会创建新的请求吗

   如果哪儿能复用，直接复用，否则去连接池里获取，没有的话创建新的连接

4. 双重锁单例模式，内层判断的意义？如果没有怎么办？

   外层判断，防止无用的同步，浪费资源

   内层判断，作用就是保证单例，只能创建一个对象，没有的话，两个线程都进入sync，一个持有锁，一个等待，等第一个创建完对象，第二个进入锁，没有判断，会重新创建新的对象

5. handler 没有消息会怎样？nativePollonce 每次都会执行吗？怎么唤醒？

6. 如果只采用某种类型 so 库，其它架构的手机会怎样？

7. ReentryLock 和 synchronized 区别

8. okhttp 缓存

9. 事件分发从哪儿开始

10. 自定义 ViewGroup 将传入的 ImageView 最终裁成圆形，需要重写哪些方法

    - 重写 onLayout() 摆放布局
    - 重写 onDraw() 使用 canvas.clipPath()

11. 如何让 viewgroup 和 子 View 都处理事件

12. hashmap 什么时候会冲突



西山居

1. okhttp源码分为哪几个模块，分别负责什么

2. 为什么用 handler

3. 一个点击事件走哪些方法

4. hashmap 的 hash 算法

   ```java
   static final int hash(Object key) {
   	int h;
   	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
   }
   ```

   为了散列更均匀

5. 搭建一个框架需要注意什么

6. hashmap 的优势

   查询速度快 O(1)，动态可变长存储数据

7. okhttp 有哪些优势

8. okhttp 缓存

9. 事件分发，点击一个 button 滑动到另一个 button 再滑出屏幕

   只会走第一个 button 的事件

10. 多个handler 同时发送消息，怎么处理

11. 数据库版本升级



金山

1. androidx
2. https 和 http 区别
3. 防止抓包 加签加密的方式
4. 非对称加密
5. webview 需要注意的安全问题
6. view的绘制流程
7. draw 先绘制哪些
8. view.post
9. android 版本适配
10. 两个 classLoader 的区别
11. RxJava 是怎样切换线程的
12. retrofit 是怎样切换线程的
13. 反射中的方法，都有哪些作用



搜狐

1. 三个线程同时启动，执行完后再执行一个线程？

2. webview 和 js 交互

3. cancel 事件什么情况下会发生

4. 点再 button 上，onTouchEvent() 的 down 事件返回 true，viewgroup 还能拦截 move 和 up 事件吗

5. tinker 缺陷，第三方 aar 能修复吗

6. **intent 有什么限制**

   > 数据传递大小限制 1024KB
   >
   > 可传递数据类型：
   >
   > - Intent传递基本数据和基本数据数组
   > - Intent传递Parcelable对象
   > - Intent传递Serializable对象
   > - Intent传递String,Integer,CharSequence泛型集合
   > - Intent传递基本自定义对象集合
   >
   > 通过 bundle 来传递

7. activity 与 service 怎样交互

8. activity 的启动

9. 本地广播



易车

1. 数组查找为什么快

2. http1 和 http2 的区别

3. 哈希算法

4. okhttp 异步请求，等待队列什么时候加入到正在执行的队列

   取出等待队列中的 call，判断正在执行的 call 数量是否大于最大数 64，且每个 host 上 call 的数量是否大于 5，通过的话，即将待请求的 call 加入到 runningAsyncCalls 里，同时加入到 executableCalls，最后遍历 executableCalls，进行执行；

   执行 runningAsyncCalls.add(asyncCall) 的方法总过被四处调用：

   - enqueue() 异步请求
   - finished() 请求结束
   - maxRequests set方法
   - maxRequestsPerHost set 方法

5. 图片压缩在边以前还是编译后

6. 二分查找

7. 路由

8. 轻量级锁、重量级锁

9. wait notify 在重入锁中对应哪些方法

   newCondition()

10. okhttp线程池最大数量

    Int.MAX_VALUE，cacheThreadPool 类型，无核心线程，最大线程数不限，60秒超时

11. 真正执行网络请求的是哪个拦截器

    callServerInterceptor

12. CAS



映客直播

1. dialog 和 window

2. Java 虚拟机栈中存的是什么

3. JPG 和 png 的区别

4. OOM 发生在哪里

5. requestlayout() 和 invalidate() 的区别

6. Bitmap 存在哪儿

   3.0~8.0之前存在Java 堆中，8.0之后存在 native 堆中

7. 哪些对象可以作为 GC root

8. okhttp 连接复用



美图

1. calladapter 怎样将 call 转换成 observable

2. hashmap 放5个数据，初始值设置多少合适

   initialCapacity = (需要存储的元素个数 / 负载因子) + 1，负载因子 0.75

   且应该为 2 的 n 次幂

3. ConcurrentHashMap 怎样实现线程安全的

4. 播放器，电话进来，怎样停止播放，怎样监听

5. TextView 怎样对 Drawable 进行缩放动画，比如分享文字和分享图标，让图标缩放

6. 自定义View 怎样绘制，设置圆角

   https://blog.csdn.net/f409031mn/article/details/87211850

   - canvas.clipPath()，canvas.drawBitmap()
   - PorterDuffXfermode 使用图像混合模式，设置画笔，canvas.drawBitmap()
   - BitmapShader 设置画笔，canvas.drawCircle()

7. fragment 回退栈，怎样监听返回



玩吧

1. **ThreadLocalMap 结构，怎样存储 Looper 的？**
   - ThreadLocalMap 是线程内部的数据存储类，在指定线程中存储的数据，只能在指定线程中获取；
   - 有个内部类，ThreadLocalMap，主体结构是 Entry 数组，在 ThreadLocalMap 构造函数中初始化，初始长度为 16，扩容是扩大为原来的 2 倍；
   - set() 方法，先获取当前线程 thread 对象，Thread 中有一个属性 threadLocals，即 ThreadLocalMap；获取 threadLocalMap 对象，为空就创建，然后将 value 存到 map 中，key 为 this，即使 ThreadLocal 本身；
2. synchronized 和 Lock 的区别？效率问题？
3. lock 的使用场景
4. 自定义 View 的流程
5. onSizeChanged 什么情况下会调用
6. hashmap 怎样通过哈希值得到数组位置
7. ==和equals区别
8. onNewIntent() 什么时候会被调用
9. 常用布局？常用布局效率问题？
10. idlehandler



爱奇艺

1. **Looper#quit() 做了哪些操作**

   - 调用了 MessageQueue 中的 quit(boolean safe)，用来退出；
   - 是否安全退出的区别在于，是直接退出，还是将消息执行完后再退出；
   - 会回收 message，将其中的属性置为 null；
   - 主线程不能退出；

2. **hashmap 哈希值 异或运算的目的**

   为了散列更均匀，key的哈希值与其右移16位后进行异或运算，右移16位，高位补0；

   - 与运算，1和1才得1，其它为0，结果趋向于0；
   - 或运算，0和0得0，其它为1，结果趋向于1；
   - 异或运算，1和0才得1，相同得0，结果更均匀，异或运算能更好的保留各部分的特征；

   > 右移原因：当数组的长度很短时，**只有低位数的hashcode值能参与运算。而让高16位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率**。**并且使得高16位和低16位的信息都被保留了。**

3. **ConcurrentHashMap 线程安全的原理？1.6和之前的有什么区别？**

   - JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。

   - JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结点）（实现 Map.Entry）。锁粒度降低了。

4. **设计模式？策略模式？**

5. **线程池的种类？分别的作用？**

   - FixedThreadPool

     线程数量固定的线程池，只有核心线程，没有超时机制，当线程处于空闲状态时，不会被回收，能更快的响应外界的请求；

   - CachedThreadPool

     - 线程数量不固定的线程池，最大线程数为 Integer.MAX_VALUE，没有核心线程，60s 超时，超过 60s 闲置线程就会被回收。
     - 当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止，此时是没有线程的，几乎不占用任何系统资源。
     - 适合执行大量的耗时较少的任务。
     - OkHttp 中 Dispatcher 中维护的线程池就是这种类型；

   - ScheduledThreadPool

     - 核心线程数量固定，非核心线程数没有限制；
     - 超时时间为 0，当非核心线程闲置时会被立即回收；
     - 主要用于执行定时任务和具有固定周期的重复任务；

   - SingleThreadExecutor

     - 内部只有一个核心线程，确保所有的任务都在同一个线程中按顺序执行；
     - 意义在于统一所有的外界任务到一个线程池中，这使得在这些任务之间不需要处理线程同步问题；

6. **单链表环长？**

   快慢指针，相等时，再次设置，再相等时及环长。

7. **一个数组最大子序列的和？**

   ```java
   /*
   假设sum<=0，那么后面的子序列肯定不包含目前的子序列，所以令sum = num；
   如果sum > 0对于后面的子序列是有好处的。res = Math.max(res, sum)保证可以找到最大的子序和。
   int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
   res = 6
   */
   private static int maxSubArray(int[] nums) {
       int res = nums[0];
       int sum = 0;
       for (int num : nums) {
           if (sum > 0) {
               sum += num;
           } else {
               sum = num;
           }
           res = Math.max(res, sum);
       }
       return res;
   }
   ```

   

8. **如果 hashmap 初始长度为1000，插入1001条数据，会触发扩容吗？**

   当HashMap中的元素个数超过`capacity(数组长度默认16) * loadFactor(负载因子默认0.75`时，就会进行数组扩容

9. **最大公约数?**

   - 辗转相除法，递归 ，两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。

     当两个整数较大时，做a%b取模运算的性能会比较差。

   - 更相减损术，两个正整数a和b（a>b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。

     - 避免了大整数取模可能出现的性能问题。
     - 更相减损术依靠两数求差的方式来递归，运算次数肯定远大于辗转相除法的取模方式，当两个相差比较大的数进行求公约数时，递归次数会很多；

   - 把辗转相除法和更相减损术的优势结合起来，在更相减损术的基础上使用移位运算。

10. **RN 与 原生交互，上下文怎么传?**













滴滴

1. **自己实现图片加载框架**
   - 异步加载：线程池
   - 切换线程：Handler
   - 缓存：LruCache、DiskLruCache
   - 防止 OOM：软引用、LruCache、图片压缩、Bitmap 像素存储位置
   - 内存泄漏：注意 ImageView 的正确引用、生命周期管理
   - 列表滑动加载问题：加载错乱、队满任务过多问题
   - 加载动画
2. **内存缓存 LruCache**
   - LruCache 采用**最近最少使用算法**，设定一个缓存大小，当缓存达到这个大小之后，会将最老的数据移除，避免图片占用内存过大导致OOM。
   - LruCache 内部用LinkHashMap存取数据，在双向链表保证数据新旧顺序的前提下，设置一个最大内存，往里面put数据的时候，当数据达到最大内存的时候，将最老的数据移除掉，保证内存不超过设定的最大值。
   - LinkHashMap 继承HashMap，在 HashMap的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头header之前，这样就保证了链表头header节点之前的数据都是最近访问的（从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在map中的位置是不变的）。
3. **怎样限制一个账号一小时内登录五次**
4. **设计模式**
5. **一个接口响应很慢怎么去定位**
   - okhttp有超时机制，用 Retrofit 和 RxJava 请求接口，超时会走 onError 回调，可以在 onError() 中打断点，查看哪个接口报错；
   - 用抓包工具，比如 Charles 可以查看一个接口的响应时间；





