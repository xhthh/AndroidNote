滴滴

1. **沉浸式标题栏，上滑背景渐变怎样实现？**

   - RecyclerView 监听滚动，根据 ToolBar 高度和滑动距离比较，计算透明度，通过 setBackGroundColor() 对 toolbar 进行设置；
   - 使用 CoordinatorLayout+AppBarLayout+CollapsingToolbarLayout来实现，因为CoordinatorLayout 有Behavior对象，可以通过设置来达到折叠效果。

2. **动态换肤怎样实现？**

   - 下载皮肤包
   - 加载皮肤 Resource 对象
     - 通过 AssertManager 反射调用 addAssertPath，加载皮肤资源
     - 构建 Resource 对象
   - 标记需要换肤的 View
     - 在 xml 中对需要换肤的 View 进行标记
     - 通过 LayoutInflater.setFactory2() 设置自定义 Factory2，在接口回调 onCreateView() 中可以拦截 view，对 view 的属性进行修改设置；
   - 刷新页面

3. **RecyclerView+ScrollView 为什么会滑动冲突？**

   > 滑动冲突会产生的根本原因在于滑动没有被正确的执行者执行，属于内部的滑动被外部劫持消耗掉了。ScrollView 的 onInterceptTouchEvent() 中对 ACTION_MOVE 进行了拦截。
   >
   > 解决方法：
   >
   > 在子控件中重写 dispatchTouchEvent() 在 ACTION_DOWN 事件中请求父 View 不进行拦截，然后在 ACTION_MOVE 事件中进行判断，子控件是否互动到了顶部或者底部，是的话，请求父 View 进行拦截做滑动处理，形成联动。
4. **动画**

5. **webview + 原生评论为什么会卡？**

6. **activity 栈**

7. **Binder 速度为什么快？Messenger怎样实现同步？**

   Binder数据拷贝只需要一次，而管道、消息队列、Socket都需要2次，但共享内存方式一次内存拷贝都不需要；从性能角度看，Binder性能仅次于共享内存。

8. **RN 和 Flutter 区别？**

   ![img](https://upload-images.jianshu.io/upload_images/9423341-b06ed95e3fec3288.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)



1. **synchronized 修饰静态方法和普通方法的区别**

   - 静态方法锁是class字节码文件对象

     两个不同对象进行访问是同步的，锁的是class

   - 普通方法锁是this对象

     两个不同的对象访问同一个方法是不同步的

2. **RN 和 H5 的区别**

3. **RN 实现原理**

   https://juejin.cn/post/6844903860255850510

   - **UI 层的 View**

     react native中所有的标签都不是真实控件，Js代码中所写的控件，都作为一种Map中的Key值。JS端通过这个Key组合的Dom，放到Virtual Dom这个虚拟的JS数据结构中，然后通过JSBridge传递到Native，Native端会解析这个Dom，从而得到对应的Native控件。

   - **API Module**

     原生端提供的各种Module模块参数，包括ModuleID、MethodID、Params，和JS端提供的各种Module模块参数，都会在C++层的Bridge 中注册。 Js/Java 调用的ModuleID、MethodID、Params，通过Birdge映射，转换成Java/Js对应的ModuleID、MethodID、Params，实现两端方法的互调。通信的数据和指令，在中间层会专成Json传输。

   - **消息循环、线程模型**

     React Native 为JS引擎创建了一个独立的线程，在Android上主要由三个线程，每个线程都由与其绑定的消息队列

     - UI线程：即Android中的主线程，负责绘制UI以及监听用户操作。
   - Native线程：负责执行C++代码，该线程主要负责Java与C++的通信。
     - JS线程：负责解释执行JS。

     三个线程的交互主要借助Android 的Handler来完成。

4. **加密**

5. **三种图片加载框架对比**

6. **防止参数被抓包**

   - 参数加密、加盐













探探

1. 泛型

   > 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。
   >
   > **泛型的本质是参数化类型**，即给类型指定一个参数，然后在使用时再指定此参数具体的值，那样这个类型就可以在使用时决定了。这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。
2. 多态

   > 多态是同一个行为具有多个不同表现形式或形态的能力。
   >
   > 多态存在的三个必要条件
   >
   > - 继承
   > - 重写
   > - 父类引用指向子类对象：**Parent p = new Child();**
3. 内存泄漏

4. 软引用的使用

5. HashMap#put() 时间复杂度

6. 怎样限制三方库的大小

7. 原子性

8. MVC、MVP、MVVM

9. **http 报文**

   https://blog.csdn.net/yutiab69/article/details/82869239

   请求报文

   - 请求行
   - 请求头
     - Accept，接收的数据类型。
     - Accept-Language，接收的语言。
     - Accept-Encoding，客户端的编码方式。
     - Connection，长连接还是短链接。
     - Host，客户端的主机和端口号。
     - Referer，请求来源网站。
     - User-Agent，客户端的系统和浏览器的信息。
     - Cache-Control，缓存设置（重点）。
     - Cookie，存储用户信息。Range，获取的数据部分。
   - 空行
   - 请求体

   响应报文

   - 状态行
   - 响应头
   - 空行
   - 响应体

10. service 生命周期
  
11. onSaveInstance() 什么时候被调用
  
12. RecyclerView 和 ListView 的区别
  
13. **ConstraintLayout 和 RelativeLayout 区别**
  
    ConstraintLayout测量次数比较多，优势是减少布局的层级，减少过度绘制，提升帧数。
  
    复杂界面的话，ConstraintLayout可以减少布局嵌套深度，简单的界面ConstraintLayout和其它布局都差不多。
  
14. MVP 减少接口的方法
  
15. 优化网络请求
  
16. **SSL 加密过程**
      SSL：安全套接字协议，TLS：安全传输层协议
  
      - 认证服务器
    
        一些主流浏览器会内置一个受信任的CA机构（如[GeoTrust](https://www.idcspy.com/geotrust.html)、[Comodo](https://www.idcspy.com/comodo.html)、[GlobalSign](https://www.idcspy.com/globalsign.html)等）列表，并会保存相关CA机构的[SSL证书](https://www.anxinssl.com/)。当用户在访问部署了SSL证书的网站时，服务器会提供经CA机构颁发的SSL证书，如果认证该服务器证书的CA机构是存在于浏览器的受信任CA机构列表当中，并且该SSL证书中的所有信息均与当前证在访问的网站所有信息一致，那么浏览器就会认为服务端是可信的，并从[SSL证书](https://www.anxinssl.com/)中取得公钥（也就是CSR文件），用于后面的流程，这是SSL加密的第一步。

      - 协商会话秘钥

        在服务器认证完获取公钥之后，SSL加密利用公钥与服务器进行加密通信，协商出两个会话秘钥，用于加密客户端和加密服务端互发数据时的会话秘钥。这个秘钥是随机生成的，每一次协商产生的结果都不一样，所以安全性也是比较高的。

      - 加密传输

        当客户端和服务器端都拥有了协商的会话密钥之后，进行数据传输时，都是以密文的方式进行传输。这样的传输方式，保证了数据的私密性和完整性，再也不用担心数据在传输过程中被第三者窃取和篡改了。

      ![img](https://img-blog.csdnimg.cn/img_convert/a9c9d8365611d09adf3b893d98537f1f.png)

  17. **https和http区别**

      - HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
      - 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
      - HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
      - http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
      - HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

  18. 进程间通信的方式

  

  1. Retrofit 解析数据
  
  2. Fragment 之间传递数据
  
3. Jetpack
  
  4. 打包
  
5. DNS解析
  
6. ViewGroup onDraw() 会执行吗
  
   ViewGroup 没有实现 onDraw()，由各个实现类如 LinearLayout 来实现



  1. **okhttp 连接池**

     - 连接池是为了解决频繁的进行建立Sokcet连接（TCP三次握手）和断开Socket（TCP四次分手）。
     - Okhttp的连接池支持最大5个链路的keep-alive连接，并且默认keep-alive的时间是5分钟。
     - 连接池实现的类是RealConnectionPool，它负责存储与清除的工作，存储是通过ArrayDeque的双端队列存储，删除交给了线程池处理cleanupRunnable的任务。
     - 在每次创建RealConnection或从连接池中拿一次RealConnection会给RealConnection的 transmitters 集合添加一个弱引用的transmitter对象，添加它主要是为了后面判断该连接是否在使用中
     - 在连接池中找连接的时候会对比连接池中相同host的连接。
     - 如果在连接池中找不到连接的话，会创建连接，创建完后会存储到连接池中。
     - 在把连接放入连接池中时，会把清除操作的任务放入到线程池中执行，删除任务中会判断当前连接有没有在使用中，有没有正在使用通过RealConnection的transmitters集合的size是否为0来判断，如果不在使用中，找出空闲时间最长的连接，如果空闲时间最长的连接超过了keep-alive默认的5分钟或者空闲的连接数超过了最大的keep-alive连接数5个的话，会把存活时间最长的连接从连接池中删除。保证keep-alive的最大空闲时间和最大的连接数。
2. **网络层**

   - 应用层

     应用层决定了向用户提供应用服务时通信的活动；

     - HTTP
     - FTP

   - 传输层

     传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输；

     - TCP（Transmission Control Protocol，传输控制协议）

       是一种面向连接的、可靠的、基于字节流的传输层通信协议。

     - UDP（User Data Protocol，用户数据报协议）

       是一种面向无连接的传输层协议，提供面向事务的简单不可靠信息传送服务。

   - 网络层

     网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据传送给对方。

   - 链路层

     用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、网卡，及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。

3. **SSL**SSL(Secure Sockets Layer 安全套接层协议),及其继任者[传输层安全](https://baike.baidu.com/item/传输层安全)（Transport Layer Security，TLS）是为[网络通信](https://baike.baidu.com/item/网络通信/9636548)提供安全及[数据完整性](https://baike.baidu.com/item/数据完整性/110071)的一种安全协议。TLS与SSL在[传输层](https://baike.baidu.com/item/传输层/4329536)与[应用层](https://baike.baidu.com/item/应用层/16412033)之间对网络连接进行加密。

4. **https 加密算法**

   - 对称加密

     - DES
     - AES

   - 非对称加密

     RSA

   - 混合加密

     AES + RSA

5. **TCP 连接状态**

   ![img](https://img-blog.csdnimg.cn/2020120210533216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3p3bDE1ODQ2NzE0MTM=,size_16,color_FFFFFF,t_70)

   各种状态的解释

   LISTEN：侦听来自远方TCP端口的连接请求

   SYN-SENT：发送连接请求后等待匹配的连接请求

   SYN-RECEIVED（syn已经收到的）：收到和发送给一个连接请求后等待对连接请求的确认

   ESTABLISHED(已建立的)：代表一个打开的连接，数据可以传送给客户

   FIN-WAIT-1：等待远程TCP的连接中断请求，或者先前的连接中断请求的确认

   FIN-WAIT-2：从远程TCP等待连接中断请求

   CLOSE-WAIT：等待从本地用户发来的连接中断请求

   CLOSEING：等待远程TCP对连接中断的确认

   LAST-ACK：等待原来发向远程TCP的连接中断请求的确认

   TIME-WAIT：等待足够的时间一确保远程TCP接受到连接中断请求的确认

   CLOSED：没有任何连接状态

6. **多线程实现方式**

7. **线程创建消耗哪些资源**

8. **合并两个有序链表**



1. 性能优化

2. 设计模式

3. webview js

4. 自定义 View

5. 过度绘制

6. application 上下文能启动 dialog 吗

   > 不能
   >
   > android.view.WindowManager$BadTokenException: Unable to add window -- token null is not valid; is your activity running?
7. ViewStub

8. 资源混淆

9. 图片加载

10. volatile
  
11. 反射
  
  12. dialog window 类型
  
  13. EventBus
  
  14. 卡顿
  
15. Fragment 创建为什么用 setArguments()
  
    防止横竖屏切换重新创建



1. startActivity 是同步还是异步
  
   > `startActivity(intent)`并且`startActivityForResult(intent)`在这些方法立即返回而不启动Activity的意义上是异步的.实际上,只有在当前Activity的生命周期事件结束后,它们才会安排Activity启动.
     >
   > 如果你有什么需要花费一些时间来完成,那么在`onPause()`第一项活动的方法中,新的`Activity`开始将很慢.
  
2. AMS 发消息是异步的吗
  
3. 资源 R 文件混淆，怎么不乱
  
  4. 单例模式
  
5. 链表环、切点、环长
  
6. 快速排序



1. 堆和栈存放了哪些文件
  
   > 堆：存放实例对象和数组
     >
     > 栈：方法执行时会创建栈帧存放局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表中存放编译期已知的基本数据类型、对象引用和 returnAddress 类型；
  
  2. class 文件存在哪儿

     > class对象存放在堆中
     >
     > 
     >
     > 静态变量：
     >
     > jdk8之前：放在方法区
     > jdk8及以后：存放在堆中反射的class对象（即[类加载](https://so.csdn.net/so/search?q=类加载&spm=1001.2101.3001.7020)后会在堆中生成一个对应的class对象）的尾部。

  3. class 文件组成

     > - 魔数和class文件版本号
     > - 常量池
     > - 访问标志
     > - 类索引、父类索引与接口索引集合
     > - 字段表集合
     > - 方法表集合
     > - 属性表集合
  4. apk 文件组成
  
     > - AndroidManifest.xml
     >       是Android应用程序的配置文件
     >   
     > - META-INF
     >
     >   META-INF目录下存放的是签名信息，用来保证apk包的完整性和系统的安全。里面包含了三个文件，MANIFEST.MF、CERT.SF、CERT.RSA。
     >
     > - res目录
     >   res目录存放资源文件（布局、图片、values下的等等）
     >
     > - resources.arsc
     >   编译后的二进制资源文件，主要作用是App的资源索引表，可以从二进制的文件中查找到资源的相关信息，或者根据资源的id可以定位到二进制文件中的位置
     >
     > - classes.dex文件
     >   简单来说就是android系统的可执行文件，类似于window系统的xx.exe,它包含应用程序的全部操作指令以及运行时数据
     >
     > - lib目录
     >   so库
     >
     > - assets目录
     >   用于存放需要打包到APK中的静态文件，和res的不同点在于，assets目录支持任意深度的子目录，
     >   用户可以根据自己的需求任意部署文件夹架构，而且res目录下的文件会在.R文件中生成对应的资源ID，assets不会自动生成对应的ID，访问的时候需要AssetManager类。
  5. 方法区

  6. 静态内部类、匿名内部类
  
  7. k个一组反转字符串

  

  1. 方法参数中的 final 起什么作用
  
  2. GC 什么时候会发生？system.gc 会直接发生吗？

  3. RN 的原理

  4. 内存相关
  
  5. 哪些可以作为 GC root
  
  6. HashMap 和 ArrayMap
  
     > 使用场景，键值对存储
     >
     > 比如自定义路由中，存储 key 为 Activity 名字，value 为 class 对象

  

  



美团

1. NestedScrollView 嵌套滑动机制
  2. RN
3. HashMap 为什么是 2^n，链表多长变为红黑树
  4. Java 包权限
  5. ConcurrentHashMap 什么情况下会阻塞

  

  

  腾讯

1. **输入网址到页面显示的过程**
  
   - 输入网址，按下回车；
   
     - DNS域名解析，查找对应服务器的IP地址；
   
       > 访问浏览器缓存，有没有对这个域名解析过的 ip 缓存存在 ，如果缓存中有，就结束这个解析过程
       >
       > 访问系统的hosts 文件中域名对应的ip 如果没有就进行下一步
       > 上面本地查找还没有查找到的话，就会去域名解析服务器查找。就是电脑中设置的本地区域DNS服务器。
       > 如果上面的 LDNS 还没有命中，就直接到Root Server域名服务器请求解析
       > 根域名服务器返回给本地域名服务器一个所查询域的主域名服务器（gTLD Server)地址，gTLD 是国际顶级域名服务器，如 .com .cn .org 等，全世界只有13台左右。
       > 本地域名服务器再向 gTLD 服务器发送请求。
       > gTLD 服务器接受请求查找并返回你注册域名的域名提供商的域名服务器（Name Server)的地址
       > Name Server 域名服务器查询域名和 ip 对应的映射表
       > 返回 ip 和 TTL 的值， Local DNS Server 缓存 域名和 IP 对应关系，缓存时间由 TTL 控制
       > 把解析的结果返回给用户，用户根据TTL值缓存在本地系统缓存中，域名解析过程结束。
     > 原文链接：https://blog.csdn.net/woshihaizeiwang/article/details/122089991
     - TCP 三次握手建立连接；
   
     - 浏览器给web服务器发送一个HTTP请求；
   
       - 服务器永久重定向响应；
   
         服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“http://www.facebook.com/” 而非“http://facebook.com/”
   
       - 访问重定向地址，发送另一个请求；
   
     - 服务器处理请求，返回响应；
   
     - 浏览器解析 HTML，进行页面渲染；
   
     - 释放连接；
  
  2. **反射效率低的原因？怎么优化**
  
     - `Method.invoke`方法会对参数做封装和解封操作
     
     - 需要检查方法可见性
     
     - 需要校验参数
    
     - 反射方法难以内联
    
     - JIT无法优化
       
     
       
     - 获取Method对象慢：
       
       -  需要检查方法权限;
       
     -  需要遍历筛选寻找方法，甚至还要遍历父类的方法或者接口;
       
       -  每一个Method都有一个root，不暴露给外部，而是每次copy一Method。
       
     - 调用invoke方法慢：
     
       - invoke调用方法需要对参数做封装和解封装等操作(啥意思？invoke参数是Object，那我传int, long等基本类型的参数，它里面是不是要做封装和拆封的操作？会不会产生大量的对象？)；
       - 调用的时候还要检查方法的权限，还要校验参数；
       - invoke调用逻辑是委托给MethodAccessor的，而这个MethodAccessor对象实懒加载，你第一次调用invoke的时候才创建。
       - 因为是动态加载的，vm无法做优化。
     
     - 因为是动态加载的，vm无法做优化。
     
     优化：
     
        - 如果反射调用场景很少，则不需要太过纠结，直接反射调用就行了。如果可以的话，我们可以将Method对象缓存起来，并且设置检查方法的可见性为true：method.setAccessible(true); 首先我们得知道这个反射的代码是没有问题的。
        - 如果对性能要求较高，且无法缓存Method对象的情况下，尽量选择AsmReflect来进行反射调用。如果可以缓存，则也可以考虑使用使用Java 版 MethodAccessor，与AsmReflect差异并不是太大。
  3. Class 文件组成部分
  
  4. message 同步、异步消息，消息屏障
  
  5. recyclerview 复用机制？满屏5个，共20个，onCreateViewHolder() 会执行多少次？
  
     先复用，再缓存，cacheViews 大小为 2，recyclerPool 大小为 5，cacheViews 只能用于同位置的item复用
  
  6. http 与 https 区别

  

  墨迹天气

  1. **okhttp缓存策略**
  
     CacheInterceptor 负责读取缓存以及更新缓存的。它内部的实现是使用的OKIO是进行读取和写入的。
  
     1. 读取候选缓存
     2. 创建缓存策略，强制缓存、对比缓存等
     
      3. 根据策略，不使用网络，又没有缓存的直接报错，并返回错误码504。
      4. 根据策略，不使用网络，有缓存的直接返回。
       5. 前面两个都没有返回，继续执行下一个Interceptor，即ConnectInterceptor。
     
      6. 接收到网络结果，如果响应code式304，则使用缓存，返回缓存结果。
       7. 读取网络结果。
     
      8. 对数据进行缓存。
       9. 返回网络读取的结果。
     
2. **okhttp超时时间**

   - internal var callTimeout = 0

     - 从发起到结束的总时长。其中不包括 UnknownHostException 情况

   - internal var connectTimeout = 10_000

     - 连接超时时间
     - 三次握手 + SSL建立耗时
     - 超时时间：默认10s

   - internal var readTimeout = 10_000

     - 读取超时时间

     - 连接建立后，从远端获取数据。TCP 传输

   - internal var writeTimeout = 10_000

     - 写入超时时间
     - 连接建立后，向远端发送数据。TCP 传输

  3. 怎样封装 okhttp

  4. **okhttp 取消请求**

           - OkHttp 取消请求

             - 可以通过对request的处理，设置tag，传入当前activity
             - 然后在页面销毁时，进行取消请求
             - 然后通过Dispatcher获取正在执行和等待执行的请求队列，如果tag相符，则call.cancel()

           - Retrofit 取消请求

             - 因为 Retrofit 并没有提供可以直接发访问 Call 的方法，所以需要通过自定义 header 和自定义拦截器来处理。

             - 给每个与页面（Activity，Fragment）相关的request加入自定义header，[参考](https://links.jianshu.com/go?to=https%3A%2F%2Fpublicobject.com%2F2016%2F01%2F17%2Fsneaking-data-into-an-okhttp-interceptor%2F)。
               给OkHttpClient添加拦截器。标记出页面的生存状态。如果页面销毁了，则取消对应的request。

  

  APUS

  1. **静态内部类和内部类的区别**
  
     - 静态内部类相对与外部类是独立存在的，在静态内部类中无法直接访问外部类中的变量、方法。如果要访问的话，必须要new一个外部类的对象，使用new出来的对象来访问。 但是可以直接访问静态变量，调用静态的方法。
     - 普通内部类作为外部类一个成员而存在，在普通内部类中可以直接访问外部类属性，调用外部类的方法。
     - 如果外部类要访问内部类的属性或者调用内部类的方法，必须要创建一个内部类的对象，使用该对象访问属性或者调用方法。
     - 如果其他的类要访问普通内部类的属性或者调用普通内部类的方法，必须要在外部类中创建一个内部类的对象作为一个属性，外部类可以通过属性调用普通内部类的方法或者访问普通内部类的属性。
     - 如果其他的类要访问静态内部类的属性或者调用静态内部类的方法，直接创建一个静态内部类对象即可。
2. **sleep 和 wait、sleep 怎样不放弃时间片**
  
   ![img](https://img-blog.csdnimg.cn/2019050816141738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwMDA5MDE1,size_16,color_FFFFFF,t_70)
  
   > - sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。
     > - 在调用sleep()方法的过程中，线程不会释放对象锁。
   > - 而当调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备。
     > - sleep,wait调用后都会暂停当前线程并让出cpu的执行时间，但不同的是sleep不会释放当前持有的对象的锁资源，到时间后会继续执行，而wait会放弃所有锁并需要notify/notifyAll后重新获取到对象锁资源后才能继续执行。
  
3. **子线程能更新UI吗**
  
4. **子线程能弹toast吗**
  
5. 插件化开发、aot预编译
  
  6. **线程池的数量怎么规定**
  
     n为CPU核心数

     - 如果是CPU密集型应用，则线程池大小设置为N+1；
     - 如果是IO密集型应用，则线程池大小设置为2N+1。



去哪儿网

1. app启动流程
  2. recyclerView 复用机制
3. MVP model层异步请求一个数据，怎样更新到 View
  4. android sdk 中 MVC 模式的体现

  

  融360

  1. **合并两个有序链表**

  2. **网络请求加密**

  3. **listview 优化**
  
  4. **inflate 布局优化方案**

  5. **反射**
  
  6. **泛型作用**

  7. **TCP三次握手、四次挥手**

     三次握手：

     - 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。

     - 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。

     - 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。

       > 为什么是三次？
       >
       > 为了防止已经失效的连接请求报文突然又传送到服务端，因而产生错误。减小因延迟高拥塞大对报文传输的影响。

     四次挥手

     - 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。

        - 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
        - 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。
        - 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。

     > 为什么连接的时候是三次握手，关闭的时候却是四次握手？
     >
     > 答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。
     > 原文链接：https://blog.csdn.net/qq_38950316/article/details/81087809
  8. 注解

  9. ImageView 怎样显示到屏幕

  

  1. 选择排序

  2. jsbridge 协议怎样定义，数据格式

  3. 网络优化

  4. okhttp 一个请求分几个过程

     - 构建 OkHttpClient 配置参数；

     - 构建 Request 配置请求参数；

     - 异步或同步执行；

     - Dispatcher 进行分发处理；

     - 各个拦截器

       - interceptors

         自定义拦截器，比如自定义日志拦截器、添加header等

       - RetryAndFollowUpInterceptor

         重试与重定向拦截器，

       - BridgeInterceptor

         桥接，负责把应用请求转换成网络请求，把网络响应转换成应用响应，就是添加各种响应头信息的。负责把用户构造的请求转换为发送给服务器的请求，把服务器返回的响应转换为对用户友好的响应。 在Request阶段配置用户信息，并添加一些请求头。在Response阶段，进行gzip解压。

       - CacheInterceptor

         用来负责读取缓存以及更新缓存的。它内部的实现是使用的OKIO是进行读取和写入的。

       - ConnectInterceptor
       
       
     
      主要功能是复用连接池里面的连接，创建新的连接，并把读写数据流的对象交由下一个拦截器处理。
     
     > - networkInterceptors
     >   
     > - CallServerInterceptor
     >   
     >    写入http的请求，读取响应的head和body



1. GC
  2. 对象间引用关系

  

  健客网

1. **handler 延迟消息原理**
  
   - sendMessageDelayed()，在调用 MessageQueue#enqueueMessage() 时将这个msg根据实际执行时间进行排序插入到queue里面；
   
   - Looper 调用 MessageQueue#next()  不断取消息处理，会调用 nativePollOnce(nextPollTimeoutMillis) 如果时间未到，计算休眠时间，再次进入休眠；
   
     如果我在这段时间又插入了一个新的message怎么办，所以handler每次插入message都会唤醒线程，重新计算插入后，再走一次这个休眠流程。
   
     - nativePollOnce() 这个方法使用了 Linux 的 epoll 机制，具体是调用了 epoll_wait 这个方法；这个epoll和select一样都是linux的一个I/O多路复用机制。
   - Linux里的I/O多路复用机制：举个例子就是我们钓鱼的时候，为了保证可以最短的时间钓到最多的鱼，我们同一时间摆放多个鱼竿，同时钓鱼。然后哪个鱼竿有鱼儿咬钩了，我们就把哪个鱼竿上面的鱼钓起来。这里就是把这些全部message放到这个机制里面，那个time到了，就执行那个message。
     - epoll与select的区别：epoll获取事件的时候采用空间换时间的方式，类似与事件驱动，有哪个事件要执行，就通知epoll，所以获取的时间复杂度是O（1），select的话则是只知道有事件发生了，要通过O（n）的事件去轮询找到这个事件。
   
  2. **发送一个延迟10秒的，再发送一个延迟5秒的，怎么做到先处理5秒的？**
  
     管道机制，哪个消息时间到了就执行哪个
  
  3. **插件化，宿主怎样和插件通信**
  
     - 通信
       
       - 通过引用相同的aar来实现，即aar作为一个三方中转，来进行相关值的传导。
       - Intent
       
       - 广播
       - EventBus
       
       - Messenger
       
     - 访问资源
     
       - 宿主 Activity 访问插件资源
     
         - getResources().getString(getResources() .getIdentifier("plugin", "string","com.your.name")
     
         - 根据资源名称，来获取资源id，所以就可以根据id拿到资源了，需要提供插件的包名。
     
       - 插件访问插件的资源
     
         - 通过反射使用 AssetManager 的 addAssetPath 方法，把插件apk路径添加进去。再把系统的resource替换掉，就可以访问到资源了。
         - 由于每个apk只能访问自己的res，所以这时候使用hook newActivity创建的Activity对象，是无法访问到插件res的，虽然这个Activity确实是插件中的Activity，但是实际上是加载在宿主里的resource，所以也就是有个隔离，因此必须替换resource。
         - 网上博客文章中说的**解决了资源访问**问题，**实际上是指插件Activity不能访问插件本身的资源，而不是说宿主Activity访问插件的资源**。
  4. **双亲委派，为什么采用这种机制**
  
     安全性、唯一性，先用父类加载器加载，一直往上查，都没有再用自身加载
  
     防止重写一个系统的类，加载进去

  5. **为什么要序列化，两种序列化的区别**

     > 在系统底层，数据的传输形式是简单的字节序列形式传递，即在底层，系统不认识对象，只认识字节序列，而为了达到进程通讯的目的，需要先将数据序列化，而序列化就是将对象转化字节序列的过程。相反地，当字节序列被运到相应的进程的时候，进程为了识别这些数据，就要将其反序列化，即把字节序列转化为对象。
     >
     > 序列化就是将对象的状态信息转换为可以存储或传输的形式的过程。
     > 序列化的原因：
     > ①永久性保存对象，保存对象的字节序列到本地文件中。
     > ②对象在网络中传递。
     > ③对象在IPC间传递。     

     > Serializable的作用是保存对象的属性到本地文件，数据库，网络流等方便数据传输，也可程序之间传递。
     >
     > parcelable的设计的目的是为了解决Serializable效率不高的问题，内存开销小，所以在内存间传递数据的方式用parcelable，缺点是不能持久化。

   ```xml
     两种序列化方式的选择：
   一般在保存数据到 SD 卡或者网络传输时建议使用 Serializable 即可，虽然效率差一些，好在使用方便。
     而在运行时数据传递时建议使用 Parcelable，比如 Intent，Bundle 等，Android 底层做了优化处理，效率很高。
     
     1.在使用内存的时候Parcelable比Serializable的性能高。
     2.Serializable在序列化的时候会产生大量的临时变量，从而引起频繁的GC（内存回收）。
     3.Parcelable不能使用在将对象存储在磁盘上这种情况，因为在外界的变化下Parcelable不能很好的保证数据的持续性。
     
   一个是Java API 一个是Android API
     一个效率低     一个效率高
   
     Parcelable与Serializable的性能比较
     （1）、在内存的使用中，前者在性能方面要强于后者；
     
     （2）、后者在序列化操作的时候会产生大量的临时变量，(原因是使用了反射机制)从而导致GC的频繁调用，因此在性能上会稍微逊色；
   
     （3）、Parcelable是以Ibinder作为信息载体的，在内存上的开销比较小，因此在内存之间进行数据传递的时候，Android推荐使用Parcelable，既然是内存方面比价有优势，那么自然就要优先选择；
   
     （4）、在读写数据的时候，Parcelable是在内存中直接进行读写，而Serializable是通过使用IO流的形式将数据读写入在硬盘上；
   
      但是：虽然Parcelable的性能要强于Serializable，但是仍然有特殊的情况需要使用Serializable，而不去使用Parcelable，因为Parcelable无法将数据进行持久化，因此在将数据保存在磁盘的时候，仍然需要使用后者，因为前者无法很好的将数据进行持久化，(原因是在不同的Android版本当中，Parcelable可能会不同，因此数据的持久化方面仍然是使用Serializable)
    原文链接：https://blog.csdn.net/qq_38533448/article/details/116126895
   ```

  6. **getWidth() 和 getMeasuredWidth() 区别？ScrollView 两种获取到的高度相同吗**

     - getWidth() 和 getMeasuredWidth() 一般情况下都是相等的
     - getMeasuredWidth方法获得的值是setMeasuredDimension方法设置的值，它的值在measure方法运行后就会确定
     - getWidth方法获得是layout方法中传递的四个参数中的mRight-mLeft，它的值是在layout方法运行后确定的
     - 一般情况下在onLayout方法中使用getMeasuredWidth方法，而在除onLayout方法之外的地方用getWidth方法。
     - 除非手动在layout() 方法中设置值，否则一般情况下两者相等，只是赋值时机不同；
     - ScrollView getHeight() 和 getMeasuredHeight() 相同，都是屏幕高度，通过子view获取的是实际高度

  7. **为什么启动一个 activity 要用 intent 传值**

     > 一个Activity启动另一个Activity时，并没有startActivity(Class activityClass)这样看起来似乎更简单、更直接的方法， 而是采用Intent"意图"来表达需要启动哪一个Activity，细想之下你会发现是有很多原因的：
     >
     > 1.“Intent提供了一种统一的编程模型”：不管是要启动一个Activity、要启动一个Service、还是要启动一个BroadcastReceiver，Android提供了统一的Intent对象来封装这种"启动意图"，这与Android本身的理念是相一致的；
     > 2.“Intent方式降低了组件耦合”：有些时候，我们只是想启动某个组件，并不想和这个组件产生耦合，如果采用startActivity(Class activityClass)方式势必会造成一种硬编码耦合，同时也就会不利于解耦；从而也提高了系统的可扩展性、可维护性；
     > 3.“Intent是组件之间通信的重要媒介”：两个Activity之间可以把要交换的数据封装在成Bundle对象，使用Intent携带Bundle对象实现Activity之间的数据交换；



猫眼

1. **recyclerView 复用机制**

     RecyclerView 中的几个关键类

     - ViewHolder

     - 对于`Adapter`来说，一个`ViewHolder`就对应一个`data`。它也是`Recycler缓存池`的基本单元。
       
     - ViewHolder 的作用是持有 View 的引用，避免每次都去 findViewById() 进行 View 的创建。 
       
     - Adapter  
       
       > 它的工作是把`data`和`View`绑定。主要负责`ViewHolder`的创建以及数据变化时通知`RecycledView`。
       
     - AdapterDataObservable
       `Adapter`是数据源的直接接触者，当数据源发生变化时，它需要通知给`RecyclerView`。这里使用的模式是`观察者模式`。`AdapterDataObservable`是数据源变化时的被观察者。
       
     - RecyclerViewDataObserver
       
       > 它是`RecycledView`用来监听`Adapter`数据变化的观察者。
       
     - LayoutManager它是`RecyclerView`的布局管理者，`RecyclerView`在`onLayout`时，会利用它来`layoutChildren`,它决定了`RecyclerView`中的子View的摆放规则。但不止如此, 它做的工作还有:

       - 测量子View
          - 对子View进行布局
        - 对子View进行回收
          - 子View动画的调度
          - 负责`RecyclerView`滚动的实现

     - Recycler
       对于`LayoutManager`来说，它是`ViewHolder`的提供者。对于`RecyclerView`来说，它是`ViewHolder`的管理者，是`RecyclerView`最核心的实现。

       >    - scrap list
       >  - mCacheViews
       >  - RecycledViewPool

     四级缓存

     - 第一级缓存：mAttachedScrap、mChangedScrap；

       - mChangedScrap

         - 只有预取阶段在 mChangedScrap 中寻找，通过 position 和 id 分别查找；

         - 当 notifyItemChanged 数据发生变化，且 payload == null 时，存入 mChangedScrap，如果 payload!=null 则存入 mAttachedScrap

       - mAttachedScrap

         - 如果在 mChangedScrap 中没有找到 holder，则通过 position 在 mAttachedScrap 和 mCachedViews 中寻找
         - 调用notifyItemRemoved、notifyItemMoved、notifyItemInserted方法，ViewHolder放入mAttachedScrap中
         - 调用notifyDataSetChanged()时，如果Adapter.hasStableIds返回true，ViewHolder放入mAttachedScrap中，否则会将ViewHolder回收到非scrap缓存中

        - 第二级缓存：mCachedViews；

          - 大小默认为 2，只有相同位置才能复用，不会触发 onBindViewHolder()；

          - 超过 2，会将最早存入的一个放入 pool 中；


     - 第三级缓存：ViewCacheExtension；

     - 第四级缓存：RecyclerViewPool；

       大小默认为 5，根据 type 查找，需要在 onBindViewHolder() 中重新绑定数据；

     - 回收与复用

       - 滚动

         情况只与 mCachedViews 与 RecyclerViewPool 有关；

       - 刷新



2. **说几个线程池**

   - FixedThreadPool

     线程数量固定，只有核心线程，没有超时机制，空闲状态，线程不会被回收，能更快的响应外界的请求；

   - CachedThreadPool

     核心线程数为 0，线程数量不固定，60秒超时，适合执行大量的耗时较少的任务，空闲时线程都被回收，不占用系统资源；

   - ScheduledThreadPool

     核心线程数量固定，非核心线程无限制，非核心线程闲置时会立即被回收，用于执行定时任务和具有固定周期的重复任务；

   - SingleThreadExecutor

     只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。

  3. **线程池怎样保证线程安全**

     - volatile、AQS、ReentrantLock
     - Worker 继承自 AQS，在 addWorker() 方法中，使用到了 ReentrantLock
4. **okhttp 责任链怎么实现**
  
   责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。
  
5. **threadlocal 怎么实现**

   - 有个内部类 ThreadLocalMap，持有一个 Entry 数组；
   - Thread 类中有个 threadLocals 属性，即 ThreadLocalMap
   - set(T value) 方法，会获取当前线程，拿到 threadMap 对象，没有创建，然后将自身作为 key，把 value 存起来；

  6. **ViewPager 懒加载**

     - ViewPager 缓存，缓存的是 Fragment 对象，该对象被封装成了`ItemInfo` 被`add`到了`ArrayList<ItemInfo>` `mItems` 里面。当我们滑动ViewPager的时候，如果进入的是 已经缓存的`Fragment`，就不会去走 `Fragment`的重新创建生命周期(`onCreate-onCreateView-onViewCreated-onStart`)，直接使用缓存中的`Fragment`，调用它的`onResume`.
     - 通过 setOffscreenPageLimit(int limit) 来设置缓存的个数，如果输入为 0，强制改成 1，即最少缓存一个；
     - 通过自定义 BaseLazyLoadFragment 实现懒加载，主要是定义 2 个布尔值变量，一个表示 Fragment 当前状态是否可见，一个表示是否已经被加载过，如果加载过就不再请求数据；
  7. **MVP 和 MVC 区别，MVP 有什么问题**

  8. **设计模式的好处**
  
9. **ViewPager 三个 Fragment的生命周期**
  
   默认预加载一个，一进入页面，第一、二个 fragment 都走到 onResume() 第三个不走，当走到第二个的时候，第三个从 onAttach 到 onResume，滑动到第三个时，第一个 onDestroyView

  

  网易

  1. **RxJava 和 Retrofit 怎么结合**
  
     主要是适配器模式：

     - 通过 addCallAdapterFactory() 设置 RxJava2CallAdapterFactory，在调用接口方法时，走动态代理的 invoke() 方法；
     - ServiceMethod 中会解析接口方法的返回类型、注解、方法参数等信息；构建 callAdapter，这里是通过Retrofit#Builder 中传入的 callAdapterFactory 获取，调用其 get() 方法，构建 callAdapter；
     - serviceMethod.invoke() 方法中，会先构建一个 OkHttpCall，然后调用 adapt() 方法，即适配器模式，调用相应的 callAdapter.adapt() 转换成接口中声明的 ObserVable 类型；
  2. **线程池有什么限制吗**

     

  3. **滑动冲突怎么处理**

     - 外部拦截法
     - 内部拦截法
4. **nestedScrollView 怎么处理嵌套 RecyclerView**

   - 子View的测量模式由layoutparams 和 父类的测量模式共同决定，NestedScrollView 传给 RV 的测量模式为 UNSPECIFIED，RV 会不限制自身的高度，即 RV 的窗口高度将会变成所有 item 高度累加后加上 padding 的高度。因此表现出来就是 item 一次性全部加载完成。

   - **嵌套滑动机制** 

     原理可以认为是事件共享：

     - 当子控件接收到滑动事件，准备要滑动时，会先通知父控件（startNestedScroll）；

     - 然后在滑动之前，会先询问父控件是否要滑动（dispatchNestedPreScroll）；
     - 如果父控件响应该事件进行了滑动，那么就会通知子控件它具体消耗了多少滑动距离；
     - 然后交由子控件处理剩余的滑动距离；
     - 最后子控件滑动结束后，如果滑动距离还有剩余，就会再问一下父控件是否需要再继续滑动剩下的距离（dispatchNestedScroll）

  5. **handler怎么处理延迟消息，时间未到怎么办？时间到了怎么办**

   - MessageQueue#next() 方法取消息，一个 for 死循环，首先会调用 nativePollOnce(nextPollTimeoutMillis) 此方法会进入休眠，nextPollTimeoutMillis 是休眠时间，默认为 0；
  
   - 进入 synchronized 同步，后去当前时间 now，取消息 message，如果消息 msg 不为空：

     - now < msg.when

       通过 msg.when 和 now 计算出需要休眠的时间 nextPollTimeoutMillis；for 循环再次走到 nativePollOnce(nextPollTimeoutMillis) 进入休眠；

     - 时间到了底层会唤醒，for 循环，取出消息返回

  6. **MVP 有什么问题**
  
     - 会造成接口类爆炸问题。

       使用MVP模式去构建项目，会造成类文件和接口文件的过多，进而增大包的体积。

       解决：写一个Contract接口，然后把与MVP相关接口全部列入到里面去。
     
     - 会造成内存泄漏的问题。
     
       当用户关闭了View层，但这时Model层如果仍然在进行耗时操作，因为Presenter层也持有View层的引用，所以造成垃圾回收器无法对View层进行回收，这样一来，就造成了内存泄漏。
       解决：可以重写onDestroy()方法，在View销毁时强制回收掉Presenter;或是采用弱引用的方式
     
     - 视图和Presenter的交互会过于频繁，使得他们的联系过于紧密。也就是说，一旦视图变更了，presenter也要变更。
  
  7. **四种垃圾回收算法**
  
     - 标记-清除
     - 复制算法
     - 标记-整理
     - 分代收集
  
  8. **Java 值传递**
  
     - 值传递传的是堆地址，引用传递是传栈中的地址
     - java 中只有值传递，没有引用传递
     - 无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。
  
  9. **合并两个有序数组**

   ```java
     //两个指针，根据两个数组的长度进行判断，移动指针的位置，记录当前值，写入新数组中
   private static void mergeArray(int[] nums1, int m, int[] nums2, int n) {
         int p1 = 0;
       int p2 = 0;
         int[] sorted = new int[n + m];
       int cur;
         while (p1 < m || p2 < n) {
           if (p1 == m) {
                 cur = nums2[p2++];
             } else if (p2 == n) {
               cur = nums1[p1++];
             } else if (nums1[p1] < nums2[p2]) {
                 cur = nums1[p1++];
             } else {
                 cur = nums2[p2++];
             }
             sorted[p1 + p2 - 1] = cur;
         }
         for (int i = 0; i < m + n; i++) {
             nums1[i] = sorted[i];
         }
     }
   ```

  10. **父 View onInterceptTouchEvent() return  false 后，还会交给父 View 吗**
  
      会的，MOVE 和 UP 事件还是会走父 View 的 onInterceptTouchEvent() 和 dispatchTouchEvent() 但是不会走父 View 的 onTouchEvent()
  
  11. **滑动冲突，同向，开始由子view处理滑动，后边想让父View处理滑动，怎么办**
  
      思路分析：
  
      - 开始子view需要滑动，所以要获取事件，即此时父view不能拦截事件
      - 后期父view需要滑动，此时父view需要进行拦截，获取事件
      
      ```java
      //子view
      @Override
      public boolean dispatchTouchEvent(MotionEvent event) {
          switch (event.getAction()){
              case MotionEvent.ACTION_DOWN:
                  //进行反拦截，保证子view获取down事件, 否则后续事件无法获取
                  parent.requestDisallowInterceptTouchEvent(true);
                  break;
              case MotionEvent.ACTION_MOVE:
                  if(子view需要滑动){//禁止父view拦截
                    parent.requestDisallowInterceptTouchEvent(true);
                  }else {//允许父view拦截事件
                    parent.requestDisallowInterceptTouchEvent(false);
                  }
                  break;
              case MotionEvent.ACTION_UP:
      
                  break;
              default:
                  break;
          }
          return super.dispatchTouchEvent(event);
      }
      
      //父view
      public boolean onInterceptTouchEvent(MotionEvent event){
      	int action = event.getAction();
      	if(action == MotionEvent.ACTION_DOWN){
      		return false;
      	}else{
      		return true;
      	}
      }
      ```
  
      > 这类场景，父view一般都是ScrollView，内部已经有事件处理，只需关注子view就行。如ScrollView嵌套ScrollView或ListView，只需重写子view的dispatchTouchEvent方法即可。

    ```java
      private float downY;
    @Override
      public boolean dispatchTouchEvent(MotionEvent event) {
        switch (event.getAction()){
              case MotionEvent.ACTION_DOWN:
                downY = event.getY();
                  getParent().requestDisallowInterceptTouchEvent(true);
                break;
              case MotionEvent.ACTION_MOVE:
                if(Math.abs(downY - event.getY()) < 200){
                      getParent().requestDisallowInterceptTouchEvent(true);
                }else {
                      getParent().requestDisallowInterceptTouchEvent(false);
                }
                  break;
            case MotionEvent.ACTION_UP:
                  break;
            default:
                  break;
        }
          return super.dispatchTouchEvent(event);
    }
      ```

  






  小熊博望

  1. **静态内部类单例模式怎样保证线程安全**

     由 JVM 类加载机制保证，同一个类在加载过程中只能由一个线程去执行这个类的 `<clinit>（）` 方法，其他线程都需要阻塞等待

  2. **单向链表给一个头结点，找到中间结点**

     快慢指针

  3. **okhttp 复用，如果已经有这个请求，还会创建新的请求吗**

     连接复用由 ConnectInterceptor 实现，代码依次执行 realChain.call.initExchange --->exchangeFinder.find() ---> findHealthyConnection() ---> findConnection()

     第一步会先判断是否存在可复用的连接，如果有则直接用，如果没有则去连接池里面获取，如果连接池里面没有获取到，则最后才会去创建一个新的连接，并添加到连接池中。

  4. **双重锁单例模式，内层判断的意义？如果没有怎么办？**
  
     外层判断，防止无用的同步，浪费资源
  
     内层判断，作用就是保证单例，只能创建一个对象，没有的话，两个线程都进入sync，一个持有锁，一个等待，等第一个创建完对象，第二个进入锁，没有判断，会重新创建新的对象
  
5. **handler 没有消息会怎样？nativePollonce 每次都会执行吗？怎么唤醒？**
  
   - 主线程的 MessageQueue 没有消息时，便阻塞在 loop() 的 queue.next() 中的 nativePollOnce() 里，此时主线程会释放 CPU 资源进入休眠状态，直到下个消息到达或者有事务发生，通过往 pipe 管道写端写入数据来唤醒主线程工作。所以主线程大多数都是出于休眠状态，并不会大量消耗 CPU 资源。
     - 每次都会执行，nextPollTimeoutMillis 为休眠时间，值为 -1 时，一直处于休眠；
   - 当有新消息插入时，调用 nativeWake() 进行唤醒，或者延时消息时间到了，通过往 pipe 管道写端写入数据来唤醒主线程工作。
  
6. **如果只采用某种类型 so 库，其它架构的手机会怎样？**
  
   https://www.jianshu.com/p/0cb6fc7fab0f
  
     例如：对于一个cpu是arm64-v8a架构的手机，它运行app时，进入jnilibs去读取库文件时，先看有没有arm64-v8a文件夹，如果没有该文件夹，去找armeabi-v7a文件夹，如果没有，再去找armeabi文件夹，如果连这个文件夹也没有，就抛出异常；
  
  7. **ReentryLock 和 synchronized 区别**

  8. **okhttp 缓存**

  9. **事件分发从哪儿开始**

     - 从手机硬件到 ViewRootImpl ---> mView.dispatchPointerEvent，mView 即 DecorView，进入父类 View 中；
     - View#dispatchPointerEvent()  ---> DecorView#dispatchTouchEvent()
     - 进入Window.Callback 接口的实现类 Activity#dispatchTouchEvent()
     - 进入 PhoneWindow#superDispatchTouchEvent() ---> mDecor.superDispatchTouchEvent()
     - 进入 DecorView#superDispatchTouchEvent() ---> super.dispatchTouchEvent(event)
     - 进入 DecorView 父类 ViewGroup 的 dispatchTouchEvent()，遍历分发至此开始
  10. **自定义 ViewGroup 将传入的 ImageView 最终裁成圆形，需要重写哪些方法**

      https://blog.csdn.net/bobo_zai/article/details/104653340

      - 重写 onLayout() 摆放布局

      - 重写 onDraw() 

        - `BitmapShader`: 使用着色器
      - `Xfermode`：使用图层叠加
        
        - `ClipPath`：通过对画布裁剪的方式
  - `RoundedBitmapDrawable`: 系统API圆角类
    
    > 前面三种是通过继承`ImageView 重写 onDraw()`方法实现最后一种是系统 API 直接使用。

  11. **如何让 viewgroup 和 子 View 都处理事件**

      - 如果是DOWN事件，只要在子view的onTouchEvent()中return false即可。

    - 如果其他事件，需要在父view的dispatchTouchEvent()中处理，并在子view的dispatchTouchEvent()中return true。

12. **hashmap 什么时候会冲突**

  

  西山居

1. **okhttp源码分为哪几个模块，分别负责什么**

   https://blog.csdn.net/Android_LeeJiaLun/article/details/108326132

   ![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMTg2MzI0OC1lNzIyNzc5ZTE1MmVmYWI5LnBuZw?x-oss-process=image/format,png)

   - **Interface 接口层**

     主要负责网络请求，用户的网络[框架](https://so.csdn.net/so/search?q=框架&spm=1001.2101.3001.7020)的各种设置也是通过okhttpclient设置的！而整个Application中，应该共享一个okhttpclient 实例。

     - Call

       - RealCall
     - AsyncCall

     - Dispatcher

   - **Protocal 协议层**

     Protocol层负责处理协议逻辑，**OkHttp**支持**Http1、Http2、WebSocket**协议。

     - **Http2 区别于Http1**：
     - Http2使用的是二进制传送，HTTP1.X是文本（字符串）传送。
       - Http2支持多路复用。
      - Http2头部压缩。
       - Http2支持在客户端未经请求许可的情况下，主动向客户端推送内容。

   - **Connection 连接层**

     RealConnection

   - **Cache-缓存层**

   - **IO 层**

   - **Interceptor 拦截器层**

2. **为什么用 handler**
  
3. **一个点击事件走哪些方法**
  
     - dispatchTouchEvent()
     - onInterceptTouchEvent()
     - onTouchEvent()

  4. **hashmap 的 hash 算法**

     ```java
     static final int hash(Object key) {
     	int h;
      	return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
     }
     //为了散列更均匀
     ```

5. **搭建一个框架需要注意什么**
  
6. **hashmap 的优势**
  
   查询速度快 O(1)，动态可变长存储数据
  
7. **okhttp 有哪些优势**
  
     - 内置连接池，支持连接复用；
     - 支持gzip压缩响应体；
   - 通过缓存避免重复的请求；
   - 支持http2，对一台机器的所有请求共享同一个[socket](https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020)。

  8. **okhttp 缓存**

  9. **有A、B两个Button，各自设置了OnClickListener，在A上按下，移动到B上抬起，会触发OnClickListener么？为何?UP事件谁接收到了？OnClickListener触发的条件是哪些？**

     - 不会触发 OnClickListener，应该是必须在一个控件上按下同一个控件上抬起，才会触发，即手指移出 View 的范围，不会触发 onClick。
     - 因为 onTouchEvent() MOVE 中做了处理，当 pointInView(x, y, mTouchSlop) 为 false 的时候 ，也就是手指移出View范围，setPressed(false)，也就是设置取消了Pressed状态。
     - 而 OnClick 是在 UP 事件中触发的，手指抬起时，只要是处于 Pressed 状态，就会触发performClick() ，也就是回调 onClick 。
     - 如何实现 手指移出View后，仍然触发点击事件？可以重写 onTouchEvent() 手动设置 pressed 的状态；
     - 只会走第一个 button 的事件，UP 事件由 A 接收；
     - onClickListener 触发条件：
       - 如果设置 OnTouchEventListener，比如返回 false，如果返回 true，则不会执行 onTouchEvent()，而 OnClickListener 在 onTouchEvent() 中；
       - clickable 必须为 true，不过 setOnClickListener() 方法会判断，如果 clickable 为 false，会先置为true；

10. **多个handler 同时发送消息，怎么处理**
  
    按发送消息的时间顺序执行，同一个线程中只有一个 Looper 和 MessageQueue 实例。
  
11. **数据库版本升级**

  

  金山

  1. **androidx**

     背景：android向下兼容，使用support lib，如Fragment，v4（API4，v1.6), appcompat-v7（API7，v2.1）
      现在Android官方支持的最低系统版本已经是4.0.1
     AndroidX 是对support library 的一次升级：包名 从在android.support.*下面变成androidx.*下面。命名规则不会再包含具体操作系统API的版本号了。
      未来以AndroidX为主，Android support library不建议使用。
  
2. **https 和 http 区别**
  
3. **防止抓包 加签加密的方式**

   https://www.jianshu.com/p/c3b2b29ba133

     - 防止抓包

       - Android 官方配置信息证书

         > 这种方法只能防篡改设备的根证书，防不了使用 Android7.0 以下的手机。

       - 点击域名旁边锁的图标，弹出框里面点「证书」，获取公钥

       - 将公钥放到 res/raw 目录下，在network_security_config.xml 里写上相关配置

     - OkHttp 配置信任认证链
     
         写一个 CertificatePinner 的配置

         > 这种方法是全方面防御，在 Android7.0 以下设备也能起作用

       - okhttpClientBuilder.hostnameVerifier，重写 verify 方法，验证相关域名，返回 true or false

       - OkHttp，可以在Builder中设置proxy(Proxy.NO_PROXY)属性，禁止使用代理，这样一般使用中间人的代理就使用不了，客户端是直接访问服务器。

       - 网络请求和返回数据都加密，一般都会加密的吧。
     
   - 加签加密方式

     - md5
     - rsa

  4. **非对称加密**
  
     - RSA
  
5. **webview 需要注意的安全问题**

   - 任意代码执行漏洞

     - addJavascriptInterface 方法引起，可以通过反射调用这个 Android 对象的所有方法，包括系统方法；
     - 4.2 以上已经修复，使用 @JavaScriptInterface 即可，4.2 以下采用setWebChromeClient重新onJsPrompt()拦截prompt()消息进行交互。

   - 密码明文存储漏洞

     WebSettings.setSavePassword(false) 

   - 域控制不严格漏洞

     - 对于不需要使用 file 协议的应用，禁用 file 协议

     - 对于需要使用 file 协议的应用，禁止 file 协议加载 JavaScript

  6. **view的绘制流程**

  7. **draw 先绘制哪些**

     - 绘制背景
     - 绘制内容
     - 绘制孩子
     - 绘制装饰
8. **view.post**

   用到了 Handler
   - 如果已经 attachedToWindow，直接调用 attachInfo.mHandler.post()，attachInfo 在 ViewRootImpl 中创建，在调用 dispatchAttachedToWindow() 后赋值给 View 中的 attachInfo，传入的 handler 对象即主线程的 Handler（默认主线程，具体是创建 ViewRootImpl 的线程）
   - 如果没有 attachedToWindow，通过 post() 将任务存到了 HandlerActionQueue#mActions 数组中，而执行这些任务的方法在 ViewRootImpl#performTraversals() 中被调用 getRunQueue().executeActions(mAttachInfo.mHandler)，而 perfromTraversals() 同样是被封装到 Runnable 中通过 Handler 执行，根据消息机制，消息执行的先后顺序，所以当执行 View.post() 中的 runnable 时，View已经绘制完成，所以能够拿到 View 的宽高。

9. **android 版本适配**

   - 6.0
     
     - 动态权限申请
     
   - 7.0

     - 文件共享不能再使用file://这样的uri去分享访问了，会报FileUriExposedException错误（比如照片剪辑的Intent跳转），用FileProvider替代。
     - APK signature scheme v2
     - 移除了三项隐式广播，以帮助优化内存使用和电量消耗。

   - 8.0

     - 通知权限

       Android 8.0以后通知权限默认都是关闭的，没法默认开启以及经过程序去主动开启，须要程序员读取权限开启状况，而后提示用户去开启。

     - 通知适配

       Android 8.0中，为了更好的管制通知的提醒，不想一些不重要的通知打扰用户，新增了通知渠道，用户能够根据渠道来屏蔽一些不想要的通知。

     - 自适应启动图标

       - 从Android 8.0系统开始，应用程序的图标被分为了两层：前景层和背景层。

       - 安装 APK

         Android 8.0去除了“容许未知来源”选项，若是咱们的App具有安装App的功能，那么AndroidManifest文件须要包含REQUEST_INSTALL_PACKAGES权限。

       - 静态广播没法正常接收

   - 9.0

     - 刘海屏 API 支持
     - Android P 限制了明文流量的网络请求，非加密的流量请求(http)都会被系统禁止掉。
     - 前台服务必须添加权限
     - 全面限制静态广播
     - 非SDK接口访问限制

   - 10.0

     - 分区存储
     - 后台启动 Activity 的限制
     - 深色主题

   - 11.0

     - 强制执行分区存储
     - 管理设备存储空间
     - 权限变动
     - 必须加上 V2 签名
     - 自定义 toast 不允许在后台显示

  10. **两个 classLoader 的区别**
  
      - 在8.0之前唯一的区别也就是生不生成优化后的odex文件，8.0之后统一不在传递optimizedDirectory。

        > optimizedDirectory this parameter is deprecated and has no effect since API level 26.
        >
        > 也即是说这俩没啥区别
- 新增了InMemoryDexClassLoader，可以实现从内存中的buffer中加载dex，其他都一样了，本质都是BaseDexClassLoader逻辑，寻找目录内的文件生成DexPathList，然后通过makeElements生成elements数组，findClass可以通过这个数组遍历加载出相关的class文件，实现类加载。
      
  11. **RxJava 是怎样切换线程的**

  12. **retrofit 是怎样切换线程的**

      - Retrofit#Builder 构造方法里会调用默认的 Platfrom.get() 对 platform 进行配置，默认是 Android；
      - Android 里有个内部类 MainThreadExecutor，里面持有主线程 Looper 构建的 Handler，用来进行线程切换；
      - 它在 CallAdapterFactory 中被使用，在得到请求结果的 onResponse() 中通过 callbackExecutor 切换到主线程，进行回调 onResponse() or onFailure()
  13. **反射中的方法，都有哪些作用**

      JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的法的功能称为java语言的反射机制。 

      Class类对象的三种实例化模式：

      - Class.forName("完整类名带包名")
      - 对象.getClass()
      - 任何类型.class
      
      Class 类常用方法及其作用：
      
      - newInstance()
      
        返回一个Oject对象，是实现“虚拟构造器”的一种途径。使用该方法创建的类，必须带有无参的构造器。
      
      - getFields()
      
        获得某个类的所有的公共（public）的字段，包括继承自父类的所有公共字段。 类似的还有getMethods和getConstructors。
      
      - getDeclaredFields()
      
        获得某个类的自己声明的字段，即包括public、private和proteced，默认但是不包括父类声明的任何字段。类似的还有getDeclaredMethods和getDeclaredConstructors。
      
      - setAccessible(boolean flag)
      
        将此对象的 accessible 标志设置为指示的布尔值,即设置其可访问性。
      
      - getMethods()
      
        返回一个包含某些 Method 对象的数组，这些对象反映此 Class 对象所表示的类或接口（包括那些由该类或接口声明的以及从超类和超接口继承的那些的类或接口）的公共 member 方法。
      
      - getDeclaredMethods()
      
        返回 Method 对象的一个数组，这些对象反映此 Class 对象表示的类或接口声明的所有方法，包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法。

  

  

  搜狐

  1. **三个线程同时启动，执行完后再执行一个线程？**
  
     - join
  
  2. **webview 和 js 交互**

  3. **cancel 事件什么情况下会发生**

  4. **点再 button 上，onTouchEvent() 的 down 事件返回 true，viewgroup 还能拦截 move 和 up 事件吗**

     能，这样就会产生 CANCEL 事件传给子 View

  5. tinker 缺陷，第三方 aar 能修复吗

     

  6. **intent 有什么限制**

     > 数据传递大小限制 1024KB
     >
     > 可传递数据类型：
     >
     > - Intent传递基本数据和基本数据数组
     > - Intent传递Parcelable对象
     > - Intent传递Serializable对象
     > - Intent传递String,Integer,CharSequence泛型集合
     > - Intent传递基本自定义对象集合
     > - 通过 bundle 来传递
  7. **activity 与 service 怎样交互**

     - 广播

     - binder

       - Service 重写 onBind() 返回 IBinder 对象；

         自定义 MyBinder 类，继承自 Binder，声明一个方法，返回 Service 对象；

       - Activity 中创建 ServiceConnection 传入 bindService()，在回调中接收 IBinder 对象，获取对应的 Service 对象，调用其中的方法；

  8. **activity 的启动**

  9. **本地广播**

  

  易车

  1. **数组查找为什么快**

     - 因为数组在内存中是顺序存储的，可以随机访问，通过索引快速找到对应的元素；

       计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址。

     - CPU缓存会把一片连续的内存空间读入，因为数组结构是连续的内存地址，所以数组全部或者部分元素被连续存在CPU缓存里面，平均读取每个元素的时间只要3个CPU时钟周期。   而链表的节点是分散在堆空间里面的，这时候CPU缓存帮不上忙，只能是去读取内存，平均读取时间需要100个CPU时钟周期。这样算下来，数组访问的速度比链表快33倍；

  2. **http1 和 http2 的区别**

     - HTTP2使用的是二进制传送，HTTP1.X是文本（字符串）传送。

       大家都知道HTTP1.X使用的是明文的文本传送，而HTTP2使用的是二进制传送，二进制传送的单位是帧和流。帧组成了流，同时流还有流ID标示，通过流ID就牵扯出了第二个区别。

     - HTTP2支持多路复用

       因为有流ID，所以通过同一个http请求实现多个http请求传输变成了可能，可以通过流ID来标示究竟是哪个流从而定位到是哪个http请求

     - HTTP2头部压缩

       HTTP2通过gzip和compress压缩头部然后再发送，同时客户端和服务器端同时维护一张头信息表，所有字段都记录在这张表中，这样后面每次传输只需要传输表里面的索引Id就行，通过索引ID就可以知道表头的值了

     - HTTP2支持服务器推送
    
       HTTP2支持在客户端未经请求许可的情况下，主动向客户端推送内容
  
3. **哈希算法**
  
   - 散列算法（Hash Algorithm），又称哈希算法，杂凑算法，是一种从任意文件中创造小的数字「指纹」的方法。与指纹一样，散列算法就是一种以较短的信息来保证文件唯一性的标志，这种标志与文件的每一个字节都相关，而且难以找到逆向规律。因此，当原有文件发生改变时，其标志值也会发生改变，从而告诉文件使用者当前的文件已经不是你所需求的文件。
    
   - 散列方法的主要思想是根据结点的关键码值来确定其存储地址：以关键码值K为自变量，通过一定的函数关系h(K)(称为散列函数)，计算出对应的函数值来，把这个值解释为结点的存储地址，将结点存入到此存储单元中。检索时，用同样的方法计算地址，然后到相应的单元里去取要找的结点。通过散列方法可以对结点进行快速检索。散列（hash，也称“哈希”）是一种重要的存储方式，也是一种常见的检索方法。
    
   - 常见 Hash 算法有 MD5 和 SHA 系列，目前 MD5 和 SHA1 已经被破解，一般推荐至少使用 SHA2-256 算法。
    
   - 哈希碰撞
    
     输入数据长度不固定，而输出的哈希值却是固定长度的，这意味着哈希值是一个有限集合，而输入数据则可以是无穷多个，那么建立一对一关系明显是不现实的。所以“碰撞”是必然会发生的。
    
     - 

  4. **okhttp 异步请求，等待队列什么时候加入到正在执行的队列**
  
     取出等待队列中的 call，判断正在执行的 call 数量是否大于最大数 64，且每个 host 上 call 的数量是否大于 5，通过的话，即将待请求的 call 加入到 runningAsyncCalls 里，同时加入到 executableCalls，最后遍历 executableCalls，进行执行；

     执行 runningAsyncCalls.add(asyncCall) 的方法总过被四处调用：

     - enqueue() 异步请求
     - finished() 请求结束
     - maxRequests set方法
     - maxRequestsPerHost set 方法
  5. 图片压缩在边以前还是编译后
  
  6. **二分查找**

  7. 路由

  8. **轻量级锁、重量级锁**

     https://blog.csdn.net/choukekai/article/details/63688332

     - 轻量级锁的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。
     - synchronized 通过 Monitor 来实现线程同步，Monitor 是依赖于底层的操作系统的 Mutex Lock（互斥锁）来实现的线程同步。“<font color='red'>阻塞或唤醒一个 Java 线程需要操作系统切换 CPU 状态来完成，这种状态转换需要耗费处理器时间</font>”，这种依赖于操作系统 Mutex Lock 所实现的锁我们称之为“重量级锁”。
     - 一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。
     - 一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。
     - 轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。
9. **wait notify 在重入锁中对应哪些方法**
  
     newCondition()
  
   1. Object类中的wait()方法相当于Condition类中的await()方法。
     2. Object类中的wait(long timeout)方法相当于Condition类中的await(long time, TimeUnit unit)方法。
   3. Object类中的notify()方法相当于Condition类中的signal()方法。
     4. Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。
   5. lock和unlock对应于synchronized，只是更为灵活。
     6. tryLock尝试获取锁；tryLock（long）尝试一定时间内获取锁；

  10. **okhttp线程池最大数量**

      Int.MAX_VALUE，cacheThreadPool 类型，无核心线程，最大线程数不限，60秒超时

  11. **真正执行网络请求的是哪个拦截器**

      callServerInterceptor

  12. **CAS**

      CAS 全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent 包中的原子类就是通过 CAS 来实现了乐观锁。

      CAS 算法涉及到三个操作数：
  
      - 需要读写的内存值 V；
    - 进行比较的值 A；
      - 要写入的新值 B；
    
      
      当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值（“比较+更新“ 整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。

  

  

  

  

  

  

  映客直播

  1. **dialog 和 window**
  
     - Dialog 持有 Window，视图是通过 Window 呈现的，在 Dialog 的构造函数中 创建了 PhoneWindow 对象；
     - Dialog 设置布局是通过 mWindow#setContentView() 来实现的；
     - 在 Dialog 的 show() 方法中，通过 mWindow 后去 DecorView，然后调用 mWindowManager#addView(mDecor, layoutParams) 进行视图的添加；
    
     > 普通 Dialog 的创建需要传入 Activity 类型的上下文，Application 或 Service 类型的 context 会报错；这样做的好处是防止当你已经关闭页面了，或者已经打开其他app了，这个时候弹出一个操作弹窗，防止误操作。
     >
     > 有个 token 验证问题，Activity 重写了 getSystemService() 方法，返回了一个已经绑定了 token 的 windowManager，这个 token 是 Activity 创建的时候在 ActivityRecord 中生成的；
     >
     > 在 Activity#attach() 中调用 setWindowManager 时传入的；
     >
     > 在 Dialog 中调用 context.getSystemService()  时调用的是 Activity 已经重写的方法，返回的是带有 mToken 的 windowManager； 
  2. **Java 虚拟机栈中存的是什么**

     每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

     局部变量表存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）。

  3. **JPG 和 png 的区别**

      二者对比：

     - png有透明通道，而jpg没有
     - png是无损压缩的，而jpg是有损压缩，因此png中存储的信息会很多，体积自然就大了
     - 手机对png情有独钟，会对其进行硬件加速，所以同样一张背景图，png虽然体积大，但是加载速度

     

     综述：

     - 对于app包中的图片，我们都使用png格式的，而对于要从网络上加载的图片，考虑到流量以及下载上速度，则使用jpg格式的，因为它有较高的压缩率，体积更小。
     - 对于背景图、引导页，这种大尺寸的图片，我们还是倾向于jpg格式的，虽然加载慢一些吗，但是体积小，减少了包的体积
     - Google后来发布了一种新的图片格式，WebP，它的压缩率比jpg更好，已经在慢慢普及


  4. **OOM 发生在哪里**

     Java 内存区域中，只有 **程序计数器** 不会发生 OOM；其他 Java 虚拟机栈、本地方法栈、堆、方法区都会发生 OOM；

  5. **requestlayout() 和 invalidate() 的区别**

  6. **Bitmap 计算图片大小？Bitmap 存在哪儿？**

     - 一张图片（BitMap）占用的内存=图片长度 * 图片宽度 * 单位像素占用的字节数（注：图片长度和图片宽度的单位是像素）。

       - ALPHA_8：每个像素都需要1（8位）个字节的内存，只存储位图的透明度，没有颜色信息
       - ARGB_4444：A(Alpha)占4位的精度，R(Red)占4位的精度，G(Green)占4位的精度，B（Blue）占4位的精度，加起来一共是16位的精度，折合是2个字节，也就是一个像素占两个字节的内存，同时存储位图的透明度和颜色信息。不过由于该精度的位图质量较差，官方不推荐使用
       - ARGB_8888：这个类型的跟ARGB_4444的原理是一样的，只是A,R,G,B各占8个位的精度，所以一个像素占4个字节的内存。由于该类型的位图质量较好，官方特别推荐使用。但是，如果一个480*800的位图设置了此类型，那个它占用的内存空间是：480*800*4/(1024*1024)=1.5M
       - RGB_565：同理，R占5位精度，G占6位精度，B占5位精度，一共是16位精度，折合两个字节。这里注意的时，这个类型存储的只是颜色信息，没有透明度信息

     - 通过 BitmapFactory.Options 来缩放图片，主要用到 inSampleSize  参数，当为 2 时，其宽、高均为原来的 1/2，即 像素数为原来的 1/4；

     - 3.0~8.0之前存在Java 堆中，8.0之后存在 native 堆中。

       Fresco 大大减少了 OOM（在更底层的 Native 层对 OOM 进行处理，图片将不再占用 App 的内存）适用于高性能加载大量图片的场景。

  7. **哪些对象可以作为 GC root**
  
     GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。
     方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。

     - 虚拟机栈中引用的对象；

       虚拟机栈中的引用的对象可以作为GC Root。我们程序在虚拟机的栈中执行，每次函数调用调用都是一次入栈。在栈中包括局部变量表和操作数栈，局部变量表中的变量可能为引用类型(reference)，他们引用的对象即可作为GC Root。不过随着函数调用结束出栈，这些引用便会消失。

     - 方法区中静态属性引用的对象；

       简单的说就是我们在类中使用的static声明的引用类型字段，例如：
    
       ```java
       Class Dog {
         private static Object tail;
       } 
       ```
       
     - 方法区中常量引用的对象；
     
       简单的说就是我们在类中使用final声明的引用类型字段，例如：
     
       ```java
       Class Dog {
         private final Object tail;//常量声明需要初始化，也可以延迟到构造函数中初始化
       }
       ```
     
     - 本地方法栈中引用的对象；
     
       就是程序中native本地方法引用的对象。

8. **分代收集**
  
   - 新生代对象存活率较低，使用复制算法
   - 老年代对象存活率较高，使用标记-清除 或 标记-整理 算法

  9. **GC 什么时候发生**
  
     GC又分为minor GC 和 Full Gc(也称为Major GC)。Java 堆内存分为新生代和老年代，新生代中又分为1个Eden区域 和两个 Survivor区域。
     
     那么对于 Minor GC 的触发条件：大多数情况下，直接在 Eden 区中进行分配。如果 Eden区域没有足够的空间，那么就会发起一次 Minor GC；对于 Full GC（Major GC）的触发条件：也是如果老年代没有足够空间的话，那么就会进行一次 Full GC。
     
     Ps：上面所说的只是一般情况下，实际上，需要考虑一个空间分配担保的问题。。。
     
        - 对什么东西
     
          主要根据可达性分析算法，如果一个对象不可达，那么就是可以回收的；如果一个对象可达，那么这个对象就不可以回收。对于可达性分析算法，它是通过一系列称为“GC Roots” 的对象作为起始点，当一个对象到 GC Roots 没有任何引用链相接的时候，那么这个对象就是不可达，就可以被回收。
     
          这个GC Root 对象可以是一些静态的对象，Java方法的local变量或参数， native 方法引用的对象，活着的线程。
     
        - 做了哪些事
     
          主要做了清理对象，整理内存的工作。Java堆分为新生代和老年代，采用了不同的回收方式。例如新生代采用了复制算法，老年代采用了标记整理法。在新生代中，分为一个Eden 区域和两个Survivor区域，真正使用的是一个Eden区域和一个Survivor区域，GC的时候，会把存活的对象放入到另外一个Survivor区域中，然后再把这个Eden区域和Survivor区域清除。那么对于老年代，采用的是标记整理法，首先标记出存活的对象，然后再移动到一端。这样也有利于减少内存碎片。

10. **okhttp 连接复用**
  
11. **synchronized、volatile**
  
12. **LayoutInflater.inflate() 中 attachToRoot 的作用？RecyclerView parent不为空？parent true，false 的区别？**
  
    - attachToRoot 一个布尔值，表示是否将 view 添加到 parent 上；
        - `attachToRoot`如果为`true`就把布局添加到`ViewGroup`中；
      - 若为`false`则只采用`ViewGroup`的`LayoutParams`作为测量的依据却不直接添加到`ViewGroup`中。
      - attach不能设置为true，否则inflate返回的布局为RecyclerView，而不是我们希望返回的自定义布局对象

  13. **线程池原理**

  14. **MVP基类是怎么封装处理的**

  15. **动画**

  16. **多进程**

      AndroidManifest.xml中配置 android:process=":remote"，冒号+进程名，或者全包名
  
17. **sp是线程安全的吗？commit和apply的区别？**
  
18. **webView碰到的问题？内存泄漏？**
  
    WebView内存泄露的主要原因是引用了 Activity/Fragment 的 Context,加之 WebView 本身的设计问题,导致 Activity/Fragment 无法被即时释放,既然 WebView 无法即时释放 Context,那就让它引用全局的 Context 就好了。
  
19. **方法参数中的 final**
  
    防止参数被修改，基本数据类型的值不能修改，引用类型的引用指向不能改，但是可以改其中的属性值；
  
20. **线程安全的容器类**
  
      - Vector
    
        使用了synchronized

      - HashTable

        使用了synchronized

      - ConcurrentHashMap

        - 1.8之前 ReentrantLock + Segment + HashEntry
        - 1.8及之后 CAS + synchronized + Node + 红黑树
  
    List 线程安全的方法：
  
    1. vector 在add方法上加上synchronized锁
      2. Collections的静态方法synchronizedList(List< T> list)
    3. copyonwritearraylist写时复制的思想
  
21. **ANR**
  
    ANR（Application Not Responding）的监测原理本质上是消息机制，设定一个delay消息，超时未被移除则触发ANR。具体逻辑处理都在system server端，包括发送超时消息，移除超时消息，处理超时消息以及ANR弹框展示等；对于app而言，触发ANR的条件是主线程阻塞。
  
    1. Service ANR：前台20s，后台200s；startForeground超时10s
      2. Broadcast ANR：前台10s，后台60s
    3. Input ANR：按键或触摸事件在5s内无响应
      4. ContentProvider ANR：10s，少见

  22. **View 的绘制帧率**

      60FPS，即每帧绘制时间不超过16ms

  23. **Java 内存运行时数据区域？堆、栈？**

  24. **异常信息怎样打印出来的？**
  
      
  
  25. **apk 是什么格式的文件**
  
      zip 格式文件













美图

1. **calladapter 怎样将 call 转换成 observable**
  
   - 首先这是通过 Retrofit 适配器模式完成的；
     - 在构建 Retrofit 对象时，可以通过 Builder 的方法 addCallAdapterFactory 添加适配器；
     - 在调用 ApiService 接口中的方法时，由于动态代理会走到 Retrofit#create() 的 invoke() 回调中；
     - loadServiceMethod(method) 会对接口中定义的方法进行解析，注解、参数、返回值类型，这里 返回值类型是 Observable；
   - 取得返回值类型后，会通过 createCallAdapter() 创建 CallAdapter 实例，这里调用的是 Retrofit 中的方法，通过找到之前设置 RxJavaCallAdapterFactory 实例，调用其 get() 方法，创建 RxJava2CallAdapter 实例；
     - 得到 callAdapter 实例后，在 Retrofit#create()#invoke() 中，调用 loadServiceMethod.invoke()；
   - HttpServiceMethod#invoke() 中会先构建一个 OkHttpCall，然后调用 adapt() 方法，即适配器模式，会调用 callAdapter 的 adapt() 方法；
     - 在 RxJava2CallAdapter#adapt() 中会将 Call 转换成 Observable 类型；
  
  2. **hashmap 放5个数据，初始值设置多少合适**

     initialCapacity = (需要存储的元素个数 / 负载因子) + 1，负载因子 0.75

     且应该为 2 的 n 次幂

  3. **ConcurrentHashMap 怎样实现线程安全的**
  
     - JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。

     - JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结

       点）（实现 Map.Entry）。锁粒度降低了。

  4. **播放器，电话进来，怎样停止播放，怎样监听**
  
     - 播放一般会启动一个 Service，在 Service 的 onCreate() 中通过 TelephonyManager 设置 listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);
     - 在 mPhoneStateListener  的回调中，根据不同状态进行暂停、恢复；
     - 在 Service 的 onDestroy() 中删除、释放；

  5. **TextView 怎样对 Drawable 进行缩放动画，比如分享文字和分享图标，让图标缩放**

     - 使用属性动画，对某个属性进行操作；
     - 先获取一个 drawable，然后 setCompoundDrawables() 设置给 TextView；
     - 然后属性动画对这个 drawable 进行操作；
  6. **自定义View 怎样绘制，设置圆角**

     https://blog.csdn.net/f409031mn/article/details/87211850

     - canvas.clipPath()，canvas.drawBitmap()
     - PorterDuffXfermode 使用图像混合模式，设置画笔，canvas.drawBitmap()
     - BitmapShader 设置画笔，canvas.drawCircle()

  7. **fragment 回退栈，怎样监听返回**

     https://blog.csdn.net/harvic880925/article/details/45013501#

     - 在 Fragment 中定义 onBackPressed() 方法，处理逻辑，返回 true or  false；
     - 定义接口，声明一个方法 setSelectedFragment()，将 Fragment 的实例传入；
     - 让 Activity 实现接口，重写方法，接收 Fragment 的实例；
     - 在 Fragment 的 onAttach() 及其之后的生命周期中将 getActivity() 转换成接口类型，并调用 setSelectedFragment(this) 将自己传出去；
     - 在 Activity 的 onBackPressed() 中处理逻辑；

  

  

  

  玩吧

  1. **ThreadLocalMap 结构，怎样存储 Looper 的？**
  
     - ThreadLocalMap 是线程内部的数据存储类，在指定线程中存储的数据，只能在指定线程中获取；
     - 有个内部类，ThreadLocalMap，主体结构是 Entry 数组，在 ThreadLocalMap 构造函数中初始化，初始长度为 16，扩容是扩大为原来的 2 倍；
     - set() 方法，先获取当前线程 thread 对象，Thread 中有一个属性 threadLocals，即 ThreadLocalMap；获取 threadLocalMap 对象，为空就创建，然后将 value 存到 map 中，key 为 this，即使 ThreadLocal 本身；
2. **synchronized 和 Lock 的区别？效率问题？**
  
  3. **lock 的使用场景**
  
  4. **自定义 View 的流程**

  5. **onSizeChanged 什么情况下会调用**

     当视图大小发生变化的时候会调用，具体看源码是在layout的过程当中出发的，在layout方法中会调用setFrame方法，在setFrame方法中又调用了sizeChange，在该方法里面回调了onSizeChanged，而后才回去回调onLayout过程。

  6. **hashmap 怎样通过哈希值得到数组位置**

     index = (n - 1) & hash

  7. **==和equals区别**
  
  8. **onNewIntent() 什么时候会被调用？**

     - singleTop 在栈顶，二次进入时
     - singleTask、singleInstance
     - 在栈顶，二次进入，onNewIntent()、onResume()
     - 不在栈顶，二次进入，onNewIntent()、onRestart()、onStart()

  9. **常用布局？常用布局效率问题？**
  - RelativeLayout会让子View调用2次onMeasure，LinearLayout 在有weight时，也会调用子View2次onMeasure
     - RelativeLayout的子View如果高度和RelativeLayout不同，则会引发效率问题，当子View很复杂时，这个问题会更加严重。如果可以，尽量使用padding代替margin。
     - 在不影响层级深度的情况下,使用LinearLayout和FrameLayout而不是RelativeLayout。
     - FrameLayout 性能最好，可以通过 android:layout_gravity 来摆放子布局。
10. **idlehandler**



爱奇艺

1. **Looper#quit() 做了哪些操作**
  
   - 调用了 MessageQueue 中的 quit(boolean safe)，用来退出；
   - 是否安全退出的区别在于，是直接退出，还是将消息执行完后再退出；
   - 会回收 message，将其中的属性置为 null；
   - 主线程不能退出；

  2. **hashmap 哈希值 异或运算的目的**

     为了散列更均匀，key的哈希值与其右移16位后进行异或运算，右移16位，高位补0；
  
     - 与运算，1和1才得1，其它为0，结果趋向于0；
     - 或运算，0和0得0，其它为1，结果趋向于1；
     - 异或运算，1和0才得1，相同得0，结果更均匀，异或运算能更好的保留各部分的特征；
     
     > 右移原因：当数组的长度很短时，**只有低位数的hashcode值能参与运算。而让高16位参与运算可以更好的均匀散列，减少碰撞，进一步降低hash冲突的几率**。**并且使得高16位和低16位的信息都被保留了。**
    3. **ConcurrentHashMap 线程安全的原理？1.6和之前的有什么区别？**
       - JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。
       - JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结点）（实现 Map.Entry）。锁粒度降低了。

  4. **设计模式？策略模式？**

  5. **线程池的种类？分别的作用？**

     - FixedThreadPool

       线程数量固定的线程池，只有核心线程，没有超时机制，当线程处于空闲状态时，不会被回收，能更快的响应外界的请求；

     - CachedThreadPool
     
       - 线程数量不固定的线程池，最大线程数为 Integer.MAX_VALUE，没有核心线程，60s 超时，超过 60s 闲置线程就会被回收。
       - 当整个线程池都处于闲置状态时，线程池中的线程都会超时而被停止，此时是没有线程的，几乎不占用任何系统资源。
       - 适合执行大量的耗时较少的任务。
       - OkHttp 中 Dispatcher 中维护的线程池就是这种类型；
     
     - ScheduledThreadPool
     
       - 核心线程数量固定，非核心线程数没有限制；
       - 超时时间为 0，当非核心线程闲置时会被立即回收；
       - 主要用于执行定时任务和具有固定周期的重复任务；
     
     - SingleThreadExecutor
     
       - 内部只有一个核心线程，确保所有的任务都在同一个线程中按顺序执行；
       - 意义在于统一所有的外界任务到一个线程池中，这使得在这些任务之间不需要处理线程同步问题；
  
  6. **单链表环长？**
  
     快慢指针，相等时，再次设置，再相等时及环长。

  7. **一个数组最大子序列的和？**

     ```java
      /*
     假设sum<=0，那么后面的子序列肯定不包含目前的子序列，所以令sum = num；
      如果sum > 0对于后面的子序列是有好处的。res = Math.max(res, sum)保证可以找到最大的子序和。
     int[] nums = {-2, 1, -3, 4, -1, 2, 1, -5, 4};
      res = 6
     */
      private static int maxSubArray(int[] nums) {
         int res = nums[0];
       int sum = 0;
         for (int num : nums) {
           if (sum > 0) {
                 sum += num;
             } else {
               sum = num;
             }
           res = Math.max(res, sum);
         }
       return res;
     }
     ```

8. **如果 hashmap 初始长度为1000，插入1001条数据，会触发扩容吗？**
  
   当HashMap中的元素个数超过`capacity(数组长度默认16) * loadFactor(负载因子默认0.75`时，就会进行数组扩容
  
9. **最大公约数?**

   - 辗转相除法，递归 ，两个正整数a和b（a>b），它们的最大公约数等于a除以b的余数c和b之间的最大公约数。

     当两个整数较大时，做a%b取模运算的性能会比较差。

   - 更相减损术，两个正整数a和b（a>b），它们的最大公约数等于a-b的差值c和较小数b的最大公约数。

     - 避免了大整数取模可能出现的性能问题。
     - 更相减损术依靠两数求差的方式来递归，运算次数肯定远大于辗转相除法的取模方式，当两个相差比较大的数进行求公约数时，递归次数会很多；

     - 把辗转相除法和更相减损术的优势结合起来，在更相减损术的基础上使用移位运算。

  10. **RN 与 原生交互，上下文怎么传?**

  

  

  

  

  

  

  滴滴

  1. **自己实现图片加载框架**
     - 异步加载：线程池
     - 切换线程：Handler
     - 缓存：LruCache、DiskLruCache
     - 防止 OOM：软引用、LruCache、图片压缩、Bitmap 像素存储位置
     - 内存泄漏：注意 ImageView 的正确引用、生命周期管理
     - 列表滑动加载问题：加载错乱、队满任务过多问题
     - 加载动画
  2. **内存缓存 LruCache**
     - LruCache 采用**最近最少使用算法**，设定一个缓存大小，当缓存达到这个大小之后，会将最老的数据移除，避免图片占用内存过大导致OOM。
     - LruCache 内部用LinkHashMap存取数据，在双向链表保证数据新旧顺序的前提下，设置一个最大内存，往里面put数据的时候，当数据达到最大内存的时候，将最老的数据移除掉，保证内存不超过设定的最大值。
     - LinkHashMap 继承HashMap，在 HashMap的基础上，新增了双向链表结构，每次访问数据的时候，会更新被访问的数据的链表指针，具体就是先在链表中删除该节点，然后添加到链表头header之前，这样就保证了链表头header节点之前的数据都是最近访问的（从链表中删除并不是真的删除数据，只是移动链表指针，数据本身在map中的位置是不变的）。
  3. **怎样限制一个账号一小时内登录五次**
  4. **设计模式**
  5. **一个接口响应很慢怎么去定位**
     - okhttp有超时机制，用 Retrofit 和 RxJava 请求接口，超时会走 onError 回调，可以在 onError() 中打断点，查看哪个接口报错；
     - 用抓包工具，比如 Charles 可以查看一个接口的响应时间；

  

  

  