## 2022年记录



白龙马云行科技

- ArrayMap 原理？什么情况下使用？和 HashMap 的时间复杂度？

  > 原理：
  >
  > - 两个数组，一个数组存储 key 的 hash 值，一个数组存储 key 和 value；
  > - 查找采用二分查找；
  > - ArrayMap每次扩容的时候，如果size长度大于8时申请size*1.5个长度，大于4小于8时申请8个，小于4时申请4个，扩容频率会更高；
  > - 扩容效率高，采用 System.arraycopy()；
  > - 能够重复的利用因为数据扩容而遗留下来的数组空间，方便下一个ArrayMap的使用；
  >
  > 使用场景：
  >
  > 数据量少的时候
  >
  > 时间复杂度：
  >
  > - HashMap O(1)、O(logn)、O(n)
  > - ArrayMap 最好O(logn) 最坏O(n) 平均 O(logn)

- 红黑树

  > 是一种自平衡二叉查找树；
  >
  > HashMap 使用红黑树的原因：
  >
  > 红黑树牺牲了一些查找性能 但其本身并不是完全平衡的二叉树。因此插入删除操作效率略高于AVL树。
  > AVL树用于自平衡的计算牺牲了插入删除性能，但是因为最多只有一层的高度差，查询效率会高一些。

- Retrofit 原理

  > 通过动态代理的方式，将接口转化成 Call，通过 OkHttp 进行请求，在 invoke() 中解析方法注解、方法参数、返回值等，通过网络请求适配器，数据转换器，将请求到的数组最终转换成我们想要的类型；

- 动态代理模式？建造者模式？

- Handler 是怎样切换线程的？切换的节点？Handler、Looper、MessageQueue 之间的关系？延迟消息怎样实现的？怎样知道时间到了？ThreadLocal 结构？IdleHandler 的用途？

  > **IdleHandler 有什么用？**
  >
  > 1. IdleHandler 是 Handler 提供的一种在消息队列空闲时，执行任务的时机；
  > 2. 当 MessageQueue 当前没有立即需要处理的消息时，会执行 IdleHandler；
  >
  > **当 mIdleHanders 一直不为空时，为什么不会进入死循环？**
  >
  > 1. 只有在 pendingIdleHandlerCount 为 -1 时，才会尝试执行 mIdleHander；
  > 2. pendingIdlehanderCount 在 next() 中初始时为 -1，执行一遍后被置为 0，所以不会重复执行；
  >
  > **是否可以将一些不重要的启动服务，搬移到 IdleHandler 中去处理？**
  >
  > 1. 不建议；
  > 2. IdleHandler 的处理时机不可控，如果 MessageQueue 一直有待处理的消息，那么 IdleHander 的执行时机会很靠后；
  >
  > **使用场景**：
  >
  > - Android Framework层的GC场景就使用了这个机制，只有当cpu空闲的时候才会去GC。
  > - 内存泄漏检测库LeakCanary，其进行内存泄漏检测并不是 onDestry 方法执行完成后就进行垃圾回收和一些分析的，而是**利用 IdleHandler 在空闲的时候进行这些操作的，尽量不去影响主线程的操作**。
  > - 想要在一个 View 绘制完成之后添加其他依赖于这个 View 的 View，当然这个用View.post()也能实现。
  > - 发送一个返回 true 的 IdleHandler，在里面让某个 View 不停闪烁，这样当用户发呆时就可以诱导用户点击这个View

- Dagger2

  > Dagger2 是一款依赖注入框架，基于 Java 注解，采用   annotationProcessor(注解处理器) 在项目编译时动态生成依赖注入需要的 Java 代码，然后我们在合适的位置手动完成最终的依赖注入（Dagger1 采用的是反射）。
  >
  > 主要作用就是解耦,降低代码的耦合度,依赖注入是面向对象的一种设计模式,其目的就是为了降低程序耦合度。 

- RxJava 是怎样实现线程切换的？

  > **observeOn() 的线程切换原理**：
  >
  > 1. 子线程切换主线程：给主线程所在的Handler发消息，然后就把逻辑切换过去了。
  > 2. 主线程切换子线程：把任务放到线程池中执行就能把执行逻辑切换到子线程
  > 3. 子线程切换子线程：把任务分别扔进两个线程就行了。

- 自定义View flowlayout  怎样实现标签换行的？
  https://www.yisu.com/zixun/203354.html

  > 我们需要去自定义一个ViewGroup，然后在onMeasure方法中需要考虑当warp_content模式时需要自己计算FlowLayout所占的宽高，它所占的宽是最长的那一行的宽度，所占的高则就是所有行累加起来。
  > 然后在onLayout方法中主要是确定好每个View要摆放的起始坐标（left,top）。
  > 每摆放一个child后，累加已经占用行宽，如果下一个child占的宽度大于剩余的行宽，则另起一行。其次我们每起一行都要累加下当前高度，这样我们才好确定下一行的摆放位置应该从哪个top坐标开始，然后一一摆放
  >
  > 需要考虑的基本情况：
  >
  > FlowLayout应该支持warp_content
  > FlowLayout应该支持padding
  > child应该支持margin
  > 当child的getVisibility() ==GONE的时候，不应该参与计算
  > 支持设定行间距
  >
  > 原文链接：https://blog.csdn.net/lc_miao/article/details/88580753

- webview 怎样实现 JS 与 android 互调的？

- 应用市场提示没有同意隐私协议就获取了用户的 MAC地址，怎样定位到？

  > VirtualXposed

- 怎样统计 App 内 所有 Button 的点击？Bugly 是怎样实现统计的？

- 性能优化





七人科技

- JsBridge 中 js 文件的作用？

- webview 注入对象的漏洞

  > webView的js对象注入的方式非常简单，可是为什么建议使用jsBridge呢？因为该方式存在安全隐患。上述提到本地方法加了@JavascriptInterface注解才能被h5调用，这个是在Android4.2之后加的，是为了避免恶意js代码获取本地信息，如SD卡中的用户信息。但是@JavascriptInterface无法兼容4.2以前的版本，所以4.2之前的系统都有被随时侵入获取信息的可能。
  >
  > 那么js是如何做到的？答案是反射。4.2之前没有加@JavascriptInterface的情况下，js是可以通过你注入的js对象(addJavascriptInterface的第一个参数)直接拿到getClass(这个方法是基类Object的方法)，然后再拿到Runtime对象用来执行一些命令。
  >
  > 解决方案：
  >
  > - 在Android 4.2版本之前采用**拦截prompt（）**进行漏洞修复。
  > - Google 在Android 4.2 版本中规定对被调用的函数以 `@JavascriptInterface`进行注解从而避免漏洞攻击。

- 写一个方法 findViewById(View view, int id) 有返回 view，没有返回 null；

- 合并两个有序数组？

  > 两个指针，while 循环



伊对

- ArrayList 实现？扩容机制？加载因子？

  数组实现，没有加载因子，当数组长度不够时，以1.5倍进行扩容。

- wait 和 sleep

  - sleep方法是Thread类中静态方法，wait方法是Object中的实例方法。

  - sleep方法不会释放锁，而wait方法释放了锁，使得其他线程可以使用同步方法或代码块。

    sleep方法不让出系统资源，wait方法是进入线程等待池等待，让出系统资源，其他线程可以占用CPU。

  - sleep方法不需要被唤醒，到时之后自动退出阻塞或者调用 `interrupt()` 打断，wait方法需要其他线程调用对象的`notify()`或者`notifyAll()`

  - sleep方法在任何地方都可以使用，但是要 try catch，wait方法必须在同步方法或者同步代码块中使用

- Fragment 生命周期

  onAttach()

  onCreate()

  onCreateView()

  onActivityCreated()

  onStart()

  onResume()

  onPause()

  onStop()

  onDestroyView()

  onDestroy()

  ondetach()

- 设计模式

- 自定义控件

- 扔石子水波纹效果

- 直播间一万条消息，页面怎么处理

- inflate 布局的过程

- 组件化开发



思图场景

- 常用的布局？怎么选取布局？启动页用什么布局？
- 如何优化启动速度？
- 常用的标签？merge、include、ViewStub？
- ViewStub 是怎样刚开始不参与绘制的？
- Handler 是怎样进行线程间通信的？