Java
一、垃圾回收机制
    四种回收算法：
        1、标记-清除算法
        流程可简述为 两步：

        1）、标记所有需要回收的对象。
        2）、统一回收所有被标记的对象。

        优点
        实现比较简单。
        缺点
        1）、标记、清除效率不高。
        2）、产生大量内存碎片。

        2、复制算法
        流程可简述为 三步：
        1）、将内存划分为大小相等的两块。
        2）、一块内存用完之后复制存活对象到另一块。
        3）、清理另一块内存。

        优点
        实现简单，运行高效，每次仅需遍历标记一半的内存区域。
        缺点
        会浪费一半的空间，代价大。

        3、标记-整理算法
        流程可简述为 三步：

        1）、标记过程与 标记-清除算法 一样。
        2）、存活对象往一端进行移动。
        3）、清理其余内存。

        优点
        1）、避免 标记-清除 导致的内存碎片。
        2）、避免复制算法的空间浪费。

        4、分代收集算法
        现在 主流的虚拟机 一般用的比较多的还是分代收集算法，它具有如下 特点：

        1）、结合多种算法优势。
        2）、新生代对象存活率低，使用 复制算法。
        3）、老年代对象存活率高，使用 标记-整理算法。

    内存分配及回收机制
        大多数情况，对象在新生代Eden中分配。当Eden区没有足够空间进行分配时，虚拟机将发生一次 Minor GC。



二、jvm数据区域？都存储哪些数据？内存泄漏发生在哪些区域？
    程序计数器(Program Counter Register)
    一块较小的内存空间，它是当前线程所执行的字节码的行号指示器，字节码解释器工作时通过改变该计数器的值来选择下一条需要执行的字节码指令，
    分支、跳转、循环等基础功能都要依赖它来实现。Java 虚拟机的多线程是通过轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，
    一个处理器都只会执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的的程序计数器，各线程间的计数器互不影响，
    因此该区域是线程私有的。当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址；当线程在执行的是Native方法时，
    该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。

    Java虚拟机栈（Java Virtual Machine Stacks）
    该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧，
    栈它是用于支持续虚拟机进行方法调用和方法执行的数据结构。对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，
    称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。
    栈帧用于存储局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，
    栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。
    因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

    每当有线程被创建的时候，JVM就需要为其在内存中分配虚拟机栈和本地方法栈来记录调用方法的内容，
    分配程序计数器记录指令执行的位置，这样的内存消耗就是创建线程的内存代价。

    本地方法栈（Native Method Stacks）
    该区域与虚拟机栈所发挥的作用非常相似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统（Native）方法服务。

    Java堆（Java Heap）
    Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这类分配内存。
    Java Heap是垃圾收集器管理的主要区域，因此很多时候也被称为“GC堆”。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，
    所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间。
    从内存分配的角度来看，线程共享的 Java 堆中可能划分出多个线程私有的分配缓冲区。
    根据Java虚拟机规范的规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存可分配时，
    并且堆也无法扩展时，将会抛出OutOfMemoryError异常。

    方法区（Method Area）
    方法区也是各个线程共享的内存区域，它用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
    根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出 OOM 异常。

    运行时常量池（Runtime Constant Pool）
    运行时常量池是方法区的一部分，Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Class文件常量池），
    用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
    运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，
    也就是并非预置入Class文件中的常量池的内容才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的是String类的intern（）方法。
    既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时，将抛出 OOM 异常。

    除了程序计数器外都可能会内存溢出


    内存区域类型
    1.寄存器：最快的存储区, 由编译器根据需求进行分配,我们在程序中无法控制；
    1. 栈：存放基本类型的变量数据和对象的引用，但对象本身不存放在栈中，而是存放在堆（new 出来的对象）或者常量池中(对象可能在常量池里)（字符串常量对象存放在常量池中。）；
    2. 堆：存放所有new出来的对象；
    3. 静态域：存放静态成员（static定义的）；
    4. 常量池：存放字符串常量和基本类型常量（public static final）。有时，在嵌入式系统中，常量本身会和其他部分分割离开(由于版权等其他原因)，所以在这种情况下，可以选择将其放在ROM中 ；
    5. 非RAM存储：硬盘等永久存储空间


三、四种引用？软引用和弱引用的区别？使用场景？
    强引用：新建一个对象时就创建了一个具有强引用的对象，如果一个对象具有强引用，垃圾收集器就绝对不会回收它，宁愿抛出OOM。
    软引用：描述一些有用但不是必须的对象，如果一个对象只具有软引用，当内存不够时，会回收这些对象的内存，回收后如果还是没有足够内存，就会抛出OOM。
    弱引用：弱引用比软引用具有更短的生命周期，垃圾收集器一旦发现了只具有弱引用的对象，不管当前内存是否足够，都会回收它的内存。
    虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，就和没任何引用一样，在任何时候都可能被垃圾收集器回收。

    使用场景：
        软引用：比如网页缓存、图片缓存等。
        弱引用：比如Handler中使用外部类Activity的成员变量
               BasePresenter中 弱引用的方式去保存这个View的对象引用,减少内存泄露的可能性。
        /**
         * 声明一个静态的Handler内部类，并持有外部类的弱引用
         */
        private static class MyHandler extends Handler{
            private final WeakReference<HandlerActivity> mActivity;

            private MyHandler(HandlerActivity mActivity) {
                this.mActivity = new WeakReference<HandlerActivity>(mActivity);
            }

            @Override
            public void handleMessage(Message msg) {
                super.handleMessage(msg);
                HandlerActivity activity = mActivity.get();
                if (activity != null){
                    // ....

                }
            }
        }

四、类加载机制
    1、简述双亲委派模式， 为什么使用这种模式？
        ①类加载器查找Class所采用的是双亲委托模式
        首先判断该Class是否已经被加载，如果没有则不是自身去查找而是委托给父加载器进行查找，
        这样依次进行递归，直到委托到最顶层的BoostStrapClassLoader，如果找到了就返回，
        如果没找到，则继续依次向下查找，如果还没找到则最后会交由自身去查找。

        ②为什么使用这种改模式？
        主要是为了安全性，避免用户自己编写的类动态替换JAVA的一些核心类，比如String。
        同时也避免了类的重复加载，因为JVM中区分不同类，不仅仅是根据类名，相同的class文件被不同的ClassLoader加载就是不同的两个类。
        保证加载的类的唯一性，一是完整类文件名称，二是加载类的ClassLoader的实例

    2、类加载的过程：
         加载
            查找并加载class文件
         验证
            确保被导入类型的正确性
         准备
            为类的静态字段分配字段，并用默认值初始化这些字段
         解析
            虚拟机将常量池内的符号引用替换为直接引用
         初始化
            将类变量初始化为正确初始值

    3、Class文件
        Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序准确地排列在Class文件中，中间没有任何分隔符。
        当遇到8位字节以上的数据时，就按照高位在前的方式（最高位字节在地址最低位、最低位字节在地址最高位的顺序储存）分割成多个8位字节储存。

        Class文件格式采用一种类似于C语言结构体的伪结构来储存数据的，这种伪结构有两种数据类型：无符号数和表。
        魔数
        Class文件的版本号
        常量池
        访问标志（2字节）
        类索引、父类索引和接口索引集合
        字段表集合
        方法表集合
        属性表集合


五、synchronized、ReentrantLock、volatile
1、synchronized修饰静态方法和普通方法有什么区别？
      synchronized
      Java中的关键字，用来实现多线程下的同步机制,避免多个线程的资源访问造成的混乱。
      java中每个对象内部都有一个锁,如果一个方法使用 synchronized关键字修饰，java便会把这个方法保护起来。
      在其中一个线程释放锁之前,别的线程在调用该同步方法时，会被阻塞。

      synchronized修饰普通方法时,使用的锁是对象的锁。
          class A {
              public synchronized void a() {
              }
              public synchronized void b() {
              }
          }
          然后创建两个对象
          A a1 = new A();
          A a2 = new A();
          然后在两个线程中并发访问如下代码：
          Thread1                       Thread2
          a1.a();                       a2.a();
          如果创建两个对象，并在两个线程中访问同步方法，此时不能保证同步，因为两个对象它们有各自的锁。

      synchronized修饰静态方法时,使用的锁是类对象的锁,Class。
          如果A的定义是下面这种呢？
          class A {
              public static synchronized void a() {
              }
              public static synchronized void b() {
              }
          }
          可以保证同步
          原因:
          对于static 修饰的方法，它的锁是类对象 即 Xxx.class 即我们调用方法时 都是A.a()
          由于使用的是同一个锁。线程1Thread1 调用时，线程2Thread2 会被阻塞。 所以可以保证同步

      synchronized修饰的代码块 使用的锁是对象锁。

2、synchronized和ReentrantLock的区别？使用场景？
      1.它们都是加锁方式同步；
      2.都是重入锁；
      3.阻塞式的同步；

      一个最主要的就是ReentrantLock还可以实现公平锁机制。什么叫公平锁呢？
      也就是在锁上等待时间最长的线程将获得锁的使用权。通俗的理解就是谁排队时间最长谁先执行获取锁。

      原始构成
          它是java语言的关键字，是原生语法层面的互斥，需要jvm实现
          它是JDK 1.5之后提供的API层面的互斥锁类
      实现
          通过JVM加锁解锁
          api层面的加锁解锁，需要手动释放锁。
      代码编写
          采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用，更安全;
          而ReentrantLock则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。需要lock()和unlock()方法配合try/finally语句块来完成;
      灵活性
          锁的范围是整个方法或synchronized块部分
          Lock因为是方法调用，可以跨方法，灵活性更大
      等待可中断
          不可中断，除非抛出异常(释放锁方式：
              1.代码执行完，正常释放锁；
              2.抛出异常，由JVM退出等待)

           持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待,(方法：
               1.设置超时方法 tryLock(long timeout, TimeUnit unit)，时间过了就放弃等待；
               2.lockInterruptibly()放代码块中，调用interrupt()方法可中断，而synchronized不行)
      是否公平锁
          非公平锁
          两者都可以，默认公平锁，构造器可以传入boolean值，true为公平锁，false为非公平锁，
      便利性
          Synchronized的使用比较方便简洁，由编译器去保证锁的加锁和释放
          需要手工声明来加锁和释放锁，

      使用场景：
      资源竞争不是很激烈的情况下，偶尔会有同步的情形下，synchronized是很合适的。
      原因在于，编译程序通常会尽可能的进行优化synchronize，另外可读性非常好

      ReentrantLock提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。
      在资源竞争不激烈的情形下，性能稍微比synchronized差点点。
      但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。

3、volatile的作用，单例双重锁中 怎么使用，为什么？
      保证可见性、有序性，一个线程中修改了变量的值，在另一个线程中立即可见，禁止指令重排。

      volatile无法保证操作的原子性，使用volatile必须具备以下两个条件：
      ①对变量的写操作不会依赖于当前值。
      ②该变量没有包含在具有其它变量的不变式中。

      DCL失效，因为 sInstance = new Singleton() 不是原子操作，对象分配内存，构造函数初始化成员变量，将对象指向内存地址，顺序可能会倒，
      如果在分配内存、指向地址后，还没初始化成员变量，这时另一个线程进来，对象已经不为空，但是拿到的数据会有问题，此时对象应该用volatile修饰

      第一次判断是为了避免不必要的同步，第二次判断是为了对象为空时创建实例

      volatile是怎样保证顺序执行的？
          volatile变量写操作相当于释放锁,读操作相当于获得锁---JVM通过在volatile变量写之前插入释放屏障,在读之后插入获取屏障.
          这种成对的释放屏障和获取屏障保证了volatile的有序性.
          同样的,JVM在volatile变量写操作之后插入存储屏障,在读操作之前插入加载屏障,保证volatile变量的可见性

          首先一个变量被volatile关键字修饰之后有两个作用：
          （1）对于写操作：对变量更改完之后，要立刻写回到主存中。
          （2）对于读操作：对变量读取的时候，要从主存中读，而不是缓存。

          内存屏障保证了volatile的有序性。

4、原子性？怎样保证原子性？
    解决办法可以有如下三种：
        synchronized同步代码块
            public static synchronized void plusAndPlus() {
                var++;
            }
        cas原子类工具
            private static AtomicInteger var = new AtomicInteger(0);
            public static synchronized void plusAndPlus() {
                var.getAndIncrement();
            }
        lock锁机制

        什么是CAS? CAS:Compare and Swap,即比较再交换。

5、线程的几种状态？
    • New(新创建）
        当用 new 操作符创建一个新线程时，如newThread(r)，该线程还没有开始运行。
        这意味着它的状态是new。当一个线程处于新创建状态时，程序还没有开始运行线程中的代码。
        在线程运行之前还有一些基础工作要做。
    • Runnable(可运行）
        一旦调用 start 方法，线程处于runnable状态。一个可运行的线桿可能正在运行也可能没有运行，
        这取决于操作系统给线程提供运行的时间。
    • Blocked(被阻塞）
        当线程处于被阻塞或等待状态时，它暂时不活动。它不运行任何代码且消耗最少的资源，直到线程调度器重新激活它。
        ①当一个线程试图获取一个内部的对象锁，而该锁被其它线程持有，则该线程进入阻塞状态。

    • Waiting(等待）
        线程暂时不动，并且不运行任何代码，这消耗最少的资源，直到线程调度器重新激活它。
        当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。
        在调用Object.wait方法或Thread.join方法，或者是等待java.util.concurrent库中的Lock或Condition时，就会出现这种情况。
    • Timed waiting(计时等待）
        它可以在指定的时间自行返回
        带有超时参数的方法有
        Thread.sleep和Object.wait、Thread.join、Lock,tryLock以及Condition.await的计时版。
    • Terminated(被终止）
        • 因为 run 方法正常退出而自然死亡。
        • 因为一个没有捕获的异常终止了run方法而意外死亡。



    相关关键字
    Thread
        sleep() 方法的作用是在指定的毫秒数内让当前“正在执行的线程”休眠（暂停执行）

    1、synchronized与wait，notify& ReentrantLock与await，signalAll
    wait()和notify()
    对象的wait()是让当前线程释放该对象Monitor锁并且进入访问该对象的等待队列，当前线程会进入挂起状态，等待操作系统唤起(notify)
    挂起的线程重新获取对该对象的访问锁才能进入运行状态。因为自身已经挂起，所以已经挂起的线程无法唤醒自己，必须通过别的线程
    告诉操作系统，再由操作系统唤醒。Monitor是不能被并发访问的(否则Monitor状态会出错，操作系统根据错误的状态调度导致系统错乱)，
    而wait和notify 正是改变Monitor的状态（请参考 PV操作） 所以使用wait、notify方法时，必须对对象使用synchronized加锁，只有线程获
    取对象的Monitor锁之后才能进行wait、notify操作否则将抛出IllegalMonitorStateException异常。

    wait()将一个线程添加到等待集中，notifyAll()或者notify()解除等待线程的阻塞状态。
    wait相当于调用condition.await()，notifyAll等价于condition.signalAll()

    2、condition.await()，在进入临界区时，如果发现某一个条件满足后它才能执行，这时可以使用一个条件对象来管理那些
    已经获得了一个锁但是却不能做有用工作的线程。

    一个锁对象拥有多个相关的条件对象，可以用newCondition()获得一个条件对象，我们得到条件对象后调用await()，
    当前线程就会被阻塞了并放弃了锁。
    一旦一个线程调用 await()，它就会进入该条件的等待集并处于阻塞状态，直到另一个线程调用了同一个条件的signalAll()时为止。
    比如一个转账的代码，当发现转账方余额不足时，就调用await()放弃锁，让其它线程调用此方法给这个转账方转钱，
    只要调用signalAll()，就可以重新激活为这一条件而等待的线程。
    public void transfer(int from, int to, int amount) throws InterruptedException {
        aliPayLock.lock();
        try{
            while(accounts[from] < amount) {
                //阻塞当前线程，并放弃锁
                condition.await();
            }
            //转账操作
            accounts[from] = accounts[from] - amount;
            accounts[to] = accounts[to] + amount;

            condition.notifyAll();
        } finally{
            aliPayLock.unlock();
        }
    }


    3、所谓重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。
    synchronized 和 ReentrantLock 都是可重入锁。

    所谓不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。


    4、Java内存模型
        堆内存用来存储对象实例，被所有线程共享的运行时内存区域，存在内存可见性问题。
        线程之间的共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存中存储了该线程共享变量的副本。
        Java内存模型控制线程之间的通信，它决定了一个线程对主存共享变量的写入何时对另一个线程可见。
        线程A与线程B之间若要通信的话，必须经历下面两个步骤：
        ①线程A把线程A本地内存中更新过的共享变量刷新到主存中去。
        ②线程B到主存中去读取线程A之前已经更新过的共享变量。

        1）原子性
            原子性是指一个操作要么完成、要么失败，不能被中断，对基本数据变量的读取和赋值操作是原子操作。
            x = 3;//是原子操作
            x++;//不是原子操作
            x++这个动作，其实分为了三个过程：
            读取x的值、对x的值进行加1、向工作内存写入新的值。

            java.util.concurrent.atomic包中有很多类使用了很高效的机器级指令来保证其他操作的原子性。
            比如AtomicInteger类提供了incrementAndGet和decrementAndGet，它们分别以原子方式将一个整数自增和自减。
        2）可见性
            可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果，
            另一个线程马上就能看到。
            当一个共享变量被volatile修饰时，它会保证修改的值立即被更新到主存中，所以对其他线程是可见的。
        3）有序性
            Java内存模型中允许编译器和处理器对指令进行重排序，虽然重排序过程不会影响到单线程执行的正确性，
            但是会影响到多线程并发执行的正确性。这时可以通过volatile来保证有序性，除了volatile，也可以通过
            synchronized和Lock来保证有序性。

        5、sleep和wait的区别？
          1、sleep是线程中的方法，但是wait是Object中的方法。
          2、sleep方法不会释放lock，但是wait会释放，而且会加入到等待队列中。
          3、sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字。
          4、sleep不需要被唤醒（休眠之后推出阻塞），但是wait需要（不指定时间需要被别人中断）。

        6、t1、t2、t3线程顺序执行
            join
        7、多个线程同时执行
        CyclicBarrier 和 CountDownLatch 都可以用来让一组线程等待其它线程。与 CyclicBarrier 不同的是，CountdownLatch 不能重新使用。

6、锁的种类
    公平锁/非公平锁
    公平锁是指多个线程按照申请锁的顺序来获取锁。
    非公平锁是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，有可能，会造成优先级反转或者饥饿现象。

    独享锁/共享锁
    独享锁是指该锁一次只能被一个线程所持有。
    共享锁是指该锁可被多个线程所持有。

    互斥锁/读写锁
    上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。
    互斥锁在Java中的具体实现就是ReentrantLock，读写锁在Java中的具体实现就是ReadWriteLock。

    乐观锁/悲观锁
    乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。
    悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。
    乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。
    从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。

    悲观锁在Java中的使用，就是利用各种锁。
    乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。


    偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
    轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
    重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，
    还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。


六、基础概念
    1、hashcode equals 区别和使用场景
        Object中的equals()是对两个对象的地址值进行的比较（即比较引用是否相同）。String中重写了equals()，比较的是字符串的内容，
        如果两个对象地址相等则true，内容相等true，内容相等，地 址不同 ==为false
        hashCode()是一个本地方法，它的实现是根据本地机器相关的。

        equals()相等的两个对象，hashcode()一定相等；
        反过来：hashcode()不等，一定能推出equals()也不等；
        hashcode()相等，equals()可能相等，也可能不等。

    2、final finally finalize
        final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。
            在方法参数前面加final关键字就是为了防止数据在方法体中被修改。

            主要分两种情况：
            第一，用final修饰基本数据类型；
            第二，用final修饰引用类型。

            第一种情况，修饰基本类型（非引用类型）。这时参数的值在方法体内是不能被修改的，即不能被重新赋值。
            否则编译就通不过。
            第二种情况，修饰引用类型，这时可以改变值，但是不能重新赋值，
            引用类型变量所指的引用是不能够改变的，但是引用类型变量的值是可以改变的
        finally是异常处理语句结构的一部分，表示总是执行。
        finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。

    3、泛型和多态的意义和使用场景？
          泛型程序设计 （ Generic programming ) 意味着编写的代码可以被很多不同类型的对象所重用。
          就是将类型由原来的具体的类型参数化
          泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法
          extends、super

          多态是继封装、继承之后，面向对象的第三大特性。
          多态体现为父类引用变量可以指向子类对象。

          多态的三个必要条件：
              继承父类。
              重写父类的方法。
              父类的引用指向子类对象。

    4、抽象类和接口的区别：
        含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。含有abstract方法的类必须定义为abstract class，
        abstract class类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，
        所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。

        接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。
        接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。

        下面比较一下两者的语法区别：

        1.抽象类可以有构造方法，接口中不能有构造方法。
        2.抽象类中可以有普通成员变量，接口中没有普通成员变量
        3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。
        4.抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然
        eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。
        5.抽象类中可以包含静态方法，接口中不能包含静态方法
        6.抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。
        7.一个类可以实现多个接口，但只能继承一个抽象类。

        下面接着再说说两者在应用上的区别：
        接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。
        而抽象类在代码实现方面发挥作用，可以实现代码的重用

    5、匿名内部类
        如果某个局部类你只需要用一次，那么你就可以使用匿名内部类，它持有外部类的引用。
        只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现。
        比如，多线程中
        new Thread(){
            public void run() {
                System.out.println("匿名内部类线程");
            }
        }.start();



七、线程池
1、创建线程池的一些参数，什么时候创建核心线程，什么时候创建非核心线程？
      ThreadPoolExecutor(int corePoolSize,//核心线程数
                         int maximumPoolSize,//线程池所能容纳的最大线程数
                         long keepAliveTime,//非核心线程闲置时的超时时长，超过这个时长，非核心线程就会被回收
                         TimeUnit unit,//用于指定keepAliveTime的时间单位
                         BlockingQueue<Runnable> workQueue,//线程池中的任务队列
                         ThreadFactory threadFactory)//线程工厂为线程池提供创建线程的功能

      原理：
      ①如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务。
      ②如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务就会被插入到任务队列中排队等待执行。
      ③如果在步骤②中无法将任务插入到任务队列中，这往往是由于任务队列已满，这个时候如果线程数量
      未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务。
      ④如果步骤③中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务。

      ①线程是稀缺资源，使用线程池可以减少创建和销毁线程的次数，每个工作线程都可以重复使用。
      ②可以根据系统的承受能力，调整线程池中工作线程的数量，防止因为消耗过多内存导致服务器崩溃。

2、线程池中的怎样保证线程安全？
   ReentrantLock

3、四种线程池
      通过Executors类中的方法创建
      ①newFixedThreadPool()
      它是一中线程数量固定的线程池，当线程处于空闲状态时，它们并不会被回收，除非线程池被关闭了。
      只有核心线程且核心线程不会被回收，没有超时机制，任务队列也没有大小限制。

      ②newCachedThreadPool()
      它是一种线程数量不定的线程池，它只有非核心线程，最大线程数为Integer.MAX_VALUE。
      比较适合执行大量的耗时较少的任务。
      比如OkHttp中的Dispatcher

      ③newScheduledThreadPool()
      它的核心线程数量是固定的，而非核心线程数是没有限制的。主要用于执行定时任务和具有固定周期的
      重复任务。

      ④newSingleThreadExecutor()
      这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。它的意义在于统一
      所有的外界任务到一个线程中，这使得在这些任务之间不需要处理线程同步的问题。

八、HashMap
1、HashMap的实现原理？是否有序？
    无序、线程不安全，效率高
    数组+链表+红黑树（链表长度超过8）

    hash值冲突是发生在put()时，从源码可以看出，hash值是通过hash(key.hashCode())来获取的，当put的元素越来越多时，
    难免或出现不同的key产生相同的hash值问题，也即是hash冲突，当拿到一个hash值，通过indexFor(hash, table.length)获取数组下标，
    先查询是否存在该hash值，若不存在，则直接以Entry<V,V>的方式存放在数组中，若存在，则再对比key是否相同,若hash值和key都相同，
    则替换value，若hash值相同，key不相同，则形成一个单链表，将hash值相同，key不同的元素以Entry<V,V>的方式存放在链表中，
    这样就解决了hash冲突

2、哪一种map是有序的？LinkedHashMap是怎么实现有序的？
    LinkedHashMap
    有序的，底层存储结构是哈希表+链表，链表记录了添加数据的顺序

    TreeMap
    底层存储结构是二叉树，二叉树的中序遍历保证了数据的有序性

3、hashMap链表是头插还是尾插？
    JDK8以前是头插法，JDK8后是尾插法

4、HashMap的put()方法，时间复杂度？怎样使得HashMap线程安全？ConcurrentHashMap线程安全是怎样实现的？
      put操作的流程：
      第一步：key.hashcode()，时间复杂度O(1)。
      第二步：找到桶以后，判断桶里是否有元素，如果没有，直接new一个entry节点插入到数组中。时间复杂度O(1)。
      第三步：如果桶里有元素，并且元素个数小于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(n)=O(n)。
      第四步：如果桶里有元素，并且元素个数大于6，则调用equals方法，比较是否存在相同名字的key，不存在则new一个entry插入都链表尾部。时间复杂度O(1)+O(logn)=O(logn)。红黑树查询的时间复杂度是logn。

      通过上面的分析，我们可以得出结论，HashMap新增元素的时间复杂度是不固定的，可能的值有O(1)、O(logn)、O(n)。

      HashMap在put元素时，首先会计算key的hashcode，这时候不会去调用equals方法。为什么呢？因为equals方法的时间复杂度是O(n)。但是HashMap存在hash碰撞问题，最坏的情况下，所有的key都被分配到了同一个桶，这时map的put和get时间复杂度都是O(n)。
      所以HashMap的设计者必须要考虑的一个问题就是减少hash碰撞。

      HashMap解决哈希冲突采用的是哪种方式呢？
      答：HashMap解决哈希冲突采用的是链地址法。说白了就是把冲突的key连接起来，放到桶里。当桶中的元素个数不超过6个时，以单链表的形式串起来，当桶中的元素个数超过6个时，以红黑树的形式串起来。

      通过上面的分析，我们可以得出结论，HashMap的hash操作的时间复杂度是O(1)，HashMap的equals操作的时间复杂度是O(n)。



      三种方案：
          ①HashTable
          ②ConcurrentHashMap
          ③SynchronizedMap
          Map<String, String> map =  Collections.synchronizedMap(new HashMap<String, Strinig>());

      从性能上面看：
          ConcurrentHashMap > SynchronizedMap > Hashtable

      ConcurrentHashMap线程安全的原因：
      JDK 1.6 ConcurrentHashMap采用 分段锁的机制，实现并发的更新操作，底层采用数组+链表+红黑树的存储结构。
      其包含两个核心静态内部类 Segment和HashEntry。Segment继承自ReentrantLock。
      1.8的实现已经抛弃了Segment分段锁机制，利用CAS+Synchronized来保证并发更新的安全，底层依然采用数组+链表+红黑树的存储结构。



      在添加元素时候，采用synchronized来保证线程安全，然后计算size的时候采用CAS操作进行计算。

5、HashMap的作用？优势？扩容？
      查询速度快 O(1)
      动态可变长存储数据

      当HashMap中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，
      就要对HashMap的数组进行扩容，数组扩容这个操作也会出现在ArrayList中，这是一个常用的操作，
      而在HashMap数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是resize。

       那么HashMap什么时候进行扩容呢？
       当HashMap中的元素个数超过数组大小*loadFactor时，就会进行数组扩容，loadFactor的默认值为0.75，
       这是一个折中的取值。也就是说，默认情况下，数组大小为16，那么当HashMap中元素个数超过16*0.75=12的时候，
       就把数组的大小扩展为 2*16=32，即扩大一倍，然后重新计算每个元素在数组中的位置，扩容是需要进行数组复制的，
       复制数组是非常消耗性能的操作，所以如果我们已经预知HashMap中元素的个数，那么预设元素的个数能够有效的提高HashMap的性能。
6、你知道hash的实现吗？为什么要这样实现？
      在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h >>> 16)，
      主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，
      同时不会有太大的开销。
7、你知道get和put的原理吗？equals()和hashCode()的都有什么作用？
      通过对key的hashCode()进行hashing，并计算下标( (n-1) & hash)，从而获得buckets的位置。如果产生碰撞，
      则利用key.equals()方法去链表或树中去查找对应的节点。

九、网络相关
    1、HTTPS和HTTP的区别？SSL加密过程？
      HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，
      如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息

      安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL/TLS协议，
      SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

      1、https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。
      2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。
      3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
      4、http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

      SSL/TLS协议的基本过程（SSL：安全套接字协议，TLS：安全传输层协议）
      （1） 客户端向服务器端索要并验证公钥。
      （2） 双方协商生成"对话密钥"。
      （3） 双方采用"对话密钥"进行加密通信。

    2、报文
      请求报文：
          请求行   由请求方法、URL字段和http协议的版本组成
          请求头   会有0个或多个请求报头，每个请求报头都包含一个名字和一个值，之间用":"分割
          空行
          请求数据(post方法使用)
      响应报文：
          响应行、响应头、空行、响应正文

    3、http1.1和http2的区别？
    HTTP/2采用二进制格式而非文本格式
    HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
    使用报头压缩，HTTP/2降低了开销
    HTTP/2让服务器可以将响应主动“推送”到客户端缓存中

    4、网络分层
      物理层
      数据链路层
      网络层
      传输层
          TCP 可靠的面向连接的协议
          UDP 不可靠的、无连接的协议
      应用层
          HTTP、FTP